/* soapC.cpp
   Generated by gSOAP 2.8.89 for spr.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.89 2019-08-13 07:28:21 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType:
		return soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, NULL, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_wsrm__FaultCodes:
		return soap_in_wsrm__FaultCodes(soap, tag, NULL, "wsrm:FaultCodes");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_in_saml2__DecisionType(soap, tag, NULL, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_in_saml1__DecisionType(soap, tag, NULL, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_in_wsc__FaultCodeType(soap, tag, NULL, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, tag, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_arr__ArrayOfstring:
		return soap_in_arr__ArrayOfstring(soap, tag, NULL, "arr:ArrayOfstring");
	case SOAP_TYPE_wsrm__AcceptType:
		return soap_in_wsrm__AcceptType(soap, tag, NULL, "wsrm:AcceptType");
	case SOAP_TYPE_wsrm__OfferType:
		return soap_in_wsrm__OfferType(soap, tag, NULL, "wsrm:OfferType");
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return soap_in_wsrm__TerminateSequenceResponseType(soap, tag, NULL, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return soap_in_wsrm__TerminateSequenceType(soap, tag, NULL, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return soap_in_wsrm__CloseSequenceResponseType(soap, tag, NULL, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return soap_in_wsrm__CloseSequenceType(soap, tag, NULL, "wsrm:CloseSequenceType");
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return soap_in_wsrm__CreateSequenceResponseType(soap, tag, NULL, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return soap_in_wsrm__CreateSequenceType(soap, tag, NULL, "wsrm:CreateSequenceType");
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return soap_in_wsrm__SequenceFaultType(soap, tag, NULL, "wsrm:SequenceFaultType");
	case SOAP_TYPE_wsrm__AckRequestedType:
		return soap_in_wsrm__AckRequestedType(soap, tag, NULL, "wsrm:AckRequestedType");
	case SOAP_TYPE_wsrm__SequenceType:
		return soap_in_wsrm__SequenceType(soap, tag, NULL, "wsrm:SequenceType");
	case SOAP_TYPE_wst__ParticipantType:
		return soap_in_wst__ParticipantType(soap, tag, NULL, "wst:ParticipantType");
	case SOAP_TYPE_wst__ParticipantsType:
		return soap_in_wst__ParticipantsType(soap, tag, NULL, "wst:ParticipantsType");
	case SOAP_TYPE_wst__DelegateToType:
		return soap_in_wst__DelegateToType(soap, tag, NULL, "wst:DelegateToType");
	case SOAP_TYPE_wst__UseKeyType:
		return soap_in_wst__UseKeyType(soap, tag, NULL, "wst:UseKeyType");
	case SOAP_TYPE_wst__ProofEncryptionType:
		return soap_in_wst__ProofEncryptionType(soap, tag, NULL, "wst:ProofEncryptionType");
	case SOAP_TYPE_wst__EncryptionType:
		return soap_in_wst__EncryptionType(soap, tag, NULL, "wst:EncryptionType");
	case SOAP_TYPE_wst__OnBehalfOfType:
		return soap_in_wst__OnBehalfOfType(soap, tag, NULL, "wst:OnBehalfOfType");
	case SOAP_TYPE_wst__AuthenticatorType:
		return soap_in_wst__AuthenticatorType(soap, tag, NULL, "wst:AuthenticatorType");
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		return soap_in_wst__KeyExchangeTokenType(soap, tag, NULL, "wst:KeyExchangeTokenType");
	case SOAP_TYPE_wst__RequestKETType:
		return soap_in_wst__RequestKETType(soap, tag, NULL, "wst:RequestKETType");
	case SOAP_TYPE_wst__BinaryExchangeType:
		return soap_in_wst__BinaryExchangeType(soap, tag, NULL, "wst:BinaryExchangeType");
	case SOAP_TYPE_wst__SignChallengeType:
		return soap_in_wst__SignChallengeType(soap, tag, NULL, "wst:SignChallengeType");
	case SOAP_TYPE_wst__StatusType:
		return soap_in_wst__StatusType(soap, tag, NULL, "wst:StatusType");
	case SOAP_TYPE_wst__ValidateTargetType:
		return soap_in_wst__ValidateTargetType(soap, tag, NULL, "wst:ValidateTargetType");
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		return soap_in_wst__RequestedTokenCancelledType(soap, tag, NULL, "wst:RequestedTokenCancelledType");
	case SOAP_TYPE_wst__CancelTargetType:
		return soap_in_wst__CancelTargetType(soap, tag, NULL, "wst:CancelTargetType");
	case SOAP_TYPE_wst__RenewingType:
		return soap_in_wst__RenewingType(soap, tag, NULL, "wst:RenewingType");
	case SOAP_TYPE_wst__AllowPostdatingType:
		return soap_in_wst__AllowPostdatingType(soap, tag, NULL, "wst:AllowPostdatingType");
	case SOAP_TYPE_wst__RenewTargetType:
		return soap_in_wst__RenewTargetType(soap, tag, NULL, "wst:RenewTargetType");
	case SOAP_TYPE_wst__RequestedProofTokenType:
		return soap_in_wst__RequestedProofTokenType(soap, tag, NULL, "wst:RequestedProofTokenType");
	case SOAP_TYPE_wst__RequestedReferenceType:
		return soap_in_wst__RequestedReferenceType(soap, tag, NULL, "wst:RequestedReferenceType");
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		return soap_in_wst__RequestSecurityTokenResponseCollectionType(soap, tag, NULL, "wst:RequestSecurityTokenResponseCollectionType");
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		return soap_in_wst__RequestSecurityTokenCollectionType(soap, tag, NULL, "wst:RequestSecurityTokenCollectionType");
	case SOAP_TYPE_wst__LifetimeType:
		return soap_in_wst__LifetimeType(soap, tag, NULL, "wst:LifetimeType");
	case SOAP_TYPE_wst__EntropyType:
		return soap_in_wst__EntropyType(soap, tag, NULL, "wst:EntropyType");
	case SOAP_TYPE_wst__ClaimsType:
		return soap_in_wst__ClaimsType(soap, tag, NULL, "wst:ClaimsType");
	case SOAP_TYPE_wst__BinarySecretType:
		return soap_in_wst__BinarySecretType(soap, tag, NULL, "wst:BinarySecretType");
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		return soap_in_wst__RequestedSecurityTokenType(soap, tag, NULL, "wst:RequestedSecurityTokenType");
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		return soap_in_wst__RequestSecurityTokenResponseType(soap, tag, NULL, "wst:RequestSecurityTokenResponseType");
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		return soap_in_wst__RequestSecurityTokenType(soap, tag, NULL, "wst:RequestSecurityTokenType");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_in_saml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_in_saml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_in_saml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_in_saml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_in_saml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_in_saml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_in_saml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_in_saml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_in_saml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_in_saml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_in_saml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_in_saml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_in_saml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_in_saml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_in_saml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_in_saml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_in_saml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_in_saml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_in_saml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_in_saml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_in_saml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_in_saml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_in_saml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_in_saml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_in_wsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, tag, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, tag, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, tag, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_in_wsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		return soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, tag, NULL, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		return soap_in_PointerTowsrm__TerminateSequenceType(soap, tag, NULL, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		return soap_in_PointerTowsrm__CloseSequenceResponseType(soap, tag, NULL, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		return soap_in_PointerTowsrm__CloseSequenceType(soap, tag, NULL, "wsrm:CloseSequenceType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		return soap_in_PointerTowsrm__CreateSequenceResponseType(soap, tag, NULL, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		return soap_in_PointerTowsrm__CreateSequenceType(soap, tag, NULL, "wsrm:CreateSequenceType");
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		return soap_in_PointerTowsrm__SequenceFaultType(soap, tag, NULL, "wsrm:SequenceFaultType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement(soap, tag, NULL, "wsrm:SequenceAcknowledgement");
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		return soap_in_PointerTowsrm__AckRequestedType(soap, tag, NULL, "wsrm:AckRequestedType");
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		return soap_in_PointerTowsrm__SequenceType(soap, tag, NULL, "wsrm:SequenceType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag, NULL, "wsrm:SequenceAcknowledgement-None");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, NULL, "wsrm:SequenceAcknowledgement-AcknowledgementRange");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag, NULL, "wsrm:SequenceAcknowledgement-Final");
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		return soap_in_PointerTowsrm__AcceptType(soap, tag, NULL, "wsrm:AcceptType");
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		return soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag, NULL, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_PointerTowsrm__OfferType:
		return soap_in_PointerTowsrm__OfferType(soap, tag, NULL, "wsrm:OfferType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		return soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, tag, NULL, "wsrm:UsesSequenceSSL");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenCollectionType:
		return soap_in_PointerTowst__RequestSecurityTokenCollectionType(soap, tag, NULL, "wst:RequestSecurityTokenCollectionType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseCollectionType:
		return soap_in_PointerTowst__RequestSecurityTokenResponseCollectionType(soap, tag, NULL, "wst:RequestSecurityTokenResponseCollectionType");
	case SOAP_TYPE_PointerTowst__ParticipantType:
		return soap_in_PointerTowst__ParticipantType(soap, tag, NULL, "wst:ParticipantType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseType:
		return soap_in_PointerTowst__RequestSecurityTokenResponseType(soap, tag, NULL, "wst:RequestSecurityTokenResponseType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenType:
		return soap_in_PointerTowst__RequestSecurityTokenType(soap, tag, NULL, "wst:RequestSecurityTokenType");
	case SOAP_TYPE_PointerTowst__LifetimeType:
		return soap_in_PointerTowst__LifetimeType(soap, tag, NULL, "wst:LifetimeType");
	case SOAP_TYPE_PointerTowst__RequestedProofTokenType:
		return soap_in_PointerTowst__RequestedProofTokenType(soap, tag, NULL, "wst:RequestedProofTokenType");
	case SOAP_TYPE_PointerTowst__RequestedReferenceType:
		return soap_in_PointerTowst__RequestedReferenceType(soap, tag, NULL, "wst:RequestedReferenceType");
	case SOAP_TYPE_PointerTowst__RequestedSecurityTokenType:
		return soap_in_PointerTowst__RequestedSecurityTokenType(soap, tag, NULL, "wst:RequestedSecurityTokenType");
	case SOAP_TYPE_PointerTowst__AuthenticatorType:
		return soap_in_PointerTowst__AuthenticatorType(soap, tag, NULL, "wst:AuthenticatorType");
	case SOAP_TYPE_PointerTowst__BinaryExchangeType:
		return soap_in_PointerTowst__BinaryExchangeType(soap, tag, NULL, "wst:BinaryExchangeType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowst__EntropyType:
		return soap_in_PointerTowst__EntropyType(soap, tag, NULL, "wst:EntropyType");
	case SOAP_TYPE_PointerTo_wsp__AppliesTo_:
		return soap_in_PointerTo_wsp__AppliesTo_(soap, tag, NULL, "wsp:AppliesTo");
	case SOAP_TYPE_PointerTowst__BinarySecretType:
		return soap_in_PointerTowst__BinarySecretType(soap, tag, NULL, "wst:BinarySecretType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, tag, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, tag, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, tag, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_in_PointerTosaml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_in_PointerTosaml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_in_PointerTosaml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_in_PointerTosaml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_in_PointerTosaml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_in_PointerTosaml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_in_PointerTosaml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_in_PointerTosaml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_in_PointerTosaml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_in_PointerTosaml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_in_PointerTosaml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_in_PointerTosaml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_in_PointerTosaml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_in_PointerTosaml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_in_PointerTosaml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_in_PointerTosaml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_in_PointerTosaml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_in_PointerTosaml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_in_PointerTosaml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_in_PointerTosaml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_in_PointerTo_ds__Signature(soap, tag, NULL, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_in_PointerTosaml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_in_PointerTosaml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_in_PointerTosaml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_in_PointerTosaml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_in_PointerToULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_in_PointerTowsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
	{	char **s;
		s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, "wsc:FaultCodeOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, tag, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, tag, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, tag, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_in_PointerTowsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, tag, NULL, "wsse:Password");
	case SOAP_TYPE_PointerTo_tempuri__GetWarnings:
		return soap_in_PointerTo_tempuri__GetWarnings(soap, tag, NULL, "tempuri:GetWarnings");
	case SOAP_TYPE_PointerTo_tempuri__HasWarnings:
		return soap_in_PointerTo_tempuri__HasWarnings(soap, tag, NULL, "tempuri:HasWarnings");
	case SOAP_TYPE_PointerTo_tempuri__GetErrors:
		return soap_in_PointerTo_tempuri__GetErrors(soap, tag, NULL, "tempuri:GetErrors");
	case SOAP_TYPE_PointerTo_tempuri__HasErrors:
		return soap_in_PointerTo_tempuri__HasErrors(soap, tag, NULL, "tempuri:HasErrors");
	case SOAP_TYPE_PointerTo_tempuri__GetMessage:
		return soap_in_PointerTo_tempuri__GetMessage(soap, tag, NULL, "tempuri:GetMessage");
	case SOAP_TYPE_PointerTo_tempuri__HasMessage:
		return soap_in_PointerTo_tempuri__HasMessage(soap, tag, NULL, "tempuri:HasMessage");
	case SOAP_TYPE_PointerTo_tempuri__IsSamplePlateTrayIn:
		return soap_in_PointerTo_tempuri__IsSamplePlateTrayIn(soap, tag, NULL, "tempuri:IsSamplePlateTrayIn");
	case SOAP_TYPE_PointerTo_tempuri__IsChipDocked:
		return soap_in_PointerTo_tempuri__IsChipDocked(soap, tag, NULL, "tempuri:IsChipDocked");
	case SOAP_TYPE_PointerTo_tempuri__GetOperationMode:
		return soap_in_PointerTo_tempuri__GetOperationMode(soap, tag, NULL, "tempuri:GetOperationMode");
	case SOAP_TYPE_PointerTo_tempuri__RunMaintenanceProcedure:
		return soap_in_PointerTo_tempuri__RunMaintenanceProcedure(soap, tag, NULL, "tempuri:RunMaintenanceProcedure");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMaintenanceProcedures:
		return soap_in_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, tag, NULL, "tempuri:GetNamesOfMaintenanceProcedures");
	case SOAP_TYPE_PointerTo_tempuri__GetStandbyAfterFinish:
		return soap_in_PointerTo_tempuri__GetStandbyAfterFinish(soap, tag, NULL, "tempuri:GetStandbyAfterFinish");
	case SOAP_TYPE_PointerTo_tempuri__SetStandbyAfterFinish:
		return soap_in_PointerTo_tempuri__SetStandbyAfterFinish(soap, tag, NULL, "tempuri:SetStandbyAfterFinish");
	case SOAP_TYPE_PointerTo_tempuri__LeaveStandby:
		return soap_in_PointerTo_tempuri__LeaveStandby(soap, tag, NULL, "tempuri:LeaveStandby");
	case SOAP_TYPE_PointerTo_tempuri__AbortScript:
		return soap_in_PointerTo_tempuri__AbortScript(soap, tag, NULL, "tempuri:AbortScript");
	case SOAP_TYPE_PointerTo_tempuri__ResetRunset:
		return soap_in_PointerTo_tempuri__ResetRunset(soap, tag, NULL, "tempuri:ResetRunset");
	case SOAP_TYPE_PointerTo_tempuri__ResumeRunset:
		return soap_in_PointerTo_tempuri__ResumeRunset(soap, tag, NULL, "tempuri:ResumeRunset");
	case SOAP_TYPE_PointerTo_tempuri__PauseRunsetAfter:
		return soap_in_PointerTo_tempuri__PauseRunsetAfter(soap, tag, NULL, "tempuri:PauseRunsetAfter");
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunsetFrom:
		return soap_in_PointerTo_tempuri__StartSelectedRunsetFrom(soap, tag, NULL, "tempuri:StartSelectedRunsetFrom");
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunset:
		return soap_in_PointerTo_tempuri__StartSelectedRunset(soap, tag, NULL, "tempuri:StartSelectedRunset");
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayIn:
		return soap_in_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, tag, NULL, "tempuri:MoveSamplePlateTrayIn");
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayOut:
		return soap_in_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, tag, NULL, "tempuri:MoveSamplePlateTrayOut");
	case SOAP_TYPE_PointerTo_tempuri__GetCurrentSamplePlateId:
		return soap_in_PointerTo_tempuri__GetCurrentSamplePlateId(soap, tag, NULL, "tempuri:GetCurrentSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__GetSamplePlateId:
		return soap_in_PointerTo_tempuri__GetSamplePlateId(soap, tag, NULL, "tempuri:GetSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__SetSamplePlateId:
		return soap_in_PointerTo_tempuri__SetSamplePlateId(soap, tag, NULL, "tempuri:SetSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__CreateRunset:
		return soap_in_PointerTo_tempuri__CreateRunset(soap, tag, NULL, "tempuri:CreateRunset");
	case SOAP_TYPE_PointerTo_tempuri__SelectRunset:
		return soap_in_PointerTo_tempuri__SelectRunset(soap, tag, NULL, "tempuri:SelectRunset");
	case SOAP_TYPE_PointerTo_tempuri__SelectMethod:
		return soap_in_PointerTo_tempuri__SelectMethod(soap, tag, NULL, "tempuri:SelectMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetMethodNamesOfRunset:
		return soap_in_PointerTo_tempuri__GetMethodNamesOfRunset(soap, tag, NULL, "tempuri:GetMethodNamesOfRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfRunset:
		return soap_in_PointerTo_tempuri__GetAssayTypeOfRunset(soap, tag, NULL, "tempuri:GetAssayTypeOfRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentRunset:
		return soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, tag, NULL, "tempuri:GetAssayTypeOfCurrentRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentRunset:
		return soap_in_PointerTo_tempuri__GetNameOfCurrentRunset(soap, tag, NULL, "tempuri:GetNameOfCurrentRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllRunsets:
		return soap_in_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, tag, NULL, "tempuri:GetAssayTypesOfAllRunsets");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType:
		return soap_in_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, NULL, "tempuri:GetNamesOfRunsetsOfAssayType");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsets:
		return soap_in_PointerTo_tempuri__GetNamesOfRunsets(soap, tag, NULL, "tempuri:GetNamesOfRunsets");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfMethod:
		return soap_in_PointerTo_tempuri__GetAssayTypeOfMethod(soap, tag, NULL, "tempuri:GetAssayTypeOfMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentMethod:
		return soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, tag, NULL, "tempuri:GetAssayTypeOfCurrentMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentMethod:
		return soap_in_PointerTo_tempuri__GetNameOfCurrentMethod(soap, tag, NULL, "tempuri:GetNameOfCurrentMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllMethods:
		return soap_in_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, tag, NULL, "tempuri:GetAssayTypesOfAllMethods");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethodsOfAssayType:
		return soap_in_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, tag, NULL, "tempuri:GetNamesOfMethodsOfAssayType");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethods:
		return soap_in_PointerTo_tempuri__GetNamesOfMethods(soap, tag, NULL, "tempuri:GetNamesOfMethods");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		return soap_in_PointerToarr__ArrayOfstring(soap, tag, NULL, "arr:ArrayOfstring");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "arr:ArrayOfstring"))
		{	*type = SOAP_TYPE_arr__ArrayOfstring;
			return soap_in_arr__ArrayOfstring(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:IncompleteSequenceBehaviorType"))
		{	*type = SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType;
			return soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:FaultCodes"))
		{	*type = SOAP_TYPE_wsrm__FaultCodes;
			return soap_in_wsrm__FaultCodes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:DecisionType"))
		{	*type = SOAP_TYPE_saml2__DecisionType;
			return soap_in_saml2__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DecisionType"))
		{	*type = SOAP_TYPE_saml1__DecisionType;
			return soap_in_saml1__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeType"))
		{	*type = SOAP_TYPE_wsc__FaultCodeType;
			return soap_in_wsc__FaultCodeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:AcceptType"))
		{	*type = SOAP_TYPE_wsrm__AcceptType;
			return soap_in_wsrm__AcceptType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:OfferType"))
		{	*type = SOAP_TYPE_wsrm__OfferType;
			return soap_in_wsrm__OfferType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:TerminateSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__TerminateSequenceResponseType;
			return soap_in_wsrm__TerminateSequenceResponseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:TerminateSequenceType"))
		{	*type = SOAP_TYPE_wsrm__TerminateSequenceType;
			return soap_in_wsrm__TerminateSequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CloseSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__CloseSequenceResponseType;
			return soap_in_wsrm__CloseSequenceResponseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CloseSequenceType"))
		{	*type = SOAP_TYPE_wsrm__CloseSequenceType;
			return soap_in_wsrm__CloseSequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CreateSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__CreateSequenceResponseType;
			return soap_in_wsrm__CreateSequenceResponseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CreateSequenceType"))
		{	*type = SOAP_TYPE_wsrm__CreateSequenceType;
			return soap_in_wsrm__CreateSequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceFaultType"))
		{	*type = SOAP_TYPE_wsrm__SequenceFaultType;
			return soap_in_wsrm__SequenceFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:AckRequestedType"))
		{	*type = SOAP_TYPE_wsrm__AckRequestedType;
			return soap_in_wsrm__AckRequestedType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceType"))
		{	*type = SOAP_TYPE_wsrm__SequenceType;
			return soap_in_wsrm__SequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ParticipantType"))
		{	*type = SOAP_TYPE_wst__ParticipantType;
			return soap_in_wst__ParticipantType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ParticipantsType"))
		{	*type = SOAP_TYPE_wst__ParticipantsType;
			return soap_in_wst__ParticipantsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:DelegateToType"))
		{	*type = SOAP_TYPE_wst__DelegateToType;
			return soap_in_wst__DelegateToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:UseKeyType"))
		{	*type = SOAP_TYPE_wst__UseKeyType;
			return soap_in_wst__UseKeyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ProofEncryptionType"))
		{	*type = SOAP_TYPE_wst__ProofEncryptionType;
			return soap_in_wst__ProofEncryptionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:EncryptionType"))
		{	*type = SOAP_TYPE_wst__EncryptionType;
			return soap_in_wst__EncryptionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:OnBehalfOfType"))
		{	*type = SOAP_TYPE_wst__OnBehalfOfType;
			return soap_in_wst__OnBehalfOfType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:AuthenticatorType"))
		{	*type = SOAP_TYPE_wst__AuthenticatorType;
			return soap_in_wst__AuthenticatorType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:KeyExchangeTokenType"))
		{	*type = SOAP_TYPE_wst__KeyExchangeTokenType;
			return soap_in_wst__KeyExchangeTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestKETType"))
		{	*type = SOAP_TYPE_wst__RequestKETType;
			return soap_in_wst__RequestKETType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:BinaryExchangeType"))
		{	*type = SOAP_TYPE_wst__BinaryExchangeType;
			return soap_in_wst__BinaryExchangeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:SignChallengeType"))
		{	*type = SOAP_TYPE_wst__SignChallengeType;
			return soap_in_wst__SignChallengeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:StatusType"))
		{	*type = SOAP_TYPE_wst__StatusType;
			return soap_in_wst__StatusType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ValidateTargetType"))
		{	*type = SOAP_TYPE_wst__ValidateTargetType;
			return soap_in_wst__ValidateTargetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedTokenCancelledType"))
		{	*type = SOAP_TYPE_wst__RequestedTokenCancelledType;
			return soap_in_wst__RequestedTokenCancelledType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:CancelTargetType"))
		{	*type = SOAP_TYPE_wst__CancelTargetType;
			return soap_in_wst__CancelTargetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RenewingType"))
		{	*type = SOAP_TYPE_wst__RenewingType;
			return soap_in_wst__RenewingType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:AllowPostdatingType"))
		{	*type = SOAP_TYPE_wst__AllowPostdatingType;
			return soap_in_wst__AllowPostdatingType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RenewTargetType"))
		{	*type = SOAP_TYPE_wst__RenewTargetType;
			return soap_in_wst__RenewTargetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedProofTokenType"))
		{	*type = SOAP_TYPE_wst__RequestedProofTokenType;
			return soap_in_wst__RequestedProofTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedReferenceType"))
		{	*type = SOAP_TYPE_wst__RequestedReferenceType;
			return soap_in_wst__RequestedReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenResponseCollectionType"))
		{	*type = SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType;
			return soap_in_wst__RequestSecurityTokenResponseCollectionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenCollectionType"))
		{	*type = SOAP_TYPE_wst__RequestSecurityTokenCollectionType;
			return soap_in_wst__RequestSecurityTokenCollectionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:LifetimeType"))
		{	*type = SOAP_TYPE_wst__LifetimeType;
			return soap_in_wst__LifetimeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:EntropyType"))
		{	*type = SOAP_TYPE_wst__EntropyType;
			return soap_in_wst__EntropyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ClaimsType"))
		{	*type = SOAP_TYPE_wst__ClaimsType;
			return soap_in_wst__ClaimsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:BinarySecretType"))
		{	*type = SOAP_TYPE_wst__BinarySecretType;
			return soap_in_wst__BinarySecretType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedSecurityTokenType"))
		{	*type = SOAP_TYPE_wst__RequestedSecurityTokenType;
			return soap_in_wst__RequestedSecurityTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenResponseType"))
		{	*type = SOAP_TYPE_wst__RequestSecurityTokenResponseType;
			return soap_in_wst__RequestSecurityTokenResponseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenType"))
		{	*type = SOAP_TYPE_wst__RequestSecurityTokenType;
			return soap_in_wst__RequestSecurityTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeType"))
		{	*type = SOAP_TYPE_saml2__AttributeType;
			return soap_in_saml2__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml2__AttributeStatementType;
			return soap_in_saml2__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EvidenceType"))
		{	*type = SOAP_TYPE_saml2__EvidenceType;
			return soap_in_saml2__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ActionType"))
		{	*type = SOAP_TYPE_saml2__ActionType;
			return soap_in_saml2__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthzDecisionStatementType;
			return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextType"))
		{	*type = SOAP_TYPE_saml2__AuthnContextType;
			return soap_in_saml2__AuthnContextType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml2__SubjectLocalityType;
			return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthnStatementType;
			return soap_in_saml2__AuthnStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml2__StatementAbstractType;
			return soap_in_saml2__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AdviceType"))
		{	*type = SOAP_TYPE_saml2__AdviceType;
			return soap_in_saml2__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestrictionType"))
		{	*type = SOAP_TYPE_saml2__ProxyRestrictionType;
			return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUseType"))
		{	*type = SOAP_TYPE_saml2__OneTimeUseType;
			return soap_in_saml2__OneTimeUseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestrictionType"))
		{	*type = SOAP_TYPE_saml2__AudienceRestrictionType;
			return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml2__ConditionAbstractType;
			return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionsType"))
		{	*type = SOAP_TYPE_saml2__ConditionsType;
			return soap_in_saml2__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:KeyInfoConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__KeyInfoConfirmationDataType;
			return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationDataType;
			return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationType;
			return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectType"))
		{	*type = SOAP_TYPE_saml2__SubjectType;
			return soap_in_saml2__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionType"))
		{	*type = SOAP_TYPE_saml2__AssertionType;
			return soap_in_saml2__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedElementType"))
		{	*type = SOAP_TYPE_saml2__EncryptedElementType;
			return soap_in_saml2__EncryptedElementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameIDType"))
		{	*type = SOAP_TYPE_saml2__NameIDType;
			return soap_in_saml2__NameIDType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseIDAbstractType"))
		{	*type = SOAP_TYPE_saml2__BaseIDAbstractType;
			return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeType"))
		{	*type = SOAP_TYPE_saml1__AttributeType;
			return soap_in_saml1__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignatorType"))
		{	*type = SOAP_TYPE_saml1__AttributeDesignatorType;
			return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml1__AttributeStatementType;
			return soap_in_saml1__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:EvidenceType"))
		{	*type = SOAP_TYPE_saml1__EvidenceType;
			return soap_in_saml1__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ActionType"))
		{	*type = SOAP_TYPE_saml1__ActionType;
			return soap_in_saml1__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthorizationDecisionStatementType;
			return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBindingType"))
		{	*type = SOAP_TYPE_saml1__AuthorityBindingType;
			return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml1__SubjectLocalityType;
			return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthenticationStatementType;
			return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml1__SubjectConfirmationType;
			return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifierType"))
		{	*type = SOAP_TYPE_saml1__NameIdentifierType;
			return soap_in_saml1__NameIdentifierType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectType"))
		{	*type = SOAP_TYPE_saml1__SubjectType;
			return soap_in_saml1__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__SubjectStatementAbstractType;
			return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__StatementAbstractType;
			return soap_in_saml1__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AdviceType"))
		{	*type = SOAP_TYPE_saml1__AdviceType;
			return soap_in_saml1__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheConditionType"))
		{	*type = SOAP_TYPE_saml1__DoNotCacheConditionType;
			return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionConditionType"))
		{	*type = SOAP_TYPE_saml1__AudienceRestrictionConditionType;
			return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml1__ConditionAbstractType;
			return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionsType"))
		{	*type = SOAP_TYPE_saml1__ConditionsType;
			return soap_in_saml1__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionType"))
		{	*type = SOAP_TYPE_saml1__AssertionType;
			return soap_in_saml1__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:PropertiesType"))
		{	*type = SOAP_TYPE_wsc__PropertiesType;
			return soap_in_wsc__PropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:DerivedKeyTokenType"))
		{	*type = SOAP_TYPE_wsc__DerivedKeyTokenType;
			return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:SecurityContextTokenType"))
		{	*type = SOAP_TYPE_wsc__SecurityContextTokenType;
			return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:EncodedString"))
		{	*type = SOAP_TYPE_wsse__EncodedString;
			return soap_in_wsse__EncodedString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsc__FaultCodeOpenEnumType;
			s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wst:KeySize"))
		{	*type = SOAP_TYPE__wst__KeySize;
			return soap_in__wst__KeySize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetWarningsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetWarningsResponse;
			return soap_in__tempuri__GetWarningsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetWarnings"))
		{	*type = SOAP_TYPE__tempuri__GetWarnings;
			return soap_in__tempuri__GetWarnings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasWarningsResponse"))
		{	*type = SOAP_TYPE__tempuri__HasWarningsResponse;
			return soap_in__tempuri__HasWarningsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasWarnings"))
		{	*type = SOAP_TYPE__tempuri__HasWarnings;
			return soap_in__tempuri__HasWarnings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetErrorsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetErrorsResponse;
			return soap_in__tempuri__GetErrorsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetErrors"))
		{	*type = SOAP_TYPE__tempuri__GetErrors;
			return soap_in__tempuri__GetErrors(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasErrorsResponse"))
		{	*type = SOAP_TYPE__tempuri__HasErrorsResponse;
			return soap_in__tempuri__HasErrorsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasErrors"))
		{	*type = SOAP_TYPE__tempuri__HasErrors;
			return soap_in__tempuri__HasErrors(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetMessageResponse"))
		{	*type = SOAP_TYPE__tempuri__GetMessageResponse;
			return soap_in__tempuri__GetMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetMessage"))
		{	*type = SOAP_TYPE__tempuri__GetMessage;
			return soap_in__tempuri__GetMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasMessageResponse"))
		{	*type = SOAP_TYPE__tempuri__HasMessageResponse;
			return soap_in__tempuri__HasMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:HasMessage"))
		{	*type = SOAP_TYPE__tempuri__HasMessage;
			return soap_in__tempuri__HasMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:IsSamplePlateTrayInResponse"))
		{	*type = SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse;
			return soap_in__tempuri__IsSamplePlateTrayInResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:IsSamplePlateTrayIn"))
		{	*type = SOAP_TYPE__tempuri__IsSamplePlateTrayIn;
			return soap_in__tempuri__IsSamplePlateTrayIn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:IsChipDockedResponse"))
		{	*type = SOAP_TYPE__tempuri__IsChipDockedResponse;
			return soap_in__tempuri__IsChipDockedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:IsChipDocked"))
		{	*type = SOAP_TYPE__tempuri__IsChipDocked;
			return soap_in__tempuri__IsChipDocked(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetOperationModeResponse"))
		{	*type = SOAP_TYPE__tempuri__GetOperationModeResponse;
			return soap_in__tempuri__GetOperationModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetOperationMode"))
		{	*type = SOAP_TYPE__tempuri__GetOperationMode;
			return soap_in__tempuri__GetOperationMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:RunMaintenanceProcedureResponse"))
		{	*type = SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse;
			return soap_in__tempuri__RunMaintenanceProcedureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:RunMaintenanceProcedure"))
		{	*type = SOAP_TYPE__tempuri__RunMaintenanceProcedure;
			return soap_in__tempuri__RunMaintenanceProcedure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMaintenanceProceduresResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse;
			return soap_in__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMaintenanceProcedures"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures;
			return soap_in__tempuri__GetNamesOfMaintenanceProcedures(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetStandbyAfterFinishResponse"))
		{	*type = SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse;
			return soap_in__tempuri__GetStandbyAfterFinishResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetStandbyAfterFinish"))
		{	*type = SOAP_TYPE__tempuri__GetStandbyAfterFinish;
			return soap_in__tempuri__GetStandbyAfterFinish(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetStandbyAfterFinishResponse"))
		{	*type = SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse;
			return soap_in__tempuri__SetStandbyAfterFinishResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetStandbyAfterFinish"))
		{	*type = SOAP_TYPE__tempuri__SetStandbyAfterFinish;
			return soap_in__tempuri__SetStandbyAfterFinish(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LeaveStandbyResponse"))
		{	*type = SOAP_TYPE__tempuri__LeaveStandbyResponse;
			return soap_in__tempuri__LeaveStandbyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LeaveStandby"))
		{	*type = SOAP_TYPE__tempuri__LeaveStandby;
			return soap_in__tempuri__LeaveStandby(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AbortScriptResponse"))
		{	*type = SOAP_TYPE__tempuri__AbortScriptResponse;
			return soap_in__tempuri__AbortScriptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AbortScript"))
		{	*type = SOAP_TYPE__tempuri__AbortScript;
			return soap_in__tempuri__AbortScript(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ResetRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__ResetRunsetResponse;
			return soap_in__tempuri__ResetRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ResetRunset"))
		{	*type = SOAP_TYPE__tempuri__ResetRunset;
			return soap_in__tempuri__ResetRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ResumeRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__ResumeRunsetResponse;
			return soap_in__tempuri__ResumeRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ResumeRunset"))
		{	*type = SOAP_TYPE__tempuri__ResumeRunset;
			return soap_in__tempuri__ResumeRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:PauseRunsetAfterResponse"))
		{	*type = SOAP_TYPE__tempuri__PauseRunsetAfterResponse;
			return soap_in__tempuri__PauseRunsetAfterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:PauseRunsetAfter"))
		{	*type = SOAP_TYPE__tempuri__PauseRunsetAfter;
			return soap_in__tempuri__PauseRunsetAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:StartSelectedRunsetFromResponse"))
		{	*type = SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse;
			return soap_in__tempuri__StartSelectedRunsetFromResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:StartSelectedRunsetFrom"))
		{	*type = SOAP_TYPE__tempuri__StartSelectedRunsetFrom;
			return soap_in__tempuri__StartSelectedRunsetFrom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:StartSelectedRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__StartSelectedRunsetResponse;
			return soap_in__tempuri__StartSelectedRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:StartSelectedRunset"))
		{	*type = SOAP_TYPE__tempuri__StartSelectedRunset;
			return soap_in__tempuri__StartSelectedRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:MoveSamplePlateTrayInResponse"))
		{	*type = SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse;
			return soap_in__tempuri__MoveSamplePlateTrayInResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:MoveSamplePlateTrayIn"))
		{	*type = SOAP_TYPE__tempuri__MoveSamplePlateTrayIn;
			return soap_in__tempuri__MoveSamplePlateTrayIn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:MoveSamplePlateTrayOutResponse"))
		{	*type = SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse;
			return soap_in__tempuri__MoveSamplePlateTrayOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:MoveSamplePlateTrayOut"))
		{	*type = SOAP_TYPE__tempuri__MoveSamplePlateTrayOut;
			return soap_in__tempuri__MoveSamplePlateTrayOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetCurrentSamplePlateIdResponse"))
		{	*type = SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse;
			return soap_in__tempuri__GetCurrentSamplePlateIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetCurrentSamplePlateId"))
		{	*type = SOAP_TYPE__tempuri__GetCurrentSamplePlateId;
			return soap_in__tempuri__GetCurrentSamplePlateId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetSamplePlateIdResponse"))
		{	*type = SOAP_TYPE__tempuri__GetSamplePlateIdResponse;
			return soap_in__tempuri__GetSamplePlateIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetSamplePlateId"))
		{	*type = SOAP_TYPE__tempuri__GetSamplePlateId;
			return soap_in__tempuri__GetSamplePlateId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetSamplePlateIdResponse"))
		{	*type = SOAP_TYPE__tempuri__SetSamplePlateIdResponse;
			return soap_in__tempuri__SetSamplePlateIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetSamplePlateId"))
		{	*type = SOAP_TYPE__tempuri__SetSamplePlateId;
			return soap_in__tempuri__SetSamplePlateId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:CreateRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__CreateRunsetResponse;
			return soap_in__tempuri__CreateRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:CreateRunset"))
		{	*type = SOAP_TYPE__tempuri__CreateRunset;
			return soap_in__tempuri__CreateRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SelectRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__SelectRunsetResponse;
			return soap_in__tempuri__SelectRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SelectRunset"))
		{	*type = SOAP_TYPE__tempuri__SelectRunset;
			return soap_in__tempuri__SelectRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SelectMethodResponse"))
		{	*type = SOAP_TYPE__tempuri__SelectMethodResponse;
			return soap_in__tempuri__SelectMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SelectMethod"))
		{	*type = SOAP_TYPE__tempuri__SelectMethod;
			return soap_in__tempuri__SelectMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetMethodNamesOfRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse;
			return soap_in__tempuri__GetMethodNamesOfRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetMethodNamesOfRunset"))
		{	*type = SOAP_TYPE__tempuri__GetMethodNamesOfRunset;
			return soap_in__tempuri__GetMethodNamesOfRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse;
			return soap_in__tempuri__GetAssayTypeOfRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfRunset"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfRunset;
			return soap_in__tempuri__GetAssayTypeOfRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfCurrentRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse;
			return soap_in__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfCurrentRunset"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset;
			return soap_in__tempuri__GetAssayTypeOfCurrentRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNameOfCurrentRunsetResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse;
			return soap_in__tempuri__GetNameOfCurrentRunsetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNameOfCurrentRunset"))
		{	*type = SOAP_TYPE__tempuri__GetNameOfCurrentRunset;
			return soap_in__tempuri__GetNameOfCurrentRunset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypesOfAllRunsetsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse;
			return soap_in__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypesOfAllRunsets"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets;
			return soap_in__tempuri__GetAssayTypesOfAllRunsets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfRunsetsOfAssayTypeResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse;
			return soap_in__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfRunsetsOfAssayType"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType;
			return soap_in__tempuri__GetNamesOfRunsetsOfAssayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfRunsetsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse;
			return soap_in__tempuri__GetNamesOfRunsetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfRunsets"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfRunsets;
			return soap_in__tempuri__GetNamesOfRunsets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfMethodResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse;
			return soap_in__tempuri__GetAssayTypeOfMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfMethod"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfMethod;
			return soap_in__tempuri__GetAssayTypeOfMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfCurrentMethodResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse;
			return soap_in__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypeOfCurrentMethod"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod;
			return soap_in__tempuri__GetAssayTypeOfCurrentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNameOfCurrentMethodResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse;
			return soap_in__tempuri__GetNameOfCurrentMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNameOfCurrentMethod"))
		{	*type = SOAP_TYPE__tempuri__GetNameOfCurrentMethod;
			return soap_in__tempuri__GetNameOfCurrentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypesOfAllMethodsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse;
			return soap_in__tempuri__GetAssayTypesOfAllMethodsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetAssayTypesOfAllMethods"))
		{	*type = SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods;
			return soap_in__tempuri__GetAssayTypesOfAllMethods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMethodsOfAssayTypeResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse;
			return soap_in__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMethodsOfAssayType"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType;
			return soap_in__tempuri__GetNamesOfMethodsOfAssayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMethodsResponse"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMethodsResponse;
			return soap_in__tempuri__GetNamesOfMethodsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetNamesOfMethods"))
		{	*type = SOAP_TYPE__tempuri__GetNamesOfMethods;
			return soap_in__tempuri__GetNamesOfMethods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-None"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_None;
			return soap_in__wsrm__SequenceAcknowledgement_None(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-AcknowledgementRange"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange;
			return soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-Final"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_Final;
			return soap_in__wsrm__SequenceAcknowledgement_Final(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:UsesSequenceSSL"))
		{	*type = SOAP_TYPE__wsrm__UsesSequenceSSL;
			return soap_in__wsrm__UsesSequenceSSL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:UsesSequenceSTR"))
		{	*type = SOAP_TYPE__wsrm__UsesSequenceSTR;
			return soap_in__wsrm__UsesSequenceSTR(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement;
			return soap_in__wsrm__SequenceAcknowledgement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Participants"))
		{	*type = SOAP_TYPE__wst__Participants;
			return soap_in__wst__Participants(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:DelegateTo"))
		{	*type = SOAP_TYPE__wst__DelegateTo;
			return soap_in__wst__DelegateTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:UseKey"))
		{	*type = SOAP_TYPE__wst__UseKey;
			return soap_in__wst__UseKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ProofEncryption"))
		{	*type = SOAP_TYPE__wst__ProofEncryption;
			return soap_in__wst__ProofEncryption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Encryption"))
		{	*type = SOAP_TYPE__wst__Encryption;
			return soap_in__wst__Encryption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Issuer"))
		{	*type = SOAP_TYPE__wst__Issuer;
			return soap_in__wst__Issuer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:OnBehalfOf"))
		{	*type = SOAP_TYPE__wst__OnBehalfOf;
			return soap_in__wst__OnBehalfOf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Authenticator"))
		{	*type = SOAP_TYPE__wst__Authenticator;
			return soap_in__wst__Authenticator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:KeyExchangeToken"))
		{	*type = SOAP_TYPE__wst__KeyExchangeToken;
			return soap_in__wst__KeyExchangeToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestKET"))
		{	*type = SOAP_TYPE__wst__RequestKET;
			return soap_in__wst__RequestKET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:BinaryExchange"))
		{	*type = SOAP_TYPE__wst__BinaryExchange;
			return soap_in__wst__BinaryExchange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:SignChallengeResponse"))
		{	*type = SOAP_TYPE__wst__SignChallengeResponse;
			return soap_in__wst__SignChallengeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:SignChallenge"))
		{	*type = SOAP_TYPE__wst__SignChallenge;
			return soap_in__wst__SignChallenge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Status"))
		{	*type = SOAP_TYPE__wst__Status;
			return soap_in__wst__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:ValidateTarget"))
		{	*type = SOAP_TYPE__wst__ValidateTarget;
			return soap_in__wst__ValidateTarget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedTokenCancelled"))
		{	*type = SOAP_TYPE__wst__RequestedTokenCancelled;
			return soap_in__wst__RequestedTokenCancelled(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:CancelTarget"))
		{	*type = SOAP_TYPE__wst__CancelTarget;
			return soap_in__wst__CancelTarget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Renewing"))
		{	*type = SOAP_TYPE__wst__Renewing;
			return soap_in__wst__Renewing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:AllowPostdating"))
		{	*type = SOAP_TYPE__wst__AllowPostdating;
			return soap_in__wst__AllowPostdating(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RenewTarget"))
		{	*type = SOAP_TYPE__wst__RenewTarget;
			return soap_in__wst__RenewTarget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:IssuedTokens"))
		{	*type = SOAP_TYPE__wst__IssuedTokens;
			return soap_in__wst__IssuedTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedProofToken"))
		{	*type = SOAP_TYPE__wst__RequestedProofToken;
			return soap_in__wst__RequestedProofToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedUnattachedReference"))
		{	*type = SOAP_TYPE__wst__RequestedUnattachedReference;
			return soap_in__wst__RequestedUnattachedReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedAttachedReference"))
		{	*type = SOAP_TYPE__wst__RequestedAttachedReference;
			return soap_in__wst__RequestedAttachedReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenResponseCollection"))
		{	*type = SOAP_TYPE__wst__RequestSecurityTokenResponseCollection;
			return soap_in__wst__RequestSecurityTokenResponseCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenCollection"))
		{	*type = SOAP_TYPE__wst__RequestSecurityTokenCollection;
			return soap_in__wst__RequestSecurityTokenCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Lifetime"))
		{	*type = SOAP_TYPE__wst__Lifetime;
			return soap_in__wst__Lifetime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Entropy"))
		{	*type = SOAP_TYPE__wst__Entropy;
			return soap_in__wst__Entropy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Claims"))
		{	*type = SOAP_TYPE__wst__Claims;
			return soap_in__wst__Claims(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:BinarySecret"))
		{	*type = SOAP_TYPE__wst__BinarySecret;
			return soap_in__wst__BinarySecret(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestedSecurityToken"))
		{	*type = SOAP_TYPE__wst__RequestedSecurityToken;
			return soap_in__wst__RequestedSecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityTokenResponse"))
		{	*type = SOAP_TYPE__wst__RequestSecurityTokenResponse;
			return soap_in__wst__RequestSecurityTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:RequestSecurityToken"))
		{	*type = SOAP_TYPE__wst__RequestSecurityToken;
			return soap_in__wst__RequestSecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:AppliesTo"))
		{	*type = SOAP_TYPE__wsp__AppliesTo_;
			return soap_in__wsp__AppliesTo_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAttribute"))
		{	*type = SOAP_TYPE__saml2__EncryptedAttribute;
			return soap_in__saml2__EncryptedAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Attribute"))
		{	*type = SOAP_TYPE__saml2__Attribute;
			return soap_in__saml2__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatement"))
		{	*type = SOAP_TYPE__saml2__AttributeStatement;
			return soap_in__saml2__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Evidence"))
		{	*type = SOAP_TYPE__saml2__Evidence;
			return soap_in__saml2__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Action"))
		{	*type = SOAP_TYPE__saml2__Action;
			return soap_in__saml2__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatement"))
		{	*type = SOAP_TYPE__saml2__AuthzDecisionStatement;
			return soap_in__saml2__AuthzDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContext"))
		{	*type = SOAP_TYPE__saml2__AuthnContext;
			return soap_in__saml2__AuthnContext(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocality"))
		{	*type = SOAP_TYPE__saml2__SubjectLocality;
			return soap_in__saml2__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatement"))
		{	*type = SOAP_TYPE__saml2__AuthnStatement;
			return soap_in__saml2__AuthnStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Statement"))
		{	*type = SOAP_TYPE__saml2__Statement;
			return soap_in__saml2__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAssertion"))
		{	*type = SOAP_TYPE__saml2__EncryptedAssertion;
			return soap_in__saml2__EncryptedAssertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Advice"))
		{	*type = SOAP_TYPE__saml2__Advice;
			return soap_in__saml2__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestriction"))
		{	*type = SOAP_TYPE__saml2__ProxyRestriction;
			return soap_in__saml2__ProxyRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUse"))
		{	*type = SOAP_TYPE__saml2__OneTimeUse;
			return soap_in__saml2__OneTimeUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestriction"))
		{	*type = SOAP_TYPE__saml2__AudienceRestriction;
			return soap_in__saml2__AudienceRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Condition"))
		{	*type = SOAP_TYPE__saml2__Condition;
			return soap_in__saml2__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Conditions"))
		{	*type = SOAP_TYPE__saml2__Conditions;
			return soap_in__saml2__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationData"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmationData;
			return soap_in__saml2__SubjectConfirmationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmation;
			return soap_in__saml2__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Subject"))
		{	*type = SOAP_TYPE__saml2__Subject;
			return soap_in__saml2__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Assertion"))
		{	*type = SOAP_TYPE__saml2__Assertion;
			return soap_in__saml2__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Issuer"))
		{	*type = SOAP_TYPE__saml2__Issuer;
			return soap_in__saml2__Issuer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedID"))
		{	*type = SOAP_TYPE__saml2__EncryptedID;
			return soap_in__saml2__EncryptedID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameID"))
		{	*type = SOAP_TYPE__saml2__NameID;
			return soap_in__saml2__NameID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseID"))
		{	*type = SOAP_TYPE__saml2__BaseID;
			return soap_in__saml2__BaseID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Attribute"))
		{	*type = SOAP_TYPE__saml1__Attribute;
			return soap_in__saml1__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignator"))
		{	*type = SOAP_TYPE__saml1__AttributeDesignator;
			return soap_in__saml1__AttributeDesignator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatement"))
		{	*type = SOAP_TYPE__saml1__AttributeStatement;
			return soap_in__saml1__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Evidence"))
		{	*type = SOAP_TYPE__saml1__Evidence;
			return soap_in__saml1__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Action"))
		{	*type = SOAP_TYPE__saml1__Action;
			return soap_in__saml1__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatement"))
		{	*type = SOAP_TYPE__saml1__AuthorizationDecisionStatement;
			return soap_in__saml1__AuthorizationDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBinding"))
		{	*type = SOAP_TYPE__saml1__AuthorityBinding;
			return soap_in__saml1__AuthorityBinding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocality"))
		{	*type = SOAP_TYPE__saml1__SubjectLocality;
			return soap_in__saml1__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatement"))
		{	*type = SOAP_TYPE__saml1__AuthenticationStatement;
			return soap_in__saml1__AuthenticationStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml1__SubjectConfirmation;
			return soap_in__saml1__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifier"))
		{	*type = SOAP_TYPE__saml1__NameIdentifier;
			return soap_in__saml1__NameIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Subject"))
		{	*type = SOAP_TYPE__saml1__Subject;
			return soap_in__saml1__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatement"))
		{	*type = SOAP_TYPE__saml1__SubjectStatement;
			return soap_in__saml1__SubjectStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Statement"))
		{	*type = SOAP_TYPE__saml1__Statement;
			return soap_in__saml1__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Advice"))
		{	*type = SOAP_TYPE__saml1__Advice;
			return soap_in__saml1__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheCondition"))
		{	*type = SOAP_TYPE__saml1__DoNotCacheCondition;
			return soap_in__saml1__DoNotCacheCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionCondition"))
		{	*type = SOAP_TYPE__saml1__AudienceRestrictionCondition;
			return soap_in__saml1__AudienceRestrictionCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Condition"))
		{	*type = SOAP_TYPE__saml1__Condition;
			return soap_in__saml1__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Conditions"))
		{	*type = SOAP_TYPE__saml1__Conditions;
			return soap_in__saml1__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Assertion"))
		{	*type = SOAP_TYPE__saml1__Assertion;
			return soap_in__saml1__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:Identifier"))
		{	char **s;
			*type = SOAP_TYPE__wsrm__Identifier;
			s = soap_in__wsrm__Identifier(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:Delegatable"))
		{	char **s;
			*type = SOAP_TYPE__wst__Delegatable;
			s = soap_in__wst__Delegatable(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:Forwardable"))
		{	char **s;
			*type = SOAP_TYPE__wst__Forwardable;
			s = soap_in__wst__Forwardable(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:EncryptWith"))
		{	char **s;
			*type = SOAP_TYPE__wst__EncryptWith;
			s = soap_in__wst__EncryptWith(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:SignWith"))
		{	char **s;
			*type = SOAP_TYPE__wst__SignWith;
			s = soap_in__wst__SignWith(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:KeyWrapAlgorithm"))
		{	char **s;
			*type = SOAP_TYPE__wst__KeyWrapAlgorithm;
			s = soap_in__wst__KeyWrapAlgorithm(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:ComputedKeyAlgorithm"))
		{	char **s;
			*type = SOAP_TYPE__wst__ComputedKeyAlgorithm;
			s = soap_in__wst__ComputedKeyAlgorithm(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:CanonicalizationAlgorithm"))
		{	char **s;
			*type = SOAP_TYPE__wst__CanonicalizationAlgorithm;
			s = soap_in__wst__CanonicalizationAlgorithm(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:EncryptionAlgorithm"))
		{	char **s;
			*type = SOAP_TYPE__wst__EncryptionAlgorithm;
			s = soap_in__wst__EncryptionAlgorithm(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:SignatureAlgorithm"))
		{	char **s;
			*type = SOAP_TYPE__wst__SignatureAlgorithm;
			s = soap_in__wst__SignatureAlgorithm(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:KeyType"))
		{	char **s;
			*type = SOAP_TYPE__wst__KeyType;
			s = soap_in__wst__KeyType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:AuthenticationType"))
		{	char **s;
			*type = SOAP_TYPE__wst__AuthenticationType;
			s = soap_in__wst__AuthenticationType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:CombinedHash"))
		{	char **s;
			*type = SOAP_TYPE__wst__CombinedHash;
			s = soap_in__wst__CombinedHash(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:Challenge"))
		{	char **s;
			*type = SOAP_TYPE__wst__Challenge;
			s = soap_in__wst__Challenge(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:ComputedKey"))
		{	char **s;
			*type = SOAP_TYPE__wst__ComputedKey;
			s = soap_in__wst__ComputedKey(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:RequestType"))
		{	char **s;
			*type = SOAP_TYPE__wst__RequestType;
			s = soap_in__wst__RequestType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wst:TokenType"))
		{	char **s;
			*type = SOAP_TYPE__wst__TokenType;
			s = soap_in__wst__TokenType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthenticatingAuthority"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthenticatingAuthority;
			s = soap_in__saml2__AuthenticatingAuthority(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextDeclRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextDeclRef;
			s = soap_in__saml2__AuthnContextDeclRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextClassRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextClassRef;
			s = soap_in__saml2__AuthnContextClassRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml2__Audience;
			s = soap_in__saml2__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionURIRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionURIRef;
			s = soap_in__saml2__AssertionURIRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionIDRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionIDRef;
			s = soap_in__saml2__AssertionIDRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:ConfirmationMethod"))
		{	char **s;
			*type = SOAP_TYPE__saml1__ConfirmationMethod;
			s = soap_in__saml1__ConfirmationMethod(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml1__Audience;
			s = soap_in__saml1__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionIDReference"))
		{	char **s;
			*type = SOAP_TYPE__saml1__AssertionIDReference;
			s = soap_in__saml1__AssertionIDReference(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ds:SignatureValue"))
		{	char **s;
			*type = SOAP_TYPE__ds__SignatureValue;
			s = soap_in__ds__SignatureValue(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE__wst__KeySize:
		return soap_out__wst__KeySize(soap, "wst:KeySize", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType:
		return soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag, id, (const enum wsrm__IncompleteSequenceBehaviorType *)ptr, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_wsrm__FaultCodes:
		return soap_out_wsrm__FaultCodes(soap, tag, id, (const enum wsrm__FaultCodes *)ptr, "wsrm:FaultCodes");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_out_saml2__DecisionType(soap, tag, id, (const enum saml2__DecisionType *)ptr, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_out_saml1__DecisionType(soap, tag, id, (const enum saml1__DecisionType *)ptr, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_out_wsc__FaultCodeType(soap, tag, id, (const enum wsc__FaultCodeType *)ptr, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_arr__ArrayOfstring:
		return ((arr__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "arr:ArrayOfstring");
	case SOAP_TYPE__tempuri__GetWarningsResponse:
		return ((_tempuri__GetWarningsResponse *)ptr)->soap_out(soap, "tempuri:GetWarningsResponse", id, "");
	case SOAP_TYPE__tempuri__GetWarnings:
		return ((_tempuri__GetWarnings *)ptr)->soap_out(soap, "tempuri:GetWarnings", id, "");
	case SOAP_TYPE__tempuri__HasWarningsResponse:
		return ((_tempuri__HasWarningsResponse *)ptr)->soap_out(soap, "tempuri:HasWarningsResponse", id, "");
	case SOAP_TYPE__tempuri__HasWarnings:
		return ((_tempuri__HasWarnings *)ptr)->soap_out(soap, "tempuri:HasWarnings", id, "");
	case SOAP_TYPE__tempuri__GetErrorsResponse:
		return ((_tempuri__GetErrorsResponse *)ptr)->soap_out(soap, "tempuri:GetErrorsResponse", id, "");
	case SOAP_TYPE__tempuri__GetErrors:
		return ((_tempuri__GetErrors *)ptr)->soap_out(soap, "tempuri:GetErrors", id, "");
	case SOAP_TYPE__tempuri__HasErrorsResponse:
		return ((_tempuri__HasErrorsResponse *)ptr)->soap_out(soap, "tempuri:HasErrorsResponse", id, "");
	case SOAP_TYPE__tempuri__HasErrors:
		return ((_tempuri__HasErrors *)ptr)->soap_out(soap, "tempuri:HasErrors", id, "");
	case SOAP_TYPE__tempuri__GetMessageResponse:
		return ((_tempuri__GetMessageResponse *)ptr)->soap_out(soap, "tempuri:GetMessageResponse", id, "");
	case SOAP_TYPE__tempuri__GetMessage:
		return ((_tempuri__GetMessage *)ptr)->soap_out(soap, "tempuri:GetMessage", id, "");
	case SOAP_TYPE__tempuri__HasMessageResponse:
		return ((_tempuri__HasMessageResponse *)ptr)->soap_out(soap, "tempuri:HasMessageResponse", id, "");
	case SOAP_TYPE__tempuri__HasMessage:
		return ((_tempuri__HasMessage *)ptr)->soap_out(soap, "tempuri:HasMessage", id, "");
	case SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse:
		return ((_tempuri__IsSamplePlateTrayInResponse *)ptr)->soap_out(soap, "tempuri:IsSamplePlateTrayInResponse", id, "");
	case SOAP_TYPE__tempuri__IsSamplePlateTrayIn:
		return ((_tempuri__IsSamplePlateTrayIn *)ptr)->soap_out(soap, "tempuri:IsSamplePlateTrayIn", id, "");
	case SOAP_TYPE__tempuri__IsChipDockedResponse:
		return ((_tempuri__IsChipDockedResponse *)ptr)->soap_out(soap, "tempuri:IsChipDockedResponse", id, "");
	case SOAP_TYPE__tempuri__IsChipDocked:
		return ((_tempuri__IsChipDocked *)ptr)->soap_out(soap, "tempuri:IsChipDocked", id, "");
	case SOAP_TYPE__tempuri__GetOperationModeResponse:
		return ((_tempuri__GetOperationModeResponse *)ptr)->soap_out(soap, "tempuri:GetOperationModeResponse", id, "");
	case SOAP_TYPE__tempuri__GetOperationMode:
		return ((_tempuri__GetOperationMode *)ptr)->soap_out(soap, "tempuri:GetOperationMode", id, "");
	case SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse:
		return ((_tempuri__RunMaintenanceProcedureResponse *)ptr)->soap_out(soap, "tempuri:RunMaintenanceProcedureResponse", id, "");
	case SOAP_TYPE__tempuri__RunMaintenanceProcedure:
		return ((_tempuri__RunMaintenanceProcedure *)ptr)->soap_out(soap, "tempuri:RunMaintenanceProcedure", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse:
		return ((_tempuri__GetNamesOfMaintenanceProceduresResponse *)ptr)->soap_out(soap, "tempuri:GetNamesOfMaintenanceProceduresResponse", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures:
		return ((_tempuri__GetNamesOfMaintenanceProcedures *)ptr)->soap_out(soap, "tempuri:GetNamesOfMaintenanceProcedures", id, "");
	case SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse:
		return ((_tempuri__GetStandbyAfterFinishResponse *)ptr)->soap_out(soap, "tempuri:GetStandbyAfterFinishResponse", id, "");
	case SOAP_TYPE__tempuri__GetStandbyAfterFinish:
		return ((_tempuri__GetStandbyAfterFinish *)ptr)->soap_out(soap, "tempuri:GetStandbyAfterFinish", id, "");
	case SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse:
		return ((_tempuri__SetStandbyAfterFinishResponse *)ptr)->soap_out(soap, "tempuri:SetStandbyAfterFinishResponse", id, "");
	case SOAP_TYPE__tempuri__SetStandbyAfterFinish:
		return ((_tempuri__SetStandbyAfterFinish *)ptr)->soap_out(soap, "tempuri:SetStandbyAfterFinish", id, "");
	case SOAP_TYPE__tempuri__LeaveStandbyResponse:
		return ((_tempuri__LeaveStandbyResponse *)ptr)->soap_out(soap, "tempuri:LeaveStandbyResponse", id, "");
	case SOAP_TYPE__tempuri__LeaveStandby:
		return ((_tempuri__LeaveStandby *)ptr)->soap_out(soap, "tempuri:LeaveStandby", id, "");
	case SOAP_TYPE__tempuri__AbortScriptResponse:
		return ((_tempuri__AbortScriptResponse *)ptr)->soap_out(soap, "tempuri:AbortScriptResponse", id, "");
	case SOAP_TYPE__tempuri__AbortScript:
		return ((_tempuri__AbortScript *)ptr)->soap_out(soap, "tempuri:AbortScript", id, "");
	case SOAP_TYPE__tempuri__ResetRunsetResponse:
		return ((_tempuri__ResetRunsetResponse *)ptr)->soap_out(soap, "tempuri:ResetRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__ResetRunset:
		return ((_tempuri__ResetRunset *)ptr)->soap_out(soap, "tempuri:ResetRunset", id, "");
	case SOAP_TYPE__tempuri__ResumeRunsetResponse:
		return ((_tempuri__ResumeRunsetResponse *)ptr)->soap_out(soap, "tempuri:ResumeRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__ResumeRunset:
		return ((_tempuri__ResumeRunset *)ptr)->soap_out(soap, "tempuri:ResumeRunset", id, "");
	case SOAP_TYPE__tempuri__PauseRunsetAfterResponse:
		return ((_tempuri__PauseRunsetAfterResponse *)ptr)->soap_out(soap, "tempuri:PauseRunsetAfterResponse", id, "");
	case SOAP_TYPE__tempuri__PauseRunsetAfter:
		return ((_tempuri__PauseRunsetAfter *)ptr)->soap_out(soap, "tempuri:PauseRunsetAfter", id, "");
	case SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse:
		return ((_tempuri__StartSelectedRunsetFromResponse *)ptr)->soap_out(soap, "tempuri:StartSelectedRunsetFromResponse", id, "");
	case SOAP_TYPE__tempuri__StartSelectedRunsetFrom:
		return ((_tempuri__StartSelectedRunsetFrom *)ptr)->soap_out(soap, "tempuri:StartSelectedRunsetFrom", id, "");
	case SOAP_TYPE__tempuri__StartSelectedRunsetResponse:
		return ((_tempuri__StartSelectedRunsetResponse *)ptr)->soap_out(soap, "tempuri:StartSelectedRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__StartSelectedRunset:
		return ((_tempuri__StartSelectedRunset *)ptr)->soap_out(soap, "tempuri:StartSelectedRunset", id, "");
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse:
		return ((_tempuri__MoveSamplePlateTrayInResponse *)ptr)->soap_out(soap, "tempuri:MoveSamplePlateTrayInResponse", id, "");
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayIn:
		return ((_tempuri__MoveSamplePlateTrayIn *)ptr)->soap_out(soap, "tempuri:MoveSamplePlateTrayIn", id, "");
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse:
		return ((_tempuri__MoveSamplePlateTrayOutResponse *)ptr)->soap_out(soap, "tempuri:MoveSamplePlateTrayOutResponse", id, "");
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOut:
		return ((_tempuri__MoveSamplePlateTrayOut *)ptr)->soap_out(soap, "tempuri:MoveSamplePlateTrayOut", id, "");
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse:
		return ((_tempuri__GetCurrentSamplePlateIdResponse *)ptr)->soap_out(soap, "tempuri:GetCurrentSamplePlateIdResponse", id, "");
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateId:
		return ((_tempuri__GetCurrentSamplePlateId *)ptr)->soap_out(soap, "tempuri:GetCurrentSamplePlateId", id, "");
	case SOAP_TYPE__tempuri__GetSamplePlateIdResponse:
		return ((_tempuri__GetSamplePlateIdResponse *)ptr)->soap_out(soap, "tempuri:GetSamplePlateIdResponse", id, "");
	case SOAP_TYPE__tempuri__GetSamplePlateId:
		return ((_tempuri__GetSamplePlateId *)ptr)->soap_out(soap, "tempuri:GetSamplePlateId", id, "");
	case SOAP_TYPE__tempuri__SetSamplePlateIdResponse:
		return ((_tempuri__SetSamplePlateIdResponse *)ptr)->soap_out(soap, "tempuri:SetSamplePlateIdResponse", id, "");
	case SOAP_TYPE__tempuri__SetSamplePlateId:
		return ((_tempuri__SetSamplePlateId *)ptr)->soap_out(soap, "tempuri:SetSamplePlateId", id, "");
	case SOAP_TYPE__tempuri__CreateRunsetResponse:
		return ((_tempuri__CreateRunsetResponse *)ptr)->soap_out(soap, "tempuri:CreateRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__CreateRunset:
		return ((_tempuri__CreateRunset *)ptr)->soap_out(soap, "tempuri:CreateRunset", id, "");
	case SOAP_TYPE__tempuri__SelectRunsetResponse:
		return ((_tempuri__SelectRunsetResponse *)ptr)->soap_out(soap, "tempuri:SelectRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__SelectRunset:
		return ((_tempuri__SelectRunset *)ptr)->soap_out(soap, "tempuri:SelectRunset", id, "");
	case SOAP_TYPE__tempuri__SelectMethodResponse:
		return ((_tempuri__SelectMethodResponse *)ptr)->soap_out(soap, "tempuri:SelectMethodResponse", id, "");
	case SOAP_TYPE__tempuri__SelectMethod:
		return ((_tempuri__SelectMethod *)ptr)->soap_out(soap, "tempuri:SelectMethod", id, "");
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse:
		return ((_tempuri__GetMethodNamesOfRunsetResponse *)ptr)->soap_out(soap, "tempuri:GetMethodNamesOfRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunset:
		return ((_tempuri__GetMethodNamesOfRunset *)ptr)->soap_out(soap, "tempuri:GetMethodNamesOfRunset", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse:
		return ((_tempuri__GetAssayTypeOfRunsetResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunset:
		return ((_tempuri__GetAssayTypeOfRunset *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfRunset", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse:
		return ((_tempuri__GetAssayTypeOfCurrentRunsetResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfCurrentRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset:
		return ((_tempuri__GetAssayTypeOfCurrentRunset *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfCurrentRunset", id, "");
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse:
		return ((_tempuri__GetNameOfCurrentRunsetResponse *)ptr)->soap_out(soap, "tempuri:GetNameOfCurrentRunsetResponse", id, "");
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunset:
		return ((_tempuri__GetNameOfCurrentRunset *)ptr)->soap_out(soap, "tempuri:GetNameOfCurrentRunset", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse:
		return ((_tempuri__GetAssayTypesOfAllRunsetsResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypesOfAllRunsetsResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets:
		return ((_tempuri__GetAssayTypesOfAllRunsets *)ptr)->soap_out(soap, "tempuri:GetAssayTypesOfAllRunsets", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse:
		return ((_tempuri__GetNamesOfRunsetsOfAssayTypeResponse *)ptr)->soap_out(soap, "tempuri:GetNamesOfRunsetsOfAssayTypeResponse", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType:
		return ((_tempuri__GetNamesOfRunsetsOfAssayType *)ptr)->soap_out(soap, "tempuri:GetNamesOfRunsetsOfAssayType", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse:
		return ((_tempuri__GetNamesOfRunsetsResponse *)ptr)->soap_out(soap, "tempuri:GetNamesOfRunsetsResponse", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfRunsets:
		return ((_tempuri__GetNamesOfRunsets *)ptr)->soap_out(soap, "tempuri:GetNamesOfRunsets", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse:
		return ((_tempuri__GetAssayTypeOfMethodResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfMethodResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethod:
		return ((_tempuri__GetAssayTypeOfMethod *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfMethod", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse:
		return ((_tempuri__GetAssayTypeOfCurrentMethodResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfCurrentMethodResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod:
		return ((_tempuri__GetAssayTypeOfCurrentMethod *)ptr)->soap_out(soap, "tempuri:GetAssayTypeOfCurrentMethod", id, "");
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse:
		return ((_tempuri__GetNameOfCurrentMethodResponse *)ptr)->soap_out(soap, "tempuri:GetNameOfCurrentMethodResponse", id, "");
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethod:
		return ((_tempuri__GetNameOfCurrentMethod *)ptr)->soap_out(soap, "tempuri:GetNameOfCurrentMethod", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse:
		return ((_tempuri__GetAssayTypesOfAllMethodsResponse *)ptr)->soap_out(soap, "tempuri:GetAssayTypesOfAllMethodsResponse", id, "");
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods:
		return ((_tempuri__GetAssayTypesOfAllMethods *)ptr)->soap_out(soap, "tempuri:GetAssayTypesOfAllMethods", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse:
		return ((_tempuri__GetNamesOfMethodsOfAssayTypeResponse *)ptr)->soap_out(soap, "tempuri:GetNamesOfMethodsOfAssayTypeResponse", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType:
		return ((_tempuri__GetNamesOfMethodsOfAssayType *)ptr)->soap_out(soap, "tempuri:GetNamesOfMethodsOfAssayType", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMethodsResponse:
		return ((_tempuri__GetNamesOfMethodsResponse *)ptr)->soap_out(soap, "tempuri:GetNamesOfMethodsResponse", id, "");
	case SOAP_TYPE__tempuri__GetNamesOfMethods:
		return ((_tempuri__GetNamesOfMethods *)ptr)->soap_out(soap, "tempuri:GetNamesOfMethods", id, "");
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		return soap_out__wsrm__SequenceAcknowledgement_None(soap, "wsrm:SequenceAcknowledgement-None", id, (const struct _wsrm__SequenceAcknowledgement_None *)ptr, "");
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:SequenceAcknowledgement-AcknowledgementRange", id, (const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)ptr, "");
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		return soap_out__wsrm__SequenceAcknowledgement_Final(soap, "wsrm:SequenceAcknowledgement-Final", id, (const struct _wsrm__SequenceAcknowledgement_Final *)ptr, "");
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		return soap_out__wsrm__UsesSequenceSSL(soap, "wsrm:UsesSequenceSSL", id, (const struct _wsrm__UsesSequenceSSL *)ptr, "");
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		return soap_out__wsrm__UsesSequenceSTR(soap, "wsrm:UsesSequenceSTR", id, (const struct _wsrm__UsesSequenceSTR *)ptr, "");
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		return soap_out__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", id, (const struct _wsrm__SequenceAcknowledgement *)ptr, "");
	case SOAP_TYPE_wsrm__AcceptType:
		return soap_out_wsrm__AcceptType(soap, tag, id, (const struct wsrm__AcceptType *)ptr, "wsrm:AcceptType");
	case SOAP_TYPE_wsrm__OfferType:
		return soap_out_wsrm__OfferType(soap, tag, id, (const struct wsrm__OfferType *)ptr, "wsrm:OfferType");
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return soap_out_wsrm__TerminateSequenceResponseType(soap, tag, id, (const struct wsrm__TerminateSequenceResponseType *)ptr, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return soap_out_wsrm__TerminateSequenceType(soap, tag, id, (const struct wsrm__TerminateSequenceType *)ptr, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return soap_out_wsrm__CloseSequenceResponseType(soap, tag, id, (const struct wsrm__CloseSequenceResponseType *)ptr, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return soap_out_wsrm__CloseSequenceType(soap, tag, id, (const struct wsrm__CloseSequenceType *)ptr, "wsrm:CloseSequenceType");
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return soap_out_wsrm__CreateSequenceResponseType(soap, tag, id, (const struct wsrm__CreateSequenceResponseType *)ptr, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return soap_out_wsrm__CreateSequenceType(soap, tag, id, (const struct wsrm__CreateSequenceType *)ptr, "wsrm:CreateSequenceType");
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return soap_out_wsrm__SequenceFaultType(soap, tag, id, (const struct wsrm__SequenceFaultType *)ptr, "wsrm:SequenceFaultType");
	case SOAP_TYPE_wsrm__AckRequestedType:
		return soap_out_wsrm__AckRequestedType(soap, tag, id, (const struct wsrm__AckRequestedType *)ptr, "wsrm:AckRequestedType");
	case SOAP_TYPE_wsrm__SequenceType:
		return soap_out_wsrm__SequenceType(soap, tag, id, (const struct wsrm__SequenceType *)ptr, "wsrm:SequenceType");
	case SOAP_TYPE__wst__Participants:
		return soap_out__wst__Participants(soap, "wst:Participants", id, (const struct wst__ParticipantsType *)ptr, "");
	case SOAP_TYPE__wst__DelegateTo:
		return soap_out__wst__DelegateTo(soap, "wst:DelegateTo", id, (const struct wst__DelegateToType *)ptr, "");
	case SOAP_TYPE__wst__UseKey:
		return soap_out__wst__UseKey(soap, "wst:UseKey", id, (const struct wst__UseKeyType *)ptr, "");
	case SOAP_TYPE__wst__ProofEncryption:
		return soap_out__wst__ProofEncryption(soap, "wst:ProofEncryption", id, (const struct wst__ProofEncryptionType *)ptr, "");
	case SOAP_TYPE__wst__Encryption:
		return soap_out__wst__Encryption(soap, "wst:Encryption", id, (const struct wst__EncryptionType *)ptr, "");
	case SOAP_TYPE__wst__Issuer:
		return soap_out__wst__Issuer(soap, "wst:Issuer", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wst__OnBehalfOf:
		return soap_out__wst__OnBehalfOf(soap, "wst:OnBehalfOf", id, (const struct wst__OnBehalfOfType *)ptr, "");
	case SOAP_TYPE__wst__Authenticator:
		return soap_out__wst__Authenticator(soap, "wst:Authenticator", id, (const struct wst__AuthenticatorType *)ptr, "");
	case SOAP_TYPE__wst__KeyExchangeToken:
		return soap_out__wst__KeyExchangeToken(soap, "wst:KeyExchangeToken", id, (const struct wst__KeyExchangeTokenType *)ptr, "");
	case SOAP_TYPE__wst__RequestKET:
		return soap_out__wst__RequestKET(soap, "wst:RequestKET", id, (const struct wst__RequestKETType *)ptr, "");
	case SOAP_TYPE__wst__BinaryExchange:
		return soap_out__wst__BinaryExchange(soap, "wst:BinaryExchange", id, (const struct wst__BinaryExchangeType *)ptr, "");
	case SOAP_TYPE__wst__SignChallengeResponse:
		return soap_out__wst__SignChallengeResponse(soap, "wst:SignChallengeResponse", id, (const struct wst__SignChallengeType *)ptr, "");
	case SOAP_TYPE__wst__SignChallenge:
		return soap_out__wst__SignChallenge(soap, "wst:SignChallenge", id, (const struct wst__SignChallengeType *)ptr, "");
	case SOAP_TYPE__wst__Status:
		return soap_out__wst__Status(soap, "wst:Status", id, (const struct wst__StatusType *)ptr, "");
	case SOAP_TYPE__wst__ValidateTarget:
		return soap_out__wst__ValidateTarget(soap, "wst:ValidateTarget", id, (const struct wst__ValidateTargetType *)ptr, "");
	case SOAP_TYPE__wst__RequestedTokenCancelled:
		return soap_out__wst__RequestedTokenCancelled(soap, "wst:RequestedTokenCancelled", id, (const struct wst__RequestedTokenCancelledType *)ptr, "");
	case SOAP_TYPE__wst__CancelTarget:
		return soap_out__wst__CancelTarget(soap, "wst:CancelTarget", id, (const struct wst__CancelTargetType *)ptr, "");
	case SOAP_TYPE__wst__Renewing:
		return soap_out__wst__Renewing(soap, "wst:Renewing", id, (const struct wst__RenewingType *)ptr, "");
	case SOAP_TYPE__wst__AllowPostdating:
		return soap_out__wst__AllowPostdating(soap, "wst:AllowPostdating", id, (const struct wst__AllowPostdatingType *)ptr, "");
	case SOAP_TYPE__wst__RenewTarget:
		return soap_out__wst__RenewTarget(soap, "wst:RenewTarget", id, (const struct wst__RenewTargetType *)ptr, "");
	case SOAP_TYPE__wst__IssuedTokens:
		return soap_out__wst__IssuedTokens(soap, "wst:IssuedTokens", id, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr, "");
	case SOAP_TYPE__wst__RequestedProofToken:
		return soap_out__wst__RequestedProofToken(soap, "wst:RequestedProofToken", id, (const struct wst__RequestedProofTokenType *)ptr, "");
	case SOAP_TYPE__wst__RequestedUnattachedReference:
		return soap_out__wst__RequestedUnattachedReference(soap, "wst:RequestedUnattachedReference", id, (const struct wst__RequestedReferenceType *)ptr, "");
	case SOAP_TYPE__wst__RequestedAttachedReference:
		return soap_out__wst__RequestedAttachedReference(soap, "wst:RequestedAttachedReference", id, (const struct wst__RequestedReferenceType *)ptr, "");
	case SOAP_TYPE__wst__RequestSecurityTokenResponseCollection:
		return soap_out__wst__RequestSecurityTokenResponseCollection(soap, "wst:RequestSecurityTokenResponseCollection", id, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr, "");
	case SOAP_TYPE__wst__RequestSecurityTokenCollection:
		return soap_out__wst__RequestSecurityTokenCollection(soap, "wst:RequestSecurityTokenCollection", id, (const struct wst__RequestSecurityTokenCollectionType *)ptr, "");
	case SOAP_TYPE__wst__Lifetime:
		return soap_out__wst__Lifetime(soap, "wst:Lifetime", id, (const struct wst__LifetimeType *)ptr, "");
	case SOAP_TYPE__wst__Entropy:
		return soap_out__wst__Entropy(soap, "wst:Entropy", id, (const struct wst__EntropyType *)ptr, "");
	case SOAP_TYPE__wst__Claims:
		return soap_out__wst__Claims(soap, "wst:Claims", id, (const struct wst__ClaimsType *)ptr, "");
	case SOAP_TYPE__wst__BinarySecret:
		return soap_out__wst__BinarySecret(soap, "wst:BinarySecret", id, (const struct wst__BinarySecretType *)ptr, "");
	case SOAP_TYPE__wst__RequestedSecurityToken:
		return soap_out__wst__RequestedSecurityToken(soap, "wst:RequestedSecurityToken", id, (const struct wst__RequestedSecurityTokenType *)ptr, "");
	case SOAP_TYPE__wst__RequestSecurityTokenResponse:
		return soap_out__wst__RequestSecurityTokenResponse(soap, "wst:RequestSecurityTokenResponse", id, (const struct wst__RequestSecurityTokenResponseType *)ptr, "");
	case SOAP_TYPE__wst__RequestSecurityToken:
		return soap_out__wst__RequestSecurityToken(soap, "wst:RequestSecurityToken", id, (const struct wst__RequestSecurityTokenType *)ptr, "");
	case SOAP_TYPE_wst__ParticipantType:
		return soap_out_wst__ParticipantType(soap, tag, id, (const struct wst__ParticipantType *)ptr, "wst:ParticipantType");
	case SOAP_TYPE_wst__ParticipantsType:
		return soap_out_wst__ParticipantsType(soap, tag, id, (const struct wst__ParticipantsType *)ptr, "wst:ParticipantsType");
	case SOAP_TYPE_wst__DelegateToType:
		return soap_out_wst__DelegateToType(soap, tag, id, (const struct wst__DelegateToType *)ptr, "wst:DelegateToType");
	case SOAP_TYPE_wst__UseKeyType:
		return soap_out_wst__UseKeyType(soap, tag, id, (const struct wst__UseKeyType *)ptr, "wst:UseKeyType");
	case SOAP_TYPE_wst__ProofEncryptionType:
		return soap_out_wst__ProofEncryptionType(soap, tag, id, (const struct wst__ProofEncryptionType *)ptr, "wst:ProofEncryptionType");
	case SOAP_TYPE_wst__EncryptionType:
		return soap_out_wst__EncryptionType(soap, tag, id, (const struct wst__EncryptionType *)ptr, "wst:EncryptionType");
	case SOAP_TYPE_wst__OnBehalfOfType:
		return soap_out_wst__OnBehalfOfType(soap, tag, id, (const struct wst__OnBehalfOfType *)ptr, "wst:OnBehalfOfType");
	case SOAP_TYPE_wst__AuthenticatorType:
		return soap_out_wst__AuthenticatorType(soap, tag, id, (const struct wst__AuthenticatorType *)ptr, "wst:AuthenticatorType");
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		return soap_out_wst__KeyExchangeTokenType(soap, tag, id, (const struct wst__KeyExchangeTokenType *)ptr, "wst:KeyExchangeTokenType");
	case SOAP_TYPE_wst__RequestKETType:
		return soap_out_wst__RequestKETType(soap, tag, id, (const struct wst__RequestKETType *)ptr, "wst:RequestKETType");
	case SOAP_TYPE_wst__BinaryExchangeType:
		return soap_out_wst__BinaryExchangeType(soap, tag, id, (const struct wst__BinaryExchangeType *)ptr, "wst:BinaryExchangeType");
	case SOAP_TYPE_wst__SignChallengeType:
		return soap_out_wst__SignChallengeType(soap, tag, id, (const struct wst__SignChallengeType *)ptr, "wst:SignChallengeType");
	case SOAP_TYPE_wst__StatusType:
		return soap_out_wst__StatusType(soap, tag, id, (const struct wst__StatusType *)ptr, "wst:StatusType");
	case SOAP_TYPE_wst__ValidateTargetType:
		return soap_out_wst__ValidateTargetType(soap, tag, id, (const struct wst__ValidateTargetType *)ptr, "wst:ValidateTargetType");
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		return soap_out_wst__RequestedTokenCancelledType(soap, tag, id, (const struct wst__RequestedTokenCancelledType *)ptr, "wst:RequestedTokenCancelledType");
	case SOAP_TYPE_wst__CancelTargetType:
		return soap_out_wst__CancelTargetType(soap, tag, id, (const struct wst__CancelTargetType *)ptr, "wst:CancelTargetType");
	case SOAP_TYPE_wst__RenewingType:
		return soap_out_wst__RenewingType(soap, tag, id, (const struct wst__RenewingType *)ptr, "wst:RenewingType");
	case SOAP_TYPE_wst__AllowPostdatingType:
		return soap_out_wst__AllowPostdatingType(soap, tag, id, (const struct wst__AllowPostdatingType *)ptr, "wst:AllowPostdatingType");
	case SOAP_TYPE_wst__RenewTargetType:
		return soap_out_wst__RenewTargetType(soap, tag, id, (const struct wst__RenewTargetType *)ptr, "wst:RenewTargetType");
	case SOAP_TYPE_wst__RequestedProofTokenType:
		return soap_out_wst__RequestedProofTokenType(soap, tag, id, (const struct wst__RequestedProofTokenType *)ptr, "wst:RequestedProofTokenType");
	case SOAP_TYPE_wst__RequestedReferenceType:
		return soap_out_wst__RequestedReferenceType(soap, tag, id, (const struct wst__RequestedReferenceType *)ptr, "wst:RequestedReferenceType");
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		return soap_out_wst__RequestSecurityTokenResponseCollectionType(soap, tag, id, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr, "wst:RequestSecurityTokenResponseCollectionType");
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		return soap_out_wst__RequestSecurityTokenCollectionType(soap, tag, id, (const struct wst__RequestSecurityTokenCollectionType *)ptr, "wst:RequestSecurityTokenCollectionType");
	case SOAP_TYPE_wst__LifetimeType:
		return soap_out_wst__LifetimeType(soap, tag, id, (const struct wst__LifetimeType *)ptr, "wst:LifetimeType");
	case SOAP_TYPE_wst__EntropyType:
		return soap_out_wst__EntropyType(soap, tag, id, (const struct wst__EntropyType *)ptr, "wst:EntropyType");
	case SOAP_TYPE_wst__ClaimsType:
		return soap_out_wst__ClaimsType(soap, tag, id, (const struct wst__ClaimsType *)ptr, "wst:ClaimsType");
	case SOAP_TYPE_wst__BinarySecretType:
		return soap_out_wst__BinarySecretType(soap, tag, id, (const struct wst__BinarySecretType *)ptr, "wst:BinarySecretType");
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		return soap_out_wst__RequestedSecurityTokenType(soap, tag, id, (const struct wst__RequestedSecurityTokenType *)ptr, "wst:RequestedSecurityTokenType");
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		return soap_out_wst__RequestSecurityTokenResponseType(soap, tag, id, (const struct wst__RequestSecurityTokenResponseType *)ptr, "wst:RequestSecurityTokenResponseType");
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		return soap_out_wst__RequestSecurityTokenType(soap, tag, id, (const struct wst__RequestSecurityTokenType *)ptr, "wst:RequestSecurityTokenType");
	case SOAP_TYPE__wsp__AppliesTo_:
		return soap_out__wsp__AppliesTo_(soap, "wsp:AppliesTo", id, (const struct _wsp__AppliesTo_ *)ptr, "");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAttribute:
		return soap_out__saml2__EncryptedAttribute(soap, "saml2:EncryptedAttribute", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Attribute:
		return soap_out__saml2__Attribute(soap, "saml2:Attribute", id, (const struct saml2__AttributeType *)ptr, "");
	case SOAP_TYPE__saml2__AttributeStatement:
		return soap_out__saml2__AttributeStatement(soap, "saml2:AttributeStatement", id, (const struct saml2__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Evidence:
		return soap_out__saml2__Evidence(soap, "saml2:Evidence", id, (const struct saml2__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml2__Action:
		return soap_out__saml2__Action(soap, "saml2:Action", id, (const struct saml2__ActionType *)ptr, "");
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		return soap_out__saml2__AuthzDecisionStatement(soap, "saml2:AuthzDecisionStatement", id, (const struct saml2__AuthzDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnContext:
		return soap_out__saml2__AuthnContext(soap, "saml2:AuthnContext", id, (const struct saml2__AuthnContextType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectLocality:
		return soap_out__saml2__SubjectLocality(soap, "saml2:SubjectLocality", id, (const struct saml2__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnStatement:
		return soap_out__saml2__AuthnStatement(soap, "saml2:AuthnStatement", id, (const struct saml2__AuthnStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Statement:
		return soap_out__saml2__Statement(soap, "saml2:Statement", id, (const struct saml2__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAssertion:
		return soap_out__saml2__EncryptedAssertion(soap, "saml2:EncryptedAssertion", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Advice:
		return soap_out__saml2__Advice(soap, "saml2:Advice", id, (const struct saml2__AdviceType *)ptr, "");
	case SOAP_TYPE__saml2__ProxyRestriction:
		return soap_out__saml2__ProxyRestriction(soap, "saml2:ProxyRestriction", id, (const struct saml2__ProxyRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__OneTimeUse:
		return soap_out__saml2__OneTimeUse(soap, "saml2:OneTimeUse", id, (const struct saml2__OneTimeUseType *)ptr, "");
	case SOAP_TYPE__saml2__AudienceRestriction:
		return soap_out__saml2__AudienceRestriction(soap, "saml2:AudienceRestriction", id, (const struct saml2__AudienceRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__Condition:
		return soap_out__saml2__Condition(soap, "saml2:Condition", id, (const struct saml2__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__Conditions:
		return soap_out__saml2__Conditions(soap, "saml2:Conditions", id, (const struct saml2__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		return soap_out__saml2__SubjectConfirmationData(soap, "saml2:SubjectConfirmationData", id, (const struct saml2__SubjectConfirmationDataType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmation:
		return soap_out__saml2__SubjectConfirmation(soap, "saml2:SubjectConfirmation", id, (const struct saml2__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml2__Subject:
		return soap_out__saml2__Subject(soap, "saml2:Subject", id, (const struct saml2__SubjectType *)ptr, "");
	case SOAP_TYPE__saml2__Assertion:
		return soap_out__saml2__Assertion(soap, "saml2:Assertion", id, (const struct saml2__AssertionType *)ptr, "");
	case SOAP_TYPE__saml2__Issuer:
		return soap_out__saml2__Issuer(soap, "saml2:Issuer", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedID:
		return soap_out__saml2__EncryptedID(soap, "saml2:EncryptedID", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__NameID:
		return soap_out__saml2__NameID(soap, "saml2:NameID", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__BaseID:
		return soap_out__saml2__BaseID(soap, "saml2:BaseID", id, (const struct saml2__BaseIDAbstractType *)ptr, "");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_out_saml2__AttributeType(soap, tag, id, (const struct saml2__AttributeType *)ptr, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_out_saml2__AttributeStatementType(soap, tag, id, (const struct saml2__AttributeStatementType *)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_out_saml2__EvidenceType(soap, tag, id, (const struct saml2__EvidenceType *)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_out_saml2__ActionType(soap, tag, id, (const struct saml2__ActionType *)ptr, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, (const struct saml2__AuthzDecisionStatementType *)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_out_saml2__AuthnContextType(soap, tag, id, (const struct saml2__AuthnContextType *)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_out_saml2__SubjectLocalityType(soap, tag, id, (const struct saml2__SubjectLocalityType *)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_out_saml2__AuthnStatementType(soap, tag, id, (const struct saml2__AuthnStatementType *)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_out_saml2__StatementAbstractType(soap, tag, id, (const struct saml2__StatementAbstractType *)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_out_saml2__AdviceType(soap, tag, id, (const struct saml2__AdviceType *)ptr, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_out_saml2__ProxyRestrictionType(soap, tag, id, (const struct saml2__ProxyRestrictionType *)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_out_saml2__OneTimeUseType(soap, tag, id, (const struct saml2__OneTimeUseType *)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_out_saml2__AudienceRestrictionType(soap, tag, id, (const struct saml2__AudienceRestrictionType *)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_out_saml2__ConditionAbstractType(soap, tag, id, (const struct saml2__ConditionAbstractType *)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_out_saml2__ConditionsType(soap, tag, id, (const struct saml2__ConditionsType *)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_out_saml2__KeyInfoConfirmationDataType(soap, tag, id, (const struct saml2__KeyInfoConfirmationDataType *)ptr, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, (const struct saml2__SubjectConfirmationDataType *)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_out_saml2__SubjectConfirmationType(soap, tag, id, (const struct saml2__SubjectConfirmationType *)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_out_saml2__SubjectType(soap, tag, id, (const struct saml2__SubjectType *)ptr, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_out_saml2__AssertionType(soap, tag, id, (const struct saml2__AssertionType *)ptr, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_out_saml2__EncryptedElementType(soap, tag, id, (const struct saml2__EncryptedElementType *)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_out_saml2__NameIDType(soap, tag, id, (const struct saml2__NameIDType *)ptr, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_out_saml2__BaseIDAbstractType(soap, tag, id, (const struct saml2__BaseIDAbstractType *)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE__saml1__Attribute:
		return soap_out__saml1__Attribute(soap, "saml1:Attribute", id, (const struct saml1__AttributeType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeDesignator:
		return soap_out__saml1__AttributeDesignator(soap, "saml1:AttributeDesignator", id, (const struct saml1__AttributeDesignatorType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeStatement:
		return soap_out__saml1__AttributeStatement(soap, "saml1:AttributeStatement", id, (const struct saml1__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml1__Evidence:
		return soap_out__saml1__Evidence(soap, "saml1:Evidence", id, (const struct saml1__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml1__Action:
		return soap_out__saml1__Action(soap, "saml1:Action", id, (const struct saml1__ActionType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		return soap_out__saml1__AuthorizationDecisionStatement(soap, "saml1:AuthorizationDecisionStatement", id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorityBinding:
		return soap_out__saml1__AuthorityBinding(soap, "saml1:AuthorityBinding", id, (const struct saml1__AuthorityBindingType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectLocality:
		return soap_out__saml1__SubjectLocality(soap, "saml1:SubjectLocality", id, (const struct saml1__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml1__AuthenticationStatement:
		return soap_out__saml1__AuthenticationStatement(soap, "saml1:AuthenticationStatement", id, (const struct saml1__AuthenticationStatementType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectConfirmation:
		return soap_out__saml1__SubjectConfirmation(soap, "saml1:SubjectConfirmation", id, (const struct saml1__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml1__NameIdentifier:
		return soap_out__saml1__NameIdentifier(soap, "saml1:NameIdentifier", id, (const struct saml1__NameIdentifierType *)ptr, "");
	case SOAP_TYPE__saml1__Subject:
		return soap_out__saml1__Subject(soap, "saml1:Subject", id, (const struct saml1__SubjectType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectStatement:
		return soap_out__saml1__SubjectStatement(soap, "saml1:SubjectStatement", id, (const struct saml1__SubjectStatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Statement:
		return soap_out__saml1__Statement(soap, "saml1:Statement", id, (const struct saml1__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Advice:
		return soap_out__saml1__Advice(soap, "saml1:Advice", id, (const struct saml1__AdviceType *)ptr, "");
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		return soap_out__saml1__DoNotCacheCondition(soap, "saml1:DoNotCacheCondition", id, (const struct saml1__DoNotCacheConditionType *)ptr, "");
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		return soap_out__saml1__AudienceRestrictionCondition(soap, "saml1:AudienceRestrictionCondition", id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "");
	case SOAP_TYPE__saml1__Condition:
		return soap_out__saml1__Condition(soap, "saml1:Condition", id, (const struct saml1__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Conditions:
		return soap_out__saml1__Conditions(soap, "saml1:Conditions", id, (const struct saml1__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml1__Assertion:
		return soap_out__saml1__Assertion(soap, "saml1:Assertion", id, (const struct saml1__AssertionType *)ptr, "");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_out_saml1__AttributeType(soap, tag, id, (const struct saml1__AttributeType *)ptr, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_out_saml1__AttributeDesignatorType(soap, tag, id, (const struct saml1__AttributeDesignatorType *)ptr, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_out_saml1__AttributeStatementType(soap, tag, id, (const struct saml1__AttributeStatementType *)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_out_saml1__EvidenceType(soap, tag, id, (const struct saml1__EvidenceType *)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_out_saml1__ActionType(soap, tag, id, (const struct saml1__ActionType *)ptr, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_out_saml1__AuthorityBindingType(soap, tag, id, (const struct saml1__AuthorityBindingType *)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_out_saml1__SubjectLocalityType(soap, tag, id, (const struct saml1__SubjectLocalityType *)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_out_saml1__AuthenticationStatementType(soap, tag, id, (const struct saml1__AuthenticationStatementType *)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_out_saml1__SubjectConfirmationType(soap, tag, id, (const struct saml1__SubjectConfirmationType *)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_out_saml1__NameIdentifierType(soap, tag, id, (const struct saml1__NameIdentifierType *)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_out_saml1__SubjectType(soap, tag, id, (const struct saml1__SubjectType *)ptr, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, (const struct saml1__SubjectStatementAbstractType *)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_out_saml1__StatementAbstractType(soap, tag, id, (const struct saml1__StatementAbstractType *)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_out_saml1__AdviceType(soap, tag, id, (const struct saml1__AdviceType *)ptr, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, (const struct saml1__DoNotCacheConditionType *)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_out_saml1__ConditionAbstractType(soap, tag, id, (const struct saml1__ConditionAbstractType *)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_out_saml1__ConditionsType(soap, tag, id, (const struct saml1__ConditionsType *)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_out_saml1__AssertionType(soap, tag, id, (const struct saml1__AssertionType *)ptr, "saml1:AssertionType");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_out_wsc__PropertiesType(soap, tag, id, (const struct wsc__PropertiesType *)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_out_wsc__DerivedKeyTokenType(soap, tag, id, (const struct wsc__DerivedKeyTokenType *)ptr, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_out_wsc__SecurityContextTokenType(soap, tag, id, (const struct wsc__SecurityContextTokenType *)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, "");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, "");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, "");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, "");
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, "");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, "");
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, "");
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, "");
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, "");
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, "");
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, "");
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, "");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_out_wsse__EncodedString(soap, tag, id, (const struct wsse__EncodedString *)ptr, "wsse:EncodedString");
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, "");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		return soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, tag, id, (struct wsrm__TerminateSequenceResponseType *const*)ptr, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		return soap_out_PointerTowsrm__TerminateSequenceType(soap, tag, id, (struct wsrm__TerminateSequenceType *const*)ptr, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		return soap_out_PointerTowsrm__CloseSequenceResponseType(soap, tag, id, (struct wsrm__CloseSequenceResponseType *const*)ptr, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		return soap_out_PointerTowsrm__CloseSequenceType(soap, tag, id, (struct wsrm__CloseSequenceType *const*)ptr, "wsrm:CloseSequenceType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		return soap_out_PointerTowsrm__CreateSequenceResponseType(soap, tag, id, (struct wsrm__CreateSequenceResponseType *const*)ptr, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		return soap_out_PointerTowsrm__CreateSequenceType(soap, tag, id, (struct wsrm__CreateSequenceType *const*)ptr, "wsrm:CreateSequenceType");
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		return soap_out_PointerTowsrm__SequenceFaultType(soap, tag, id, (struct wsrm__SequenceFaultType *const*)ptr, "wsrm:SequenceFaultType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement(soap, tag, id, (struct _wsrm__SequenceAcknowledgement *const*)ptr, "wsrm:SequenceAcknowledgement");
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		return soap_out_PointerTowsrm__AckRequestedType(soap, tag, id, (struct wsrm__AckRequestedType *const*)ptr, "wsrm:AckRequestedType");
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		return soap_out_PointerTowsrm__SequenceType(soap, tag, id, (struct wsrm__SequenceType *const*)ptr, "wsrm:SequenceType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_None *const*)ptr, "wsrm:SequenceAcknowledgement-None");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*)ptr, "wsrm:SequenceAcknowledgement-AcknowledgementRange");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_Final *const*)ptr, "wsrm:SequenceAcknowledgement-Final");
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		return soap_out_PointerTowsrm__AcceptType(soap, tag, id, (struct wsrm__AcceptType *const*)ptr, "wsrm:AcceptType");
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		return soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag, id, (enum wsrm__IncompleteSequenceBehaviorType *const*)ptr, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_PointerTowsrm__OfferType:
		return soap_out_PointerTowsrm__OfferType(soap, tag, id, (struct wsrm__OfferType *const*)ptr, "wsrm:OfferType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		return soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, tag, id, (struct _wsrm__UsesSequenceSSL *const*)ptr, "wsrm:UsesSequenceSSL");
	case SOAP_TYPE__wsrm__Identifier:
		return soap_out_string(soap, "wsrm:Identifier", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenCollectionType:
		return soap_out_PointerTowst__RequestSecurityTokenCollectionType(soap, tag, id, (struct wst__RequestSecurityTokenCollectionType *const*)ptr, "wst:RequestSecurityTokenCollectionType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseCollectionType:
		return soap_out_PointerTowst__RequestSecurityTokenResponseCollectionType(soap, tag, id, (struct wst__RequestSecurityTokenResponseCollectionType *const*)ptr, "wst:RequestSecurityTokenResponseCollectionType");
	case SOAP_TYPE__wst__Delegatable:
		return soap_out_string(soap, "wst:Delegatable", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__Forwardable:
		return soap_out_string(soap, "wst:Forwardable", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__EncryptWith:
		return soap_out_string(soap, "wst:EncryptWith", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__SignWith:
		return soap_out_string(soap, "wst:SignWith", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__KeyWrapAlgorithm:
		return soap_out_string(soap, "wst:KeyWrapAlgorithm", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__ComputedKeyAlgorithm:
		return soap_out_string(soap, "wst:ComputedKeyAlgorithm", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__CanonicalizationAlgorithm:
		return soap_out_string(soap, "wst:CanonicalizationAlgorithm", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__EncryptionAlgorithm:
		return soap_out_string(soap, "wst:EncryptionAlgorithm", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__SignatureAlgorithm:
		return soap_out_string(soap, "wst:SignatureAlgorithm", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__KeyType:
		return soap_out_string(soap, "wst:KeyType", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__AuthenticationType:
		return soap_out_string(soap, "wst:AuthenticationType", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__CombinedHash:
		return soap_out_string(soap, "wst:CombinedHash", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__Challenge:
		return soap_out_string(soap, "wst:Challenge", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__ComputedKey:
		return soap_out_string(soap, "wst:ComputedKey", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__RequestType:
		return soap_out_string(soap, "wst:RequestType", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wst__TokenType:
		return soap_out_string(soap, "wst:TokenType", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowst__ParticipantType:
		return soap_out_PointerTowst__ParticipantType(soap, tag, id, (struct wst__ParticipantType *const*)ptr, "wst:ParticipantType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseType:
		return soap_out_PointerTowst__RequestSecurityTokenResponseType(soap, tag, id, (struct wst__RequestSecurityTokenResponseType *const*)ptr, "wst:RequestSecurityTokenResponseType");
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenType:
		return soap_out_PointerTowst__RequestSecurityTokenType(soap, tag, id, (struct wst__RequestSecurityTokenType *const*)ptr, "wst:RequestSecurityTokenType");
	case SOAP_TYPE_PointerTowst__LifetimeType:
		return soap_out_PointerTowst__LifetimeType(soap, tag, id, (struct wst__LifetimeType *const*)ptr, "wst:LifetimeType");
	case SOAP_TYPE_PointerTowst__RequestedProofTokenType:
		return soap_out_PointerTowst__RequestedProofTokenType(soap, tag, id, (struct wst__RequestedProofTokenType *const*)ptr, "wst:RequestedProofTokenType");
	case SOAP_TYPE_PointerTowst__RequestedReferenceType:
		return soap_out_PointerTowst__RequestedReferenceType(soap, tag, id, (struct wst__RequestedReferenceType *const*)ptr, "wst:RequestedReferenceType");
	case SOAP_TYPE_PointerTowst__RequestedSecurityTokenType:
		return soap_out_PointerTowst__RequestedSecurityTokenType(soap, tag, id, (struct wst__RequestedSecurityTokenType *const*)ptr, "wst:RequestedSecurityTokenType");
	case SOAP_TYPE_PointerTowst__AuthenticatorType:
		return soap_out_PointerTowst__AuthenticatorType(soap, tag, id, (struct wst__AuthenticatorType *const*)ptr, "wst:AuthenticatorType");
	case SOAP_TYPE_PointerTowst__BinaryExchangeType:
		return soap_out_PointerTowst__BinaryExchangeType(soap, tag, id, (struct wst__BinaryExchangeType *const*)ptr, "wst:BinaryExchangeType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowst__EntropyType:
		return soap_out_PointerTowst__EntropyType(soap, tag, id, (struct wst__EntropyType *const*)ptr, "wst:EntropyType");
	case SOAP_TYPE_PointerTo_wsp__AppliesTo_:
		return soap_out_PointerTo_wsp__AppliesTo_(soap, tag, id, (struct _wsp__AppliesTo_ *const*)ptr, "wsp:AppliesTo");
	case SOAP_TYPE_PointerTowst__BinarySecretType:
		return soap_out_PointerTowst__BinarySecretType(soap, tag, id, (struct wst__BinarySecretType *const*)ptr, "wst:BinarySecretType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_out_PointerTowsc__SecurityContextTokenType(soap, tag, id, (struct wsc__SecurityContextTokenType *const*)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		return soap_out_string(soap, "saml2:AuthenticatingAuthority", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		return soap_out_string(soap, "saml2:AuthnContextDeclRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		return soap_out_string(soap, "saml2:AuthnContextClassRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__Audience:
		return soap_out_string(soap, "saml2:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionURIRef:
		return soap_out_string(soap, "saml2:AssertionURIRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionIDRef:
		return soap_out_string(soap, "saml2:AssertionIDRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType **const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_out_PointerTosaml2__AttributeType(soap, tag, id, (struct saml2__AttributeType *const*)ptr, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_out_PointerTosaml2__EvidenceType(soap, tag, id, (struct saml2__EvidenceType *const*)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_out_PointerTosaml2__ActionType(soap, tag, id, (struct saml2__ActionType *const*)ptr, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_out_PointerTosaml2__AuthnContextType(soap, tag, id, (struct saml2__AuthnContextType *const*)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_out_PointerTosaml2__SubjectLocalityType(soap, tag, id, (struct saml2__SubjectLocalityType *const*)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_out_PointerTosaml2__AssertionType(soap, tag, id, (struct saml2__AssertionType *const*)ptr, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag, id, (struct saml2__ProxyRestrictionType *const*)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_out_PointerTosaml2__OneTimeUseType(soap, tag, id, (struct saml2__OneTimeUseType *const*)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag, id, (struct saml2__AudienceRestrictionType *const*)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_out_PointerTosaml2__ConditionAbstractType(soap, tag, id, (struct saml2__ConditionAbstractType *const*)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag, id, (struct saml2__SubjectConfirmationDataType *const*)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag, id, (struct saml2__SubjectConfirmationType *const*)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_out_PointerTosaml2__EncryptedElementType(soap, tag, id, (struct saml2__EncryptedElementType *const*)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag, id, (struct saml2__BaseIDAbstractType *const*)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_out_PointerTosaml2__AttributeStatementType(soap, tag, id, (struct saml2__AttributeStatementType *const*)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag, id, (struct saml2__AuthzDecisionStatementType *const*)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_out_PointerTosaml2__AuthnStatementType(soap, tag, id, (struct saml2__AuthnStatementType *const*)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_out_PointerTosaml2__StatementAbstractType(soap, tag, id, (struct saml2__StatementAbstractType *const*)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_out_PointerTosaml2__AdviceType(soap, tag, id, (struct saml2__AdviceType *const*)ptr, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_out_PointerTosaml2__ConditionsType(soap, tag, id, (struct saml2__ConditionsType *const*)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_out_PointerTosaml2__SubjectType(soap, tag, id, (struct saml2__SubjectType *const*)ptr, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_out_PointerTosaml2__NameIDType(soap, tag, id, (struct saml2__NameIDType *const*)ptr, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType **const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE__saml1__ConfirmationMethod:
		return soap_out_string(soap, "saml1:ConfirmationMethod", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__Audience:
		return soap_out_string(soap, "saml1:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__AssertionIDReference:
		return soap_out_string(soap, "saml1:AssertionIDReference", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_out_PointerTosaml1__AttributeType(soap, tag, id, (struct saml1__AttributeType *const*)ptr, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_out_PointerTosaml1__EvidenceType(soap, tag, id, (struct saml1__EvidenceType *const*)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_out_PointerTosaml1__ActionType(soap, tag, id, (struct saml1__ActionType *const*)ptr, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_out_PointerTosaml1__AuthorityBindingType(soap, tag, id, (struct saml1__AuthorityBindingType *const*)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_out_PointerTosaml1__SubjectLocalityType(soap, tag, id, (struct saml1__SubjectLocalityType *const*)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_out_PointerTosaml1__SubjectType(soap, tag, id, (struct saml1__SubjectType *const*)ptr, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag, id, (struct saml1__SubjectConfirmationType *const*)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_out_PointerTosaml1__NameIdentifierType(soap, tag, id, (struct saml1__NameIdentifierType *const*)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_out_PointerTosaml1__AssertionType(soap, tag, id, (struct saml1__AssertionType *const*)ptr, "saml1:AssertionType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_out_PointerTosaml1__ConditionAbstractType(soap, tag, id, (struct saml1__ConditionAbstractType *const*)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag, id, (struct saml1__DoNotCacheConditionType *const*)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, id, (struct saml1__AudienceRestrictionConditionType *const*)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_out_PointerTo_ds__Signature(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_out_PointerTosaml1__AttributeStatementType(soap, tag, id, (struct saml1__AttributeStatementType *const*)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, id, (struct saml1__AuthorizationDecisionStatementType *const*)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag, id, (struct saml1__AuthenticationStatementType *const*)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag, id, (struct saml1__SubjectStatementAbstractType *const*)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_out_PointerTosaml1__StatementAbstractType(soap, tag, id, (struct saml1__StatementAbstractType *const*)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_out_PointerTosaml1__AdviceType(soap, tag, id, (struct saml1__AdviceType *const*)ptr, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_out_PointerTosaml1__ConditionsType(soap, tag, id, (struct saml1__ConditionsType *const*)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_out_PointerToULONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_out_PointerTowsc__PropertiesType(soap, tag, id, (struct wsc__PropertiesType *const*)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsc:FaultCodeOpenEnumType");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE__ds__SignatureValue:
		return soap_out_string(soap, "ds:SignatureValue", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_out_PointerTowsse__EncodedString(soap, tag, id, (struct wsse__EncodedString *const*)ptr, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE_PointerTo_tempuri__GetWarnings:
		return soap_out_PointerTo_tempuri__GetWarnings(soap, tag, id, (_tempuri__GetWarnings *const*)ptr, "tempuri:GetWarnings");
	case SOAP_TYPE_PointerTo_tempuri__HasWarnings:
		return soap_out_PointerTo_tempuri__HasWarnings(soap, tag, id, (_tempuri__HasWarnings *const*)ptr, "tempuri:HasWarnings");
	case SOAP_TYPE_PointerTo_tempuri__GetErrors:
		return soap_out_PointerTo_tempuri__GetErrors(soap, tag, id, (_tempuri__GetErrors *const*)ptr, "tempuri:GetErrors");
	case SOAP_TYPE_PointerTo_tempuri__HasErrors:
		return soap_out_PointerTo_tempuri__HasErrors(soap, tag, id, (_tempuri__HasErrors *const*)ptr, "tempuri:HasErrors");
	case SOAP_TYPE_PointerTo_tempuri__GetMessage:
		return soap_out_PointerTo_tempuri__GetMessage(soap, tag, id, (_tempuri__GetMessage *const*)ptr, "tempuri:GetMessage");
	case SOAP_TYPE_PointerTo_tempuri__HasMessage:
		return soap_out_PointerTo_tempuri__HasMessage(soap, tag, id, (_tempuri__HasMessage *const*)ptr, "tempuri:HasMessage");
	case SOAP_TYPE_PointerTo_tempuri__IsSamplePlateTrayIn:
		return soap_out_PointerTo_tempuri__IsSamplePlateTrayIn(soap, tag, id, (_tempuri__IsSamplePlateTrayIn *const*)ptr, "tempuri:IsSamplePlateTrayIn");
	case SOAP_TYPE_PointerTo_tempuri__IsChipDocked:
		return soap_out_PointerTo_tempuri__IsChipDocked(soap, tag, id, (_tempuri__IsChipDocked *const*)ptr, "tempuri:IsChipDocked");
	case SOAP_TYPE_PointerTo_tempuri__GetOperationMode:
		return soap_out_PointerTo_tempuri__GetOperationMode(soap, tag, id, (_tempuri__GetOperationMode *const*)ptr, "tempuri:GetOperationMode");
	case SOAP_TYPE_PointerTo_tempuri__RunMaintenanceProcedure:
		return soap_out_PointerTo_tempuri__RunMaintenanceProcedure(soap, tag, id, (_tempuri__RunMaintenanceProcedure *const*)ptr, "tempuri:RunMaintenanceProcedure");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMaintenanceProcedures:
		return soap_out_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, tag, id, (_tempuri__GetNamesOfMaintenanceProcedures *const*)ptr, "tempuri:GetNamesOfMaintenanceProcedures");
	case SOAP_TYPE_PointerTo_tempuri__GetStandbyAfterFinish:
		return soap_out_PointerTo_tempuri__GetStandbyAfterFinish(soap, tag, id, (_tempuri__GetStandbyAfterFinish *const*)ptr, "tempuri:GetStandbyAfterFinish");
	case SOAP_TYPE_PointerTo_tempuri__SetStandbyAfterFinish:
		return soap_out_PointerTo_tempuri__SetStandbyAfterFinish(soap, tag, id, (_tempuri__SetStandbyAfterFinish *const*)ptr, "tempuri:SetStandbyAfterFinish");
	case SOAP_TYPE_PointerTo_tempuri__LeaveStandby:
		return soap_out_PointerTo_tempuri__LeaveStandby(soap, tag, id, (_tempuri__LeaveStandby *const*)ptr, "tempuri:LeaveStandby");
	case SOAP_TYPE_PointerTo_tempuri__AbortScript:
		return soap_out_PointerTo_tempuri__AbortScript(soap, tag, id, (_tempuri__AbortScript *const*)ptr, "tempuri:AbortScript");
	case SOAP_TYPE_PointerTo_tempuri__ResetRunset:
		return soap_out_PointerTo_tempuri__ResetRunset(soap, tag, id, (_tempuri__ResetRunset *const*)ptr, "tempuri:ResetRunset");
	case SOAP_TYPE_PointerTo_tempuri__ResumeRunset:
		return soap_out_PointerTo_tempuri__ResumeRunset(soap, tag, id, (_tempuri__ResumeRunset *const*)ptr, "tempuri:ResumeRunset");
	case SOAP_TYPE_PointerTo_tempuri__PauseRunsetAfter:
		return soap_out_PointerTo_tempuri__PauseRunsetAfter(soap, tag, id, (_tempuri__PauseRunsetAfter *const*)ptr, "tempuri:PauseRunsetAfter");
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunsetFrom:
		return soap_out_PointerTo_tempuri__StartSelectedRunsetFrom(soap, tag, id, (_tempuri__StartSelectedRunsetFrom *const*)ptr, "tempuri:StartSelectedRunsetFrom");
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunset:
		return soap_out_PointerTo_tempuri__StartSelectedRunset(soap, tag, id, (_tempuri__StartSelectedRunset *const*)ptr, "tempuri:StartSelectedRunset");
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayIn:
		return soap_out_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, tag, id, (_tempuri__MoveSamplePlateTrayIn *const*)ptr, "tempuri:MoveSamplePlateTrayIn");
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayOut:
		return soap_out_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, tag, id, (_tempuri__MoveSamplePlateTrayOut *const*)ptr, "tempuri:MoveSamplePlateTrayOut");
	case SOAP_TYPE_PointerTo_tempuri__GetCurrentSamplePlateId:
		return soap_out_PointerTo_tempuri__GetCurrentSamplePlateId(soap, tag, id, (_tempuri__GetCurrentSamplePlateId *const*)ptr, "tempuri:GetCurrentSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__GetSamplePlateId:
		return soap_out_PointerTo_tempuri__GetSamplePlateId(soap, tag, id, (_tempuri__GetSamplePlateId *const*)ptr, "tempuri:GetSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__SetSamplePlateId:
		return soap_out_PointerTo_tempuri__SetSamplePlateId(soap, tag, id, (_tempuri__SetSamplePlateId *const*)ptr, "tempuri:SetSamplePlateId");
	case SOAP_TYPE_PointerTo_tempuri__CreateRunset:
		return soap_out_PointerTo_tempuri__CreateRunset(soap, tag, id, (_tempuri__CreateRunset *const*)ptr, "tempuri:CreateRunset");
	case SOAP_TYPE_PointerTo_tempuri__SelectRunset:
		return soap_out_PointerTo_tempuri__SelectRunset(soap, tag, id, (_tempuri__SelectRunset *const*)ptr, "tempuri:SelectRunset");
	case SOAP_TYPE_PointerTo_tempuri__SelectMethod:
		return soap_out_PointerTo_tempuri__SelectMethod(soap, tag, id, (_tempuri__SelectMethod *const*)ptr, "tempuri:SelectMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetMethodNamesOfRunset:
		return soap_out_PointerTo_tempuri__GetMethodNamesOfRunset(soap, tag, id, (_tempuri__GetMethodNamesOfRunset *const*)ptr, "tempuri:GetMethodNamesOfRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfRunset:
		return soap_out_PointerTo_tempuri__GetAssayTypeOfRunset(soap, tag, id, (_tempuri__GetAssayTypeOfRunset *const*)ptr, "tempuri:GetAssayTypeOfRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentRunset:
		return soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, tag, id, (_tempuri__GetAssayTypeOfCurrentRunset *const*)ptr, "tempuri:GetAssayTypeOfCurrentRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentRunset:
		return soap_out_PointerTo_tempuri__GetNameOfCurrentRunset(soap, tag, id, (_tempuri__GetNameOfCurrentRunset *const*)ptr, "tempuri:GetNameOfCurrentRunset");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllRunsets:
		return soap_out_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, tag, id, (_tempuri__GetAssayTypesOfAllRunsets *const*)ptr, "tempuri:GetAssayTypesOfAllRunsets");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType:
		return soap_out_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, id, (_tempuri__GetNamesOfRunsetsOfAssayType *const*)ptr, "tempuri:GetNamesOfRunsetsOfAssayType");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsets:
		return soap_out_PointerTo_tempuri__GetNamesOfRunsets(soap, tag, id, (_tempuri__GetNamesOfRunsets *const*)ptr, "tempuri:GetNamesOfRunsets");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfMethod:
		return soap_out_PointerTo_tempuri__GetAssayTypeOfMethod(soap, tag, id, (_tempuri__GetAssayTypeOfMethod *const*)ptr, "tempuri:GetAssayTypeOfMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentMethod:
		return soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, tag, id, (_tempuri__GetAssayTypeOfCurrentMethod *const*)ptr, "tempuri:GetAssayTypeOfCurrentMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentMethod:
		return soap_out_PointerTo_tempuri__GetNameOfCurrentMethod(soap, tag, id, (_tempuri__GetNameOfCurrentMethod *const*)ptr, "tempuri:GetNameOfCurrentMethod");
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllMethods:
		return soap_out_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, tag, id, (_tempuri__GetAssayTypesOfAllMethods *const*)ptr, "tempuri:GetAssayTypesOfAllMethods");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethodsOfAssayType:
		return soap_out_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, tag, id, (_tempuri__GetNamesOfMethodsOfAssayType *const*)ptr, "tempuri:GetNamesOfMethodsOfAssayType");
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethods:
		return soap_out_PointerTo_tempuri__GetNamesOfMethods(soap, tag, id, (_tempuri__GetNamesOfMethods *const*)ptr, "tempuri:GetNamesOfMethods");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		return soap_out_PointerToarr__ArrayOfstring(soap, tag, id, (arr__ArrayOfstring *const*)ptr, "arr:ArrayOfstring");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		((arr__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetWarningsResponse:
		((_tempuri__GetWarningsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetWarnings:
		((_tempuri__GetWarnings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasWarningsResponse:
		((_tempuri__HasWarningsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasWarnings:
		((_tempuri__HasWarnings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetErrorsResponse:
		((_tempuri__GetErrorsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetErrors:
		((_tempuri__GetErrors *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasErrorsResponse:
		((_tempuri__HasErrorsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasErrors:
		((_tempuri__HasErrors *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetMessageResponse:
		((_tempuri__GetMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetMessage:
		((_tempuri__GetMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasMessageResponse:
		((_tempuri__HasMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__HasMessage:
		((_tempuri__HasMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse:
		((_tempuri__IsSamplePlateTrayInResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayIn:
		((_tempuri__IsSamplePlateTrayIn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__IsChipDockedResponse:
		((_tempuri__IsChipDockedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__IsChipDocked:
		((_tempuri__IsChipDocked *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetOperationModeResponse:
		((_tempuri__GetOperationModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetOperationMode:
		((_tempuri__GetOperationMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse:
		((_tempuri__RunMaintenanceProcedureResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedure:
		((_tempuri__RunMaintenanceProcedure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse:
		((_tempuri__GetNamesOfMaintenanceProceduresResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures:
		((_tempuri__GetNamesOfMaintenanceProcedures *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse:
		((_tempuri__GetStandbyAfterFinishResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinish:
		((_tempuri__GetStandbyAfterFinish *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse:
		((_tempuri__SetStandbyAfterFinishResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinish:
		((_tempuri__SetStandbyAfterFinish *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LeaveStandbyResponse:
		((_tempuri__LeaveStandbyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LeaveStandby:
		((_tempuri__LeaveStandby *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AbortScriptResponse:
		((_tempuri__AbortScriptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AbortScript:
		((_tempuri__AbortScript *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ResetRunsetResponse:
		((_tempuri__ResetRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ResetRunset:
		((_tempuri__ResetRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ResumeRunsetResponse:
		((_tempuri__ResumeRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ResumeRunset:
		((_tempuri__ResumeRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfterResponse:
		((_tempuri__PauseRunsetAfterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfter:
		((_tempuri__PauseRunsetAfter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse:
		((_tempuri__StartSelectedRunsetFromResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFrom:
		((_tempuri__StartSelectedRunsetFrom *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetResponse:
		((_tempuri__StartSelectedRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunset:
		((_tempuri__StartSelectedRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse:
		((_tempuri__MoveSamplePlateTrayInResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayIn:
		((_tempuri__MoveSamplePlateTrayIn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse:
		((_tempuri__MoveSamplePlateTrayOutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOut:
		((_tempuri__MoveSamplePlateTrayOut *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse:
		((_tempuri__GetCurrentSamplePlateIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateId:
		((_tempuri__GetCurrentSamplePlateId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateIdResponse:
		((_tempuri__GetSamplePlateIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateId:
		((_tempuri__GetSamplePlateId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateIdResponse:
		((_tempuri__SetSamplePlateIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateId:
		((_tempuri__SetSamplePlateId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__CreateRunsetResponse:
		((_tempuri__CreateRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__CreateRunset:
		((_tempuri__CreateRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SelectRunsetResponse:
		((_tempuri__SelectRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SelectRunset:
		((_tempuri__SelectRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SelectMethodResponse:
		((_tempuri__SelectMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SelectMethod:
		((_tempuri__SelectMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse:
		((_tempuri__GetMethodNamesOfRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunset:
		((_tempuri__GetMethodNamesOfRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse:
		((_tempuri__GetAssayTypeOfRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunset:
		((_tempuri__GetAssayTypeOfRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse:
		((_tempuri__GetAssayTypeOfCurrentRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset:
		((_tempuri__GetAssayTypeOfCurrentRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse:
		((_tempuri__GetNameOfCurrentRunsetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunset:
		((_tempuri__GetNameOfCurrentRunset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse:
		((_tempuri__GetAssayTypesOfAllRunsetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets:
		((_tempuri__GetAssayTypesOfAllRunsets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse:
		((_tempuri__GetNamesOfRunsetsOfAssayTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType:
		((_tempuri__GetNamesOfRunsetsOfAssayType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse:
		((_tempuri__GetNamesOfRunsetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsets:
		((_tempuri__GetNamesOfRunsets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse:
		((_tempuri__GetAssayTypeOfMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethod:
		((_tempuri__GetAssayTypeOfMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse:
		((_tempuri__GetAssayTypeOfCurrentMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod:
		((_tempuri__GetAssayTypeOfCurrentMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse:
		((_tempuri__GetNameOfCurrentMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethod:
		((_tempuri__GetNameOfCurrentMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse:
		((_tempuri__GetAssayTypesOfAllMethodsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods:
		((_tempuri__GetAssayTypesOfAllMethods *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse:
		((_tempuri__GetNamesOfMethodsOfAssayTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType:
		((_tempuri__GetNamesOfMethodsOfAssayType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsResponse:
		((_tempuri__GetNamesOfMethodsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethods:
		((_tempuri__GetNamesOfMethods *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___wsrm__LastMessage:
		soap_serialize___wsrm__LastMessage(soap, (const struct __wsrm__LastMessage *)ptr);
		break;
	case SOAP_TYPE___wsrm__AckRequested:
		soap_serialize___wsrm__AckRequested(soap, (const struct __wsrm__AckRequested *)ptr);
		break;
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		soap_serialize___wsrm__SequenceAcknowledgement(soap, (const struct __wsrm__SequenceAcknowledgement *)ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		soap_serialize___wsrm__TerminateSequenceResponse(soap, (const struct __wsrm__TerminateSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		soap_serialize___wsrm__CloseSequenceResponse(soap, (const struct __wsrm__CloseSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		soap_serialize___wsrm__CreateSequenceResponse(soap, (const struct __wsrm__CreateSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequence:
		soap_serialize___wsrm__TerminateSequence(soap, (const struct __wsrm__TerminateSequence *)ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequence:
		soap_serialize___wsrm__CloseSequence(soap, (const struct __wsrm__CloseSequence *)ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequence:
		soap_serialize___wsrm__CreateSequence(soap, (const struct __wsrm__CreateSequence *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		soap_serialize__wsrm__SequenceAcknowledgement_None(soap, (const struct _wsrm__SequenceAcknowledgement_None *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, (const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		soap_serialize__wsrm__SequenceAcknowledgement_Final(soap, (const struct _wsrm__SequenceAcknowledgement_Final *)ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		soap_serialize__wsrm__UsesSequenceSSL(soap, (const struct _wsrm__UsesSequenceSSL *)ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		soap_serialize__wsrm__UsesSequenceSTR(soap, (const struct _wsrm__UsesSequenceSTR *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		soap_serialize__wsrm__SequenceAcknowledgement(soap, (const struct _wsrm__SequenceAcknowledgement *)ptr);
		break;
	case SOAP_TYPE_wsrm__AcceptType:
		soap_serialize_wsrm__AcceptType(soap, (const struct wsrm__AcceptType *)ptr);
		break;
	case SOAP_TYPE_wsrm__OfferType:
		soap_serialize_wsrm__OfferType(soap, (const struct wsrm__OfferType *)ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		soap_serialize_wsrm__TerminateSequenceResponseType(soap, (const struct wsrm__TerminateSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		soap_serialize_wsrm__TerminateSequenceType(soap, (const struct wsrm__TerminateSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		soap_serialize_wsrm__CloseSequenceResponseType(soap, (const struct wsrm__CloseSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceType:
		soap_serialize_wsrm__CloseSequenceType(soap, (const struct wsrm__CloseSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		soap_serialize_wsrm__CreateSequenceResponseType(soap, (const struct wsrm__CreateSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceType:
		soap_serialize_wsrm__CreateSequenceType(soap, (const struct wsrm__CreateSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__SequenceFaultType:
		soap_serialize_wsrm__SequenceFaultType(soap, (const struct wsrm__SequenceFaultType *)ptr);
		break;
	case SOAP_TYPE_wsrm__AckRequestedType:
		soap_serialize_wsrm__AckRequestedType(soap, (const struct wsrm__AckRequestedType *)ptr);
		break;
	case SOAP_TYPE_wsrm__SequenceType:
		soap_serialize_wsrm__SequenceType(soap, (const struct wsrm__SequenceType *)ptr);
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenCollection:
		soap_serialize___wst__RequestSecurityTokenCollection(soap, (const struct __wst__RequestSecurityTokenCollection *)ptr);
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenResponse:
		soap_serialize___wst__RequestSecurityTokenResponse(soap, (const struct __wst__RequestSecurityTokenResponse *)ptr);
		break;
	case SOAP_TYPE___wst__RequestSecurityToken:
		soap_serialize___wst__RequestSecurityToken(soap, (const struct __wst__RequestSecurityToken *)ptr);
		break;
	case SOAP_TYPE__wst__Participants:
		soap_serialize__wst__Participants(soap, (const struct wst__ParticipantsType *)ptr);
		break;
	case SOAP_TYPE__wst__DelegateTo:
		soap_serialize__wst__DelegateTo(soap, (const struct wst__DelegateToType *)ptr);
		break;
	case SOAP_TYPE__wst__UseKey:
		soap_serialize__wst__UseKey(soap, (const struct wst__UseKeyType *)ptr);
		break;
	case SOAP_TYPE__wst__ProofEncryption:
		soap_serialize__wst__ProofEncryption(soap, (const struct wst__ProofEncryptionType *)ptr);
		break;
	case SOAP_TYPE__wst__Encryption:
		soap_serialize__wst__Encryption(soap, (const struct wst__EncryptionType *)ptr);
		break;
	case SOAP_TYPE__wst__Issuer:
		soap_serialize__wst__Issuer(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wst__OnBehalfOf:
		soap_serialize__wst__OnBehalfOf(soap, (const struct wst__OnBehalfOfType *)ptr);
		break;
	case SOAP_TYPE__wst__Authenticator:
		soap_serialize__wst__Authenticator(soap, (const struct wst__AuthenticatorType *)ptr);
		break;
	case SOAP_TYPE__wst__KeyExchangeToken:
		soap_serialize__wst__KeyExchangeToken(soap, (const struct wst__KeyExchangeTokenType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestKET:
		soap_serialize__wst__RequestKET(soap, (const struct wst__RequestKETType *)ptr);
		break;
	case SOAP_TYPE__wst__BinaryExchange:
		soap_serialize__wst__BinaryExchange(soap, (const struct wst__BinaryExchangeType *)ptr);
		break;
	case SOAP_TYPE__wst__SignChallengeResponse:
		soap_serialize__wst__SignChallengeResponse(soap, (const struct wst__SignChallengeType *)ptr);
		break;
	case SOAP_TYPE__wst__SignChallenge:
		soap_serialize__wst__SignChallenge(soap, (const struct wst__SignChallengeType *)ptr);
		break;
	case SOAP_TYPE__wst__Status:
		soap_serialize__wst__Status(soap, (const struct wst__StatusType *)ptr);
		break;
	case SOAP_TYPE__wst__ValidateTarget:
		soap_serialize__wst__ValidateTarget(soap, (const struct wst__ValidateTargetType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestedTokenCancelled:
		soap_serialize__wst__RequestedTokenCancelled(soap, (const struct wst__RequestedTokenCancelledType *)ptr);
		break;
	case SOAP_TYPE__wst__CancelTarget:
		soap_serialize__wst__CancelTarget(soap, (const struct wst__CancelTargetType *)ptr);
		break;
	case SOAP_TYPE__wst__Renewing:
		soap_serialize__wst__Renewing(soap, (const struct wst__RenewingType *)ptr);
		break;
	case SOAP_TYPE__wst__AllowPostdating:
		soap_serialize__wst__AllowPostdating(soap, (const struct wst__AllowPostdatingType *)ptr);
		break;
	case SOAP_TYPE__wst__RenewTarget:
		soap_serialize__wst__RenewTarget(soap, (const struct wst__RenewTargetType *)ptr);
		break;
	case SOAP_TYPE__wst__IssuedTokens:
		soap_serialize__wst__IssuedTokens(soap, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestedProofToken:
		soap_serialize__wst__RequestedProofToken(soap, (const struct wst__RequestedProofTokenType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestedUnattachedReference:
		soap_serialize__wst__RequestedUnattachedReference(soap, (const struct wst__RequestedReferenceType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestedAttachedReference:
		soap_serialize__wst__RequestedAttachedReference(soap, (const struct wst__RequestedReferenceType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponseCollection:
		soap_serialize__wst__RequestSecurityTokenResponseCollection(soap, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenCollection:
		soap_serialize__wst__RequestSecurityTokenCollection(soap, (const struct wst__RequestSecurityTokenCollectionType *)ptr);
		break;
	case SOAP_TYPE__wst__Lifetime:
		soap_serialize__wst__Lifetime(soap, (const struct wst__LifetimeType *)ptr);
		break;
	case SOAP_TYPE__wst__Entropy:
		soap_serialize__wst__Entropy(soap, (const struct wst__EntropyType *)ptr);
		break;
	case SOAP_TYPE__wst__Claims:
		soap_serialize__wst__Claims(soap, (const struct wst__ClaimsType *)ptr);
		break;
	case SOAP_TYPE__wst__BinarySecret:
		soap_serialize__wst__BinarySecret(soap, (const struct wst__BinarySecretType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestedSecurityToken:
		soap_serialize__wst__RequestedSecurityToken(soap, (const struct wst__RequestedSecurityTokenType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponse:
		soap_serialize__wst__RequestSecurityTokenResponse(soap, (const struct wst__RequestSecurityTokenResponseType *)ptr);
		break;
	case SOAP_TYPE__wst__RequestSecurityToken:
		soap_serialize__wst__RequestSecurityToken(soap, (const struct wst__RequestSecurityTokenType *)ptr);
		break;
	case SOAP_TYPE_wst__ParticipantType:
		soap_serialize_wst__ParticipantType(soap, (const struct wst__ParticipantType *)ptr);
		break;
	case SOAP_TYPE_wst__ParticipantsType:
		soap_serialize_wst__ParticipantsType(soap, (const struct wst__ParticipantsType *)ptr);
		break;
	case SOAP_TYPE_wst__DelegateToType:
		soap_serialize_wst__DelegateToType(soap, (const struct wst__DelegateToType *)ptr);
		break;
	case SOAP_TYPE_wst__UseKeyType:
		soap_serialize_wst__UseKeyType(soap, (const struct wst__UseKeyType *)ptr);
		break;
	case SOAP_TYPE_wst__ProofEncryptionType:
		soap_serialize_wst__ProofEncryptionType(soap, (const struct wst__ProofEncryptionType *)ptr);
		break;
	case SOAP_TYPE_wst__EncryptionType:
		soap_serialize_wst__EncryptionType(soap, (const struct wst__EncryptionType *)ptr);
		break;
	case SOAP_TYPE_wst__OnBehalfOfType:
		soap_serialize_wst__OnBehalfOfType(soap, (const struct wst__OnBehalfOfType *)ptr);
		break;
	case SOAP_TYPE_wst__AuthenticatorType:
		soap_serialize_wst__AuthenticatorType(soap, (const struct wst__AuthenticatorType *)ptr);
		break;
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		soap_serialize_wst__KeyExchangeTokenType(soap, (const struct wst__KeyExchangeTokenType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestKETType:
		soap_serialize_wst__RequestKETType(soap, (const struct wst__RequestKETType *)ptr);
		break;
	case SOAP_TYPE_wst__BinaryExchangeType:
		soap_serialize_wst__BinaryExchangeType(soap, (const struct wst__BinaryExchangeType *)ptr);
		break;
	case SOAP_TYPE_wst__SignChallengeType:
		soap_serialize_wst__SignChallengeType(soap, (const struct wst__SignChallengeType *)ptr);
		break;
	case SOAP_TYPE_wst__StatusType:
		soap_serialize_wst__StatusType(soap, (const struct wst__StatusType *)ptr);
		break;
	case SOAP_TYPE_wst__ValidateTargetType:
		soap_serialize_wst__ValidateTargetType(soap, (const struct wst__ValidateTargetType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		soap_serialize_wst__RequestedTokenCancelledType(soap, (const struct wst__RequestedTokenCancelledType *)ptr);
		break;
	case SOAP_TYPE_wst__CancelTargetType:
		soap_serialize_wst__CancelTargetType(soap, (const struct wst__CancelTargetType *)ptr);
		break;
	case SOAP_TYPE_wst__RenewingType:
		soap_serialize_wst__RenewingType(soap, (const struct wst__RenewingType *)ptr);
		break;
	case SOAP_TYPE_wst__AllowPostdatingType:
		soap_serialize_wst__AllowPostdatingType(soap, (const struct wst__AllowPostdatingType *)ptr);
		break;
	case SOAP_TYPE_wst__RenewTargetType:
		soap_serialize_wst__RenewTargetType(soap, (const struct wst__RenewTargetType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestedProofTokenType:
		soap_serialize_wst__RequestedProofTokenType(soap, (const struct wst__RequestedProofTokenType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestedReferenceType:
		soap_serialize_wst__RequestedReferenceType(soap, (const struct wst__RequestedReferenceType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		soap_serialize_wst__RequestSecurityTokenResponseCollectionType(soap, (const struct wst__RequestSecurityTokenResponseCollectionType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		soap_serialize_wst__RequestSecurityTokenCollectionType(soap, (const struct wst__RequestSecurityTokenCollectionType *)ptr);
		break;
	case SOAP_TYPE_wst__LifetimeType:
		soap_serialize_wst__LifetimeType(soap, (const struct wst__LifetimeType *)ptr);
		break;
	case SOAP_TYPE_wst__EntropyType:
		soap_serialize_wst__EntropyType(soap, (const struct wst__EntropyType *)ptr);
		break;
	case SOAP_TYPE_wst__ClaimsType:
		soap_serialize_wst__ClaimsType(soap, (const struct wst__ClaimsType *)ptr);
		break;
	case SOAP_TYPE_wst__BinarySecretType:
		soap_serialize_wst__BinarySecretType(soap, (const struct wst__BinarySecretType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		soap_serialize_wst__RequestedSecurityTokenType(soap, (const struct wst__RequestedSecurityTokenType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		soap_serialize_wst__RequestSecurityTokenResponseType(soap, (const struct wst__RequestSecurityTokenResponseType *)ptr);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		soap_serialize_wst__RequestSecurityTokenType(soap, (const struct wst__RequestSecurityTokenType *)ptr);
		break;
	case SOAP_TYPE__wsp__AppliesTo_:
		soap_serialize__wsp__AppliesTo_(soap, (const struct _wsp__AppliesTo_ *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		soap_serialize__saml2__EncryptedAttribute(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Attribute:
		soap_serialize__saml2__Attribute(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		soap_serialize__saml2__AttributeStatement(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Evidence:
		soap_serialize__saml2__Evidence(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml2__Action:
		soap_serialize__saml2__Action(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		soap_serialize__saml2__AuthzDecisionStatement(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		soap_serialize__saml2__AuthnContext(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		soap_serialize__saml2__SubjectLocality(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		soap_serialize__saml2__AuthnStatement(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Statement:
		soap_serialize__saml2__Statement(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		soap_serialize__saml2__EncryptedAssertion(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Advice:
		soap_serialize__saml2__Advice(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		soap_serialize__saml2__ProxyRestriction(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		soap_serialize__saml2__OneTimeUse(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		soap_serialize__saml2__AudienceRestriction(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Condition:
		soap_serialize__saml2__Condition(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__Conditions:
		soap_serialize__saml2__Conditions(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		soap_serialize__saml2__SubjectConfirmationData(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		soap_serialize__saml2__SubjectConfirmation(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml2__Subject:
		soap_serialize__saml2__Subject(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml2__Assertion:
		soap_serialize__saml2__Assertion(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Issuer:
		soap_serialize__saml2__Issuer(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		soap_serialize__saml2__EncryptedID(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__NameID:
		soap_serialize__saml2__NameID(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__BaseID:
		soap_serialize__saml2__BaseID(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		soap_serialize___saml2__union_AttributeStatementType(soap, (const struct __saml2__union_AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		soap_serialize___saml2__union_EvidenceType(soap, (const struct __saml2__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		soap_serialize___saml2__union_AdviceType(soap, (const struct __saml2__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		soap_serialize___saml2__union_ConditionsType(soap, (const struct __saml2__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		soap_serialize___saml2__union_AssertionType(soap, (const struct __saml2__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeType:
		soap_serialize_saml2__AttributeType(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		soap_serialize_saml2__AttributeStatementType(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		soap_serialize_saml2__EvidenceType(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ActionType:
		soap_serialize_saml2__ActionType(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		soap_serialize_saml2__AuthzDecisionStatementType(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		soap_serialize_saml2__AuthnContextType(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		soap_serialize_saml2__SubjectLocalityType(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		soap_serialize_saml2__AuthnStatementType(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		soap_serialize_saml2__StatementAbstractType(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__AdviceType:
		soap_serialize_saml2__AdviceType(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		soap_serialize_saml2__ProxyRestrictionType(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		soap_serialize_saml2__OneTimeUseType(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		soap_serialize_saml2__AudienceRestrictionType(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		soap_serialize_saml2__ConditionAbstractType(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		soap_serialize_saml2__ConditionsType(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		soap_serialize_saml2__KeyInfoConfirmationDataType(soap, (const struct saml2__KeyInfoConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		soap_serialize_saml2__SubjectConfirmationDataType(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		soap_serialize_saml2__SubjectConfirmationType(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectType:
		soap_serialize_saml2__SubjectType(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml2__AssertionType:
		soap_serialize_saml2__AssertionType(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		soap_serialize_saml2__EncryptedElementType(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE_saml2__NameIDType:
		soap_serialize_saml2__NameIDType(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		soap_serialize_saml2__BaseIDAbstractType(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Attribute:
		soap_serialize__saml1__Attribute(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		soap_serialize__saml1__AttributeDesignator(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		soap_serialize__saml1__AttributeStatement(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__Evidence:
		soap_serialize__saml1__Evidence(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml1__Action:
		soap_serialize__saml1__Action(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		soap_serialize__saml1__AuthorizationDecisionStatement(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		soap_serialize__saml1__AuthorityBinding(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		soap_serialize__saml1__SubjectLocality(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		soap_serialize__saml1__AuthenticationStatement(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		soap_serialize__saml1__SubjectConfirmation(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		soap_serialize__saml1__NameIdentifier(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE__saml1__Subject:
		soap_serialize__saml1__Subject(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		soap_serialize__saml1__SubjectStatement(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Statement:
		soap_serialize__saml1__Statement(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Advice:
		soap_serialize__saml1__Advice(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		soap_serialize__saml1__DoNotCacheCondition(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		soap_serialize__saml1__AudienceRestrictionCondition(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__Condition:
		soap_serialize__saml1__Condition(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Conditions:
		soap_serialize__saml1__Conditions(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml1__Assertion:
		soap_serialize__saml1__Assertion(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		soap_serialize___saml1__union_EvidenceType(soap, (const struct __saml1__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		soap_serialize___saml1__union_AdviceType(soap, (const struct __saml1__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		soap_serialize___saml1__union_ConditionsType(soap, (const struct __saml1__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		soap_serialize___saml1__union_AssertionType(soap, (const struct __saml1__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeType:
		soap_serialize_saml1__AttributeType(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		soap_serialize_saml1__AttributeDesignatorType(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		soap_serialize_saml1__AttributeStatementType(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		soap_serialize_saml1__EvidenceType(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml1__ActionType:
		soap_serialize_saml1__ActionType(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		soap_serialize_saml1__AuthorityBindingType(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		soap_serialize_saml1__SubjectLocalityType(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		soap_serialize_saml1__AuthenticationStatementType(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		soap_serialize_saml1__SubjectConfirmationType(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		soap_serialize_saml1__NameIdentifierType(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectType:
		soap_serialize_saml1__SubjectType(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		soap_serialize_saml1__SubjectStatementAbstractType(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		soap_serialize_saml1__StatementAbstractType(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__AdviceType:
		soap_serialize_saml1__AdviceType(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		soap_serialize_saml1__DoNotCacheConditionType(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		soap_serialize_saml1__ConditionAbstractType(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		soap_serialize_saml1__ConditionsType(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml1__AssertionType:
		soap_serialize_saml1__AssertionType(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, (const struct __wsc__DerivedKeyTokenType_sequence *)ptr);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		soap_serialize_wsc__PropertiesType(soap, (const struct wsc__PropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		soap_serialize_wsc__DerivedKeyTokenType(soap, (const struct wsc__DerivedKeyTokenType *)ptr);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		soap_serialize_wsc__SecurityContextTokenType(soap, (const struct wsc__SecurityContextTokenType *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		soap_serialize_wsse__EncodedString(soap, (const struct wsse__EncodedString *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE___name2__GetWarnings:
		soap_serialize___name2__GetWarnings(soap, (const struct __name2__GetWarnings *)ptr);
		break;
	case SOAP_TYPE___name2__HasWarnings:
		soap_serialize___name2__HasWarnings(soap, (const struct __name2__HasWarnings *)ptr);
		break;
	case SOAP_TYPE___name2__GetErrors:
		soap_serialize___name2__GetErrors(soap, (const struct __name2__GetErrors *)ptr);
		break;
	case SOAP_TYPE___name2__HasErrors:
		soap_serialize___name2__HasErrors(soap, (const struct __name2__HasErrors *)ptr);
		break;
	case SOAP_TYPE___name2__GetMessage:
		soap_serialize___name2__GetMessage(soap, (const struct __name2__GetMessage *)ptr);
		break;
	case SOAP_TYPE___name2__HasMessage:
		soap_serialize___name2__HasMessage(soap, (const struct __name2__HasMessage *)ptr);
		break;
	case SOAP_TYPE___name2__IsSamplePlateTrayIn:
		soap_serialize___name2__IsSamplePlateTrayIn(soap, (const struct __name2__IsSamplePlateTrayIn *)ptr);
		break;
	case SOAP_TYPE___name2__IsChipDocked:
		soap_serialize___name2__IsChipDocked(soap, (const struct __name2__IsChipDocked *)ptr);
		break;
	case SOAP_TYPE___name2__GetOperationMode:
		soap_serialize___name2__GetOperationMode(soap, (const struct __name2__GetOperationMode *)ptr);
		break;
	case SOAP_TYPE___name2__RunMaintenanceProcedure:
		soap_serialize___name2__RunMaintenanceProcedure(soap, (const struct __name2__RunMaintenanceProcedure *)ptr);
		break;
	case SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures:
		soap_serialize___name2__GetNamesOfMaintenanceProcedures(soap, (const struct __name2__GetNamesOfMaintenanceProcedures *)ptr);
		break;
	case SOAP_TYPE___name2__GetStandbyAfterFinish:
		soap_serialize___name2__GetStandbyAfterFinish(soap, (const struct __name2__GetStandbyAfterFinish *)ptr);
		break;
	case SOAP_TYPE___name2__SetStandbyAfterFinish:
		soap_serialize___name2__SetStandbyAfterFinish(soap, (const struct __name2__SetStandbyAfterFinish *)ptr);
		break;
	case SOAP_TYPE___name2__LeaveStandby:
		soap_serialize___name2__LeaveStandby(soap, (const struct __name2__LeaveStandby *)ptr);
		break;
	case SOAP_TYPE___name2__AbortScript:
		soap_serialize___name2__AbortScript(soap, (const struct __name2__AbortScript *)ptr);
		break;
	case SOAP_TYPE___name2__ResetRunset:
		soap_serialize___name2__ResetRunset(soap, (const struct __name2__ResetRunset *)ptr);
		break;
	case SOAP_TYPE___name2__ResumeRunset:
		soap_serialize___name2__ResumeRunset(soap, (const struct __name2__ResumeRunset *)ptr);
		break;
	case SOAP_TYPE___name2__PauseRunsetAfter:
		soap_serialize___name2__PauseRunsetAfter(soap, (const struct __name2__PauseRunsetAfter *)ptr);
		break;
	case SOAP_TYPE___name2__StartSelectedRunsetFrom:
		soap_serialize___name2__StartSelectedRunsetFrom(soap, (const struct __name2__StartSelectedRunsetFrom *)ptr);
		break;
	case SOAP_TYPE___name2__StartSelectedRunset:
		soap_serialize___name2__StartSelectedRunset(soap, (const struct __name2__StartSelectedRunset *)ptr);
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayIn:
		soap_serialize___name2__MoveSamplePlateTrayIn(soap, (const struct __name2__MoveSamplePlateTrayIn *)ptr);
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayOut:
		soap_serialize___name2__MoveSamplePlateTrayOut(soap, (const struct __name2__MoveSamplePlateTrayOut *)ptr);
		break;
	case SOAP_TYPE___name2__GetCurrentSamplePlateId:
		soap_serialize___name2__GetCurrentSamplePlateId(soap, (const struct __name2__GetCurrentSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name2__GetSamplePlateId:
		soap_serialize___name2__GetSamplePlateId(soap, (const struct __name2__GetSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name2__SetSamplePlateId:
		soap_serialize___name2__SetSamplePlateId(soap, (const struct __name2__SetSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name2__CreateRunset:
		soap_serialize___name2__CreateRunset(soap, (const struct __name2__CreateRunset *)ptr);
		break;
	case SOAP_TYPE___name2__SelectRunset:
		soap_serialize___name2__SelectRunset(soap, (const struct __name2__SelectRunset *)ptr);
		break;
	case SOAP_TYPE___name2__SelectMethod:
		soap_serialize___name2__SelectMethod(soap, (const struct __name2__SelectMethod *)ptr);
		break;
	case SOAP_TYPE___name2__GetMethodNamesOfRunset:
		soap_serialize___name2__GetMethodNamesOfRunset(soap, (const struct __name2__GetMethodNamesOfRunset *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfRunset:
		soap_serialize___name2__GetAssayTypeOfRunset(soap, (const struct __name2__GetAssayTypeOfRunset *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset:
		soap_serialize___name2__GetAssayTypeOfCurrentRunset(soap, (const struct __name2__GetAssayTypeOfCurrentRunset *)ptr);
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentRunset:
		soap_serialize___name2__GetNameOfCurrentRunset(soap, (const struct __name2__GetNameOfCurrentRunset *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllRunsets:
		soap_serialize___name2__GetAssayTypesOfAllRunsets(soap, (const struct __name2__GetAssayTypesOfAllRunsets *)ptr);
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType:
		soap_serialize___name2__GetNamesOfRunsetsOfAssayType(soap, (const struct __name2__GetNamesOfRunsetsOfAssayType *)ptr);
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsets:
		soap_serialize___name2__GetNamesOfRunsets(soap, (const struct __name2__GetNamesOfRunsets *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfMethod:
		soap_serialize___name2__GetAssayTypeOfMethod(soap, (const struct __name2__GetAssayTypeOfMethod *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod:
		soap_serialize___name2__GetAssayTypeOfCurrentMethod(soap, (const struct __name2__GetAssayTypeOfCurrentMethod *)ptr);
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentMethod:
		soap_serialize___name2__GetNameOfCurrentMethod(soap, (const struct __name2__GetNameOfCurrentMethod *)ptr);
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllMethods:
		soap_serialize___name2__GetAssayTypesOfAllMethods(soap, (const struct __name2__GetAssayTypesOfAllMethods *)ptr);
		break;
	case SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType:
		soap_serialize___name2__GetNamesOfMethodsOfAssayType(soap, (const struct __name2__GetNamesOfMethodsOfAssayType *)ptr);
		break;
	case SOAP_TYPE___name2__GetNamesOfMethods:
		soap_serialize___name2__GetNamesOfMethods(soap, (const struct __name2__GetNamesOfMethods *)ptr);
		break;
	case SOAP_TYPE___name__GetWarnings:
		soap_serialize___name__GetWarnings(soap, (const struct __name__GetWarnings *)ptr);
		break;
	case SOAP_TYPE___name__HasWarnings:
		soap_serialize___name__HasWarnings(soap, (const struct __name__HasWarnings *)ptr);
		break;
	case SOAP_TYPE___name__GetErrors:
		soap_serialize___name__GetErrors(soap, (const struct __name__GetErrors *)ptr);
		break;
	case SOAP_TYPE___name__HasErrors:
		soap_serialize___name__HasErrors(soap, (const struct __name__HasErrors *)ptr);
		break;
	case SOAP_TYPE___name__GetMessage:
		soap_serialize___name__GetMessage(soap, (const struct __name__GetMessage *)ptr);
		break;
	case SOAP_TYPE___name__HasMessage:
		soap_serialize___name__HasMessage(soap, (const struct __name__HasMessage *)ptr);
		break;
	case SOAP_TYPE___name__IsSamplePlateTrayIn:
		soap_serialize___name__IsSamplePlateTrayIn(soap, (const struct __name__IsSamplePlateTrayIn *)ptr);
		break;
	case SOAP_TYPE___name__IsChipDocked:
		soap_serialize___name__IsChipDocked(soap, (const struct __name__IsChipDocked *)ptr);
		break;
	case SOAP_TYPE___name__GetOperationMode:
		soap_serialize___name__GetOperationMode(soap, (const struct __name__GetOperationMode *)ptr);
		break;
	case SOAP_TYPE___name__RunMaintenanceProcedure:
		soap_serialize___name__RunMaintenanceProcedure(soap, (const struct __name__RunMaintenanceProcedure *)ptr);
		break;
	case SOAP_TYPE___name__GetNamesOfMaintenanceProcedures:
		soap_serialize___name__GetNamesOfMaintenanceProcedures(soap, (const struct __name__GetNamesOfMaintenanceProcedures *)ptr);
		break;
	case SOAP_TYPE___name__GetStandbyAfterFinish:
		soap_serialize___name__GetStandbyAfterFinish(soap, (const struct __name__GetStandbyAfterFinish *)ptr);
		break;
	case SOAP_TYPE___name__SetStandbyAfterFinish:
		soap_serialize___name__SetStandbyAfterFinish(soap, (const struct __name__SetStandbyAfterFinish *)ptr);
		break;
	case SOAP_TYPE___name__LeaveStandby:
		soap_serialize___name__LeaveStandby(soap, (const struct __name__LeaveStandby *)ptr);
		break;
	case SOAP_TYPE___name__AbortScript:
		soap_serialize___name__AbortScript(soap, (const struct __name__AbortScript *)ptr);
		break;
	case SOAP_TYPE___name__ResetRunset:
		soap_serialize___name__ResetRunset(soap, (const struct __name__ResetRunset *)ptr);
		break;
	case SOAP_TYPE___name__ResumeRunset:
		soap_serialize___name__ResumeRunset(soap, (const struct __name__ResumeRunset *)ptr);
		break;
	case SOAP_TYPE___name__PauseRunsetAfter:
		soap_serialize___name__PauseRunsetAfter(soap, (const struct __name__PauseRunsetAfter *)ptr);
		break;
	case SOAP_TYPE___name__StartSelectedRunsetFrom:
		soap_serialize___name__StartSelectedRunsetFrom(soap, (const struct __name__StartSelectedRunsetFrom *)ptr);
		break;
	case SOAP_TYPE___name__StartSelectedRunset:
		soap_serialize___name__StartSelectedRunset(soap, (const struct __name__StartSelectedRunset *)ptr);
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayIn:
		soap_serialize___name__MoveSamplePlateTrayIn(soap, (const struct __name__MoveSamplePlateTrayIn *)ptr);
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayOut:
		soap_serialize___name__MoveSamplePlateTrayOut(soap, (const struct __name__MoveSamplePlateTrayOut *)ptr);
		break;
	case SOAP_TYPE___name__GetCurrentSamplePlateId:
		soap_serialize___name__GetCurrentSamplePlateId(soap, (const struct __name__GetCurrentSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name__GetSamplePlateId:
		soap_serialize___name__GetSamplePlateId(soap, (const struct __name__GetSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name__SetSamplePlateId:
		soap_serialize___name__SetSamplePlateId(soap, (const struct __name__SetSamplePlateId *)ptr);
		break;
	case SOAP_TYPE___name__CreateRunset:
		soap_serialize___name__CreateRunset(soap, (const struct __name__CreateRunset *)ptr);
		break;
	case SOAP_TYPE___name__SelectRunset:
		soap_serialize___name__SelectRunset(soap, (const struct __name__SelectRunset *)ptr);
		break;
	case SOAP_TYPE___name__SelectMethod:
		soap_serialize___name__SelectMethod(soap, (const struct __name__SelectMethod *)ptr);
		break;
	case SOAP_TYPE___name__GetMethodNamesOfRunset:
		soap_serialize___name__GetMethodNamesOfRunset(soap, (const struct __name__GetMethodNamesOfRunset *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfRunset:
		soap_serialize___name__GetAssayTypeOfRunset(soap, (const struct __name__GetAssayTypeOfRunset *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentRunset:
		soap_serialize___name__GetAssayTypeOfCurrentRunset(soap, (const struct __name__GetAssayTypeOfCurrentRunset *)ptr);
		break;
	case SOAP_TYPE___name__GetNameOfCurrentRunset:
		soap_serialize___name__GetNameOfCurrentRunset(soap, (const struct __name__GetNameOfCurrentRunset *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllRunsets:
		soap_serialize___name__GetAssayTypesOfAllRunsets(soap, (const struct __name__GetAssayTypesOfAllRunsets *)ptr);
		break;
	case SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType:
		soap_serialize___name__GetNamesOfRunsetsOfAssayType(soap, (const struct __name__GetNamesOfRunsetsOfAssayType *)ptr);
		break;
	case SOAP_TYPE___name__GetNamesOfRunsets:
		soap_serialize___name__GetNamesOfRunsets(soap, (const struct __name__GetNamesOfRunsets *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfMethod:
		soap_serialize___name__GetAssayTypeOfMethod(soap, (const struct __name__GetAssayTypeOfMethod *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentMethod:
		soap_serialize___name__GetAssayTypeOfCurrentMethod(soap, (const struct __name__GetAssayTypeOfCurrentMethod *)ptr);
		break;
	case SOAP_TYPE___name__GetNameOfCurrentMethod:
		soap_serialize___name__GetNameOfCurrentMethod(soap, (const struct __name__GetNameOfCurrentMethod *)ptr);
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllMethods:
		soap_serialize___name__GetAssayTypesOfAllMethods(soap, (const struct __name__GetAssayTypesOfAllMethods *)ptr);
		break;
	case SOAP_TYPE___name__GetNamesOfMethodsOfAssayType:
		soap_serialize___name__GetNamesOfMethodsOfAssayType(soap, (const struct __name__GetNamesOfMethodsOfAssayType *)ptr);
		break;
	case SOAP_TYPE___name__GetNamesOfMethods:
		soap_serialize___name__GetNamesOfMethods(soap, (const struct __name__GetNamesOfMethods *)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		soap_serialize_PointerTowsrm__TerminateSequenceResponseType(soap, (struct wsrm__TerminateSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		soap_serialize_PointerTowsrm__TerminateSequenceType(soap, (struct wsrm__TerminateSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		soap_serialize_PointerTowsrm__CloseSequenceResponseType(soap, (struct wsrm__CloseSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		soap_serialize_PointerTowsrm__CloseSequenceType(soap, (struct wsrm__CloseSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		soap_serialize_PointerTowsrm__CreateSequenceResponseType(soap, (struct wsrm__CreateSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		soap_serialize_PointerTowsrm__CreateSequenceType(soap, (struct wsrm__CreateSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		soap_serialize_PointerTowsrm__SequenceFaultType(soap, (struct wsrm__SequenceFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement(soap, (struct _wsrm__SequenceAcknowledgement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		soap_serialize_PointerTowsrm__AckRequestedType(soap, (struct wsrm__AckRequestedType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		soap_serialize_PointerTowsrm__SequenceType(soap, (struct wsrm__SequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(soap, (struct _wsrm__SequenceAcknowledgement_None *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, (struct _wsrm__SequenceAcknowledgement_Final *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		soap_serialize_PointerTowsrm__AcceptType(soap, (struct wsrm__AcceptType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, (enum wsrm__IncompleteSequenceBehaviorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__OfferType:
		soap_serialize_PointerTowsrm__OfferType(soap, (struct wsrm__OfferType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		soap_serialize_PointerTo_wsrm__UsesSequenceSSL(soap, (struct _wsrm__UsesSequenceSSL *const*)ptr);
		break;
	case SOAP_TYPE__wsrm__Identifier:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenCollectionType:
		soap_serialize_PointerTowst__RequestSecurityTokenCollectionType(soap, (struct wst__RequestSecurityTokenCollectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseCollectionType:
		soap_serialize_PointerTowst__RequestSecurityTokenResponseCollectionType(soap, (struct wst__RequestSecurityTokenResponseCollectionType *const*)ptr);
		break;
	case SOAP_TYPE__wst__Delegatable:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__Forwardable:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__EncryptWith:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__SignWith:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__KeyWrapAlgorithm:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__ComputedKeyAlgorithm:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__CanonicalizationAlgorithm:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__EncryptionAlgorithm:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__SignatureAlgorithm:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__KeyType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__AuthenticationType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__CombinedHash:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__Challenge:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__ComputedKey:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__RequestType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wst__TokenType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowst__ParticipantType:
		soap_serialize_PointerTowst__ParticipantType(soap, (struct wst__ParticipantType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseType:
		soap_serialize_PointerTowst__RequestSecurityTokenResponseType(soap, (struct wst__RequestSecurityTokenResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestSecurityTokenType:
		soap_serialize_PointerTowst__RequestSecurityTokenType(soap, (struct wst__RequestSecurityTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__LifetimeType:
		soap_serialize_PointerTowst__LifetimeType(soap, (struct wst__LifetimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestedProofTokenType:
		soap_serialize_PointerTowst__RequestedProofTokenType(soap, (struct wst__RequestedProofTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestedReferenceType:
		soap_serialize_PointerTowst__RequestedReferenceType(soap, (struct wst__RequestedReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__RequestedSecurityTokenType:
		soap_serialize_PointerTowst__RequestedSecurityTokenType(soap, (struct wst__RequestedSecurityTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__AuthenticatorType:
		soap_serialize_PointerTowst__AuthenticatorType(soap, (struct wst__AuthenticatorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__BinaryExchangeType:
		soap_serialize_PointerTowst__BinaryExchangeType(soap, (struct wst__BinaryExchangeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__EntropyType:
		soap_serialize_PointerTowst__EntropyType(soap, (struct wst__EntropyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsp__AppliesTo_:
		soap_serialize_PointerTo_wsp__AppliesTo_(soap, (struct _wsp__AppliesTo_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__BinarySecretType:
		soap_serialize_PointerTowst__BinarySecretType(soap, (struct wst__BinarySecretType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		soap_serialize_PointerTowsc__SecurityContextTokenType(soap, (struct wsc__SecurityContextTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionURIRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionIDRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		soap_serialize_PointerToPointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType:
		soap_serialize_PointerTo__saml2__union_AttributeStatementType(soap, (struct __saml2__union_AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		soap_serialize_PointerTosaml2__AttributeType(soap, (struct saml2__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		soap_serialize_PointerTosaml2__EvidenceType(soap, (struct saml2__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ActionType:
		soap_serialize_PointerTosaml2__ActionType(soap, (struct saml2__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		soap_serialize_PointerTosaml2__AuthnContextType(soap, (struct saml2__AuthnContextType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		soap_serialize_PointerTosaml2__SubjectLocalityType(soap, (struct saml2__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_EvidenceType:
		soap_serialize_PointerTo__saml2__union_EvidenceType(soap, (struct __saml2__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AdviceType:
		soap_serialize_PointerTo__saml2__union_AdviceType(soap, (struct __saml2__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		soap_serialize_PointerTosaml2__AssertionType(soap, (struct saml2__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_ConditionsType:
		soap_serialize_PointerTo__saml2__union_ConditionsType(soap, (struct __saml2__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, (struct saml2__ProxyRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		soap_serialize_PointerTosaml2__OneTimeUseType(soap, (struct saml2__OneTimeUseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, (struct saml2__AudienceRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		soap_serialize_PointerTosaml2__ConditionAbstractType(soap, (struct saml2__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, (struct saml2__SubjectConfirmationDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		soap_serialize_PointerTosaml2__SubjectConfirmationType(soap, (struct saml2__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		soap_serialize_PointerTosaml2__EncryptedElementType(soap, (struct saml2__EncryptedElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, (struct saml2__BaseIDAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AssertionType:
		soap_serialize_PointerTo__saml2__union_AssertionType(soap, (struct __saml2__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		soap_serialize_PointerTosaml2__AttributeStatementType(soap, (struct saml2__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, (struct saml2__AuthzDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		soap_serialize_PointerTosaml2__AuthnStatementType(soap, (struct saml2__AuthnStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		soap_serialize_PointerTosaml2__StatementAbstractType(soap, (struct saml2__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		soap_serialize_PointerTosaml2__AdviceType(soap, (struct saml2__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		soap_serialize_PointerTosaml2__ConditionsType(soap, (struct saml2__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		soap_serialize_PointerTosaml2__SubjectType(soap, (struct saml2__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		soap_serialize_PointerTosaml2__NameIDType(soap, (struct saml2__NameIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToPointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType **const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE__saml1__ConfirmationMethod:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__AssertionIDReference:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		soap_serialize_PointerTosaml1__AttributeType(soap, (struct saml1__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		soap_serialize_PointerTosaml1__EvidenceType(soap, (struct saml1__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ActionType:
		soap_serialize_PointerTosaml1__ActionType(soap, (struct saml1__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		soap_serialize_PointerTosaml1__AuthorityBindingType(soap, (struct saml1__AuthorityBindingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		soap_serialize_PointerTosaml1__SubjectLocalityType(soap, (struct saml1__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		soap_serialize_PointerTosaml1__SubjectType(soap, (struct saml1__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_EvidenceType:
		soap_serialize_PointerTo__saml1__union_EvidenceType(soap, (struct __saml1__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, (struct saml1__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		soap_serialize_PointerTosaml1__NameIdentifierType(soap, (struct saml1__NameIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AdviceType:
		soap_serialize_PointerTo__saml1__union_AdviceType(soap, (struct __saml1__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		soap_serialize_PointerTosaml1__AssertionType(soap, (struct saml1__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_ConditionsType:
		soap_serialize_PointerTo__saml1__union_ConditionsType(soap, (struct __saml1__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		soap_serialize_PointerTosaml1__ConditionAbstractType(soap, (struct saml1__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, (struct saml1__DoNotCacheConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, (struct saml1__AudienceRestrictionConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__Signature:
		soap_serialize_PointerTo_ds__Signature(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AssertionType:
		soap_serialize_PointerTo__saml1__union_AssertionType(soap, (struct __saml1__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		soap_serialize_PointerTosaml1__AttributeStatementType(soap, (struct saml1__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, (struct saml1__AuthorizationDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, (struct saml1__AuthenticationStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, (struct saml1__SubjectStatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		soap_serialize_PointerTosaml1__StatementAbstractType(soap, (struct saml1__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		soap_serialize_PointerTosaml1__AdviceType(soap, (struct saml1__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		soap_serialize_PointerTosaml1__ConditionsType(soap, (struct saml1__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence:
		soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, (struct __wsc__DerivedKeyTokenType_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerToULONG64:
		soap_serialize_PointerToULONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		soap_serialize_PointerTowsc__PropertiesType(soap, (struct wsc__PropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE__ds__SignatureValue:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsse__EncodedString:
		soap_serialize_PointerTowsse__EncodedString(soap, (struct wsse__EncodedString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetWarnings:
		soap_serialize_PointerTo_tempuri__GetWarnings(soap, (_tempuri__GetWarnings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__HasWarnings:
		soap_serialize_PointerTo_tempuri__HasWarnings(soap, (_tempuri__HasWarnings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetErrors:
		soap_serialize_PointerTo_tempuri__GetErrors(soap, (_tempuri__GetErrors *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__HasErrors:
		soap_serialize_PointerTo_tempuri__HasErrors(soap, (_tempuri__HasErrors *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetMessage:
		soap_serialize_PointerTo_tempuri__GetMessage(soap, (_tempuri__GetMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__HasMessage:
		soap_serialize_PointerTo_tempuri__HasMessage(soap, (_tempuri__HasMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__IsSamplePlateTrayIn:
		soap_serialize_PointerTo_tempuri__IsSamplePlateTrayIn(soap, (_tempuri__IsSamplePlateTrayIn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__IsChipDocked:
		soap_serialize_PointerTo_tempuri__IsChipDocked(soap, (_tempuri__IsChipDocked *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetOperationMode:
		soap_serialize_PointerTo_tempuri__GetOperationMode(soap, (_tempuri__GetOperationMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__RunMaintenanceProcedure:
		soap_serialize_PointerTo_tempuri__RunMaintenanceProcedure(soap, (_tempuri__RunMaintenanceProcedure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMaintenanceProcedures:
		soap_serialize_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, (_tempuri__GetNamesOfMaintenanceProcedures *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetStandbyAfterFinish:
		soap_serialize_PointerTo_tempuri__GetStandbyAfterFinish(soap, (_tempuri__GetStandbyAfterFinish *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__SetStandbyAfterFinish:
		soap_serialize_PointerTo_tempuri__SetStandbyAfterFinish(soap, (_tempuri__SetStandbyAfterFinish *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LeaveStandby:
		soap_serialize_PointerTo_tempuri__LeaveStandby(soap, (_tempuri__LeaveStandby *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AbortScript:
		soap_serialize_PointerTo_tempuri__AbortScript(soap, (_tempuri__AbortScript *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ResetRunset:
		soap_serialize_PointerTo_tempuri__ResetRunset(soap, (_tempuri__ResetRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ResumeRunset:
		soap_serialize_PointerTo_tempuri__ResumeRunset(soap, (_tempuri__ResumeRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__PauseRunsetAfter:
		soap_serialize_PointerTo_tempuri__PauseRunsetAfter(soap, (_tempuri__PauseRunsetAfter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunsetFrom:
		soap_serialize_PointerTo_tempuri__StartSelectedRunsetFrom(soap, (_tempuri__StartSelectedRunsetFrom *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__StartSelectedRunset:
		soap_serialize_PointerTo_tempuri__StartSelectedRunset(soap, (_tempuri__StartSelectedRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayIn:
		soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, (_tempuri__MoveSamplePlateTrayIn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayOut:
		soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, (_tempuri__MoveSamplePlateTrayOut *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetCurrentSamplePlateId:
		soap_serialize_PointerTo_tempuri__GetCurrentSamplePlateId(soap, (_tempuri__GetCurrentSamplePlateId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetSamplePlateId:
		soap_serialize_PointerTo_tempuri__GetSamplePlateId(soap, (_tempuri__GetSamplePlateId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__SetSamplePlateId:
		soap_serialize_PointerTo_tempuri__SetSamplePlateId(soap, (_tempuri__SetSamplePlateId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__CreateRunset:
		soap_serialize_PointerTo_tempuri__CreateRunset(soap, (_tempuri__CreateRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__SelectRunset:
		soap_serialize_PointerTo_tempuri__SelectRunset(soap, (_tempuri__SelectRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__SelectMethod:
		soap_serialize_PointerTo_tempuri__SelectMethod(soap, (_tempuri__SelectMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetMethodNamesOfRunset:
		soap_serialize_PointerTo_tempuri__GetMethodNamesOfRunset(soap, (_tempuri__GetMethodNamesOfRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfRunset:
		soap_serialize_PointerTo_tempuri__GetAssayTypeOfRunset(soap, (_tempuri__GetAssayTypeOfRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentRunset:
		soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, (_tempuri__GetAssayTypeOfCurrentRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentRunset:
		soap_serialize_PointerTo_tempuri__GetNameOfCurrentRunset(soap, (_tempuri__GetNameOfCurrentRunset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllRunsets:
		soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, (_tempuri__GetAssayTypesOfAllRunsets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType:
		soap_serialize_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, (_tempuri__GetNamesOfRunsetsOfAssayType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsets:
		soap_serialize_PointerTo_tempuri__GetNamesOfRunsets(soap, (_tempuri__GetNamesOfRunsets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfMethod:
		soap_serialize_PointerTo_tempuri__GetAssayTypeOfMethod(soap, (_tempuri__GetAssayTypeOfMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentMethod:
		soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, (_tempuri__GetAssayTypeOfCurrentMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentMethod:
		soap_serialize_PointerTo_tempuri__GetNameOfCurrentMethod(soap, (_tempuri__GetNameOfCurrentMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllMethods:
		soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, (_tempuri__GetAssayTypesOfAllMethods *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethodsOfAssayType:
		soap_serialize_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, (_tempuri__GetNamesOfMethodsOfAssayType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethods:
		soap_serialize_PointerTo_tempuri__GetNamesOfMethods(soap, (_tempuri__GetNamesOfMethods *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		soap_serialize_PointerToarr__ArrayOfstring(soap, (arr__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__tempuri__GetNamesOfMethods:
		return (void*)soap_instantiate__tempuri__GetNamesOfMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfMethodsResponse:
		return (void*)soap_instantiate__tempuri__GetNamesOfMethodsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType:
		return (void*)soap_instantiate__tempuri__GetNamesOfMethodsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse:
		return (void*)soap_instantiate__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods:
		return (void*)soap_instantiate__tempuri__GetAssayTypesOfAllMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypesOfAllMethodsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethod:
		return (void*)soap_instantiate__tempuri__GetNameOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse:
		return (void*)soap_instantiate__tempuri__GetNameOfCurrentMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethod:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfRunsets:
		return (void*)soap_instantiate__tempuri__GetNamesOfRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse:
		return (void*)soap_instantiate__tempuri__GetNamesOfRunsetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType:
		return (void*)soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse:
		return (void*)soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets:
		return (void*)soap_instantiate__tempuri__GetAssayTypesOfAllRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunset:
		return (void*)soap_instantiate__tempuri__GetNameOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse:
		return (void*)soap_instantiate__tempuri__GetNameOfCurrentRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunset:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse:
		return (void*)soap_instantiate__tempuri__GetAssayTypeOfRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunset:
		return (void*)soap_instantiate__tempuri__GetMethodNamesOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse:
		return (void*)soap_instantiate__tempuri__GetMethodNamesOfRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SelectMethod:
		return (void*)soap_instantiate__tempuri__SelectMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SelectMethodResponse:
		return (void*)soap_instantiate__tempuri__SelectMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SelectRunset:
		return (void*)soap_instantiate__tempuri__SelectRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SelectRunsetResponse:
		return (void*)soap_instantiate__tempuri__SelectRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__CreateRunset:
		return (void*)soap_instantiate__tempuri__CreateRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__CreateRunsetResponse:
		return (void*)soap_instantiate__tempuri__CreateRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetSamplePlateId:
		return (void*)soap_instantiate__tempuri__SetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetSamplePlateIdResponse:
		return (void*)soap_instantiate__tempuri__SetSamplePlateIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetSamplePlateId:
		return (void*)soap_instantiate__tempuri__GetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetSamplePlateIdResponse:
		return (void*)soap_instantiate__tempuri__GetSamplePlateIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateId:
		return (void*)soap_instantiate__tempuri__GetCurrentSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse:
		return (void*)soap_instantiate__tempuri__GetCurrentSamplePlateIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOut:
		return (void*)soap_instantiate__tempuri__MoveSamplePlateTrayOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse:
		return (void*)soap_instantiate__tempuri__MoveSamplePlateTrayOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayIn:
		return (void*)soap_instantiate__tempuri__MoveSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse:
		return (void*)soap_instantiate__tempuri__MoveSamplePlateTrayInResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__StartSelectedRunset:
		return (void*)soap_instantiate__tempuri__StartSelectedRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__StartSelectedRunsetResponse:
		return (void*)soap_instantiate__tempuri__StartSelectedRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__StartSelectedRunsetFrom:
		return (void*)soap_instantiate__tempuri__StartSelectedRunsetFrom(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse:
		return (void*)soap_instantiate__tempuri__StartSelectedRunsetFromResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__PauseRunsetAfter:
		return (void*)soap_instantiate__tempuri__PauseRunsetAfter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__PauseRunsetAfterResponse:
		return (void*)soap_instantiate__tempuri__PauseRunsetAfterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ResumeRunset:
		return (void*)soap_instantiate__tempuri__ResumeRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ResumeRunsetResponse:
		return (void*)soap_instantiate__tempuri__ResumeRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ResetRunset:
		return (void*)soap_instantiate__tempuri__ResetRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ResetRunsetResponse:
		return (void*)soap_instantiate__tempuri__ResetRunsetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AbortScript:
		return (void*)soap_instantiate__tempuri__AbortScript(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AbortScriptResponse:
		return (void*)soap_instantiate__tempuri__AbortScriptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LeaveStandby:
		return (void*)soap_instantiate__tempuri__LeaveStandby(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LeaveStandbyResponse:
		return (void*)soap_instantiate__tempuri__LeaveStandbyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetStandbyAfterFinish:
		return (void*)soap_instantiate__tempuri__SetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse:
		return (void*)soap_instantiate__tempuri__SetStandbyAfterFinishResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetStandbyAfterFinish:
		return (void*)soap_instantiate__tempuri__GetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse:
		return (void*)soap_instantiate__tempuri__GetStandbyAfterFinishResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures:
		return (void*)soap_instantiate__tempuri__GetNamesOfMaintenanceProcedures(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse:
		return (void*)soap_instantiate__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__RunMaintenanceProcedure:
		return (void*)soap_instantiate__tempuri__RunMaintenanceProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse:
		return (void*)soap_instantiate__tempuri__RunMaintenanceProcedureResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetOperationMode:
		return (void*)soap_instantiate__tempuri__GetOperationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetOperationModeResponse:
		return (void*)soap_instantiate__tempuri__GetOperationModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__IsChipDocked:
		return (void*)soap_instantiate__tempuri__IsChipDocked(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__IsChipDockedResponse:
		return (void*)soap_instantiate__tempuri__IsChipDockedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__IsSamplePlateTrayIn:
		return (void*)soap_instantiate__tempuri__IsSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse:
		return (void*)soap_instantiate__tempuri__IsSamplePlateTrayInResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasMessage:
		return (void*)soap_instantiate__tempuri__HasMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasMessageResponse:
		return (void*)soap_instantiate__tempuri__HasMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetMessage:
		return (void*)soap_instantiate__tempuri__GetMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetMessageResponse:
		return (void*)soap_instantiate__tempuri__GetMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasErrors:
		return (void*)soap_instantiate__tempuri__HasErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasErrorsResponse:
		return (void*)soap_instantiate__tempuri__HasErrorsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetErrors:
		return (void*)soap_instantiate__tempuri__GetErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetErrorsResponse:
		return (void*)soap_instantiate__tempuri__GetErrorsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasWarnings:
		return (void*)soap_instantiate__tempuri__HasWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__HasWarningsResponse:
		return (void*)soap_instantiate__tempuri__HasWarningsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetWarnings:
		return (void*)soap_instantiate__tempuri__GetWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetWarningsResponse:
		return (void*)soap_instantiate__tempuri__GetWarningsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_arr__ArrayOfstring:
		return (void*)soap_instantiate_arr__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNamesOfMethods:
		return (void*)soap_instantiate___name__GetNamesOfMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNamesOfMethodsOfAssayType:
		return (void*)soap_instantiate___name__GetNamesOfMethodsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypesOfAllMethods:
		return (void*)soap_instantiate___name__GetAssayTypesOfAllMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNameOfCurrentMethod:
		return (void*)soap_instantiate___name__GetNameOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypeOfCurrentMethod:
		return (void*)soap_instantiate___name__GetAssayTypeOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypeOfMethod:
		return (void*)soap_instantiate___name__GetAssayTypeOfMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNamesOfRunsets:
		return (void*)soap_instantiate___name__GetNamesOfRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType:
		return (void*)soap_instantiate___name__GetNamesOfRunsetsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypesOfAllRunsets:
		return (void*)soap_instantiate___name__GetAssayTypesOfAllRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNameOfCurrentRunset:
		return (void*)soap_instantiate___name__GetNameOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypeOfCurrentRunset:
		return (void*)soap_instantiate___name__GetAssayTypeOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetAssayTypeOfRunset:
		return (void*)soap_instantiate___name__GetAssayTypeOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetMethodNamesOfRunset:
		return (void*)soap_instantiate___name__GetMethodNamesOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__SelectMethod:
		return (void*)soap_instantiate___name__SelectMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__SelectRunset:
		return (void*)soap_instantiate___name__SelectRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__CreateRunset:
		return (void*)soap_instantiate___name__CreateRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__SetSamplePlateId:
		return (void*)soap_instantiate___name__SetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetSamplePlateId:
		return (void*)soap_instantiate___name__GetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetCurrentSamplePlateId:
		return (void*)soap_instantiate___name__GetCurrentSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__MoveSamplePlateTrayOut:
		return (void*)soap_instantiate___name__MoveSamplePlateTrayOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__MoveSamplePlateTrayIn:
		return (void*)soap_instantiate___name__MoveSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__StartSelectedRunset:
		return (void*)soap_instantiate___name__StartSelectedRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__StartSelectedRunsetFrom:
		return (void*)soap_instantiate___name__StartSelectedRunsetFrom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__PauseRunsetAfter:
		return (void*)soap_instantiate___name__PauseRunsetAfter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__ResumeRunset:
		return (void*)soap_instantiate___name__ResumeRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__ResetRunset:
		return (void*)soap_instantiate___name__ResetRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__AbortScript:
		return (void*)soap_instantiate___name__AbortScript(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__LeaveStandby:
		return (void*)soap_instantiate___name__LeaveStandby(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__SetStandbyAfterFinish:
		return (void*)soap_instantiate___name__SetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetStandbyAfterFinish:
		return (void*)soap_instantiate___name__GetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetNamesOfMaintenanceProcedures:
		return (void*)soap_instantiate___name__GetNamesOfMaintenanceProcedures(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__RunMaintenanceProcedure:
		return (void*)soap_instantiate___name__RunMaintenanceProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetOperationMode:
		return (void*)soap_instantiate___name__GetOperationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__IsChipDocked:
		return (void*)soap_instantiate___name__IsChipDocked(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__IsSamplePlateTrayIn:
		return (void*)soap_instantiate___name__IsSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__HasMessage:
		return (void*)soap_instantiate___name__HasMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetMessage:
		return (void*)soap_instantiate___name__GetMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__HasErrors:
		return (void*)soap_instantiate___name__HasErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetErrors:
		return (void*)soap_instantiate___name__GetErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__HasWarnings:
		return (void*)soap_instantiate___name__HasWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name__GetWarnings:
		return (void*)soap_instantiate___name__GetWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNamesOfMethods:
		return (void*)soap_instantiate___name2__GetNamesOfMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType:
		return (void*)soap_instantiate___name2__GetNamesOfMethodsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypesOfAllMethods:
		return (void*)soap_instantiate___name2__GetAssayTypesOfAllMethods(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNameOfCurrentMethod:
		return (void*)soap_instantiate___name2__GetNameOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod:
		return (void*)soap_instantiate___name2__GetAssayTypeOfCurrentMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypeOfMethod:
		return (void*)soap_instantiate___name2__GetAssayTypeOfMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNamesOfRunsets:
		return (void*)soap_instantiate___name2__GetNamesOfRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType:
		return (void*)soap_instantiate___name2__GetNamesOfRunsetsOfAssayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypesOfAllRunsets:
		return (void*)soap_instantiate___name2__GetAssayTypesOfAllRunsets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNameOfCurrentRunset:
		return (void*)soap_instantiate___name2__GetNameOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset:
		return (void*)soap_instantiate___name2__GetAssayTypeOfCurrentRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetAssayTypeOfRunset:
		return (void*)soap_instantiate___name2__GetAssayTypeOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetMethodNamesOfRunset:
		return (void*)soap_instantiate___name2__GetMethodNamesOfRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__SelectMethod:
		return (void*)soap_instantiate___name2__SelectMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__SelectRunset:
		return (void*)soap_instantiate___name2__SelectRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__CreateRunset:
		return (void*)soap_instantiate___name2__CreateRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__SetSamplePlateId:
		return (void*)soap_instantiate___name2__SetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetSamplePlateId:
		return (void*)soap_instantiate___name2__GetSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetCurrentSamplePlateId:
		return (void*)soap_instantiate___name2__GetCurrentSamplePlateId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__MoveSamplePlateTrayOut:
		return (void*)soap_instantiate___name2__MoveSamplePlateTrayOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__MoveSamplePlateTrayIn:
		return (void*)soap_instantiate___name2__MoveSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__StartSelectedRunset:
		return (void*)soap_instantiate___name2__StartSelectedRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__StartSelectedRunsetFrom:
		return (void*)soap_instantiate___name2__StartSelectedRunsetFrom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__PauseRunsetAfter:
		return (void*)soap_instantiate___name2__PauseRunsetAfter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__ResumeRunset:
		return (void*)soap_instantiate___name2__ResumeRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__ResetRunset:
		return (void*)soap_instantiate___name2__ResetRunset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__AbortScript:
		return (void*)soap_instantiate___name2__AbortScript(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__LeaveStandby:
		return (void*)soap_instantiate___name2__LeaveStandby(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__SetStandbyAfterFinish:
		return (void*)soap_instantiate___name2__SetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetStandbyAfterFinish:
		return (void*)soap_instantiate___name2__GetStandbyAfterFinish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures:
		return (void*)soap_instantiate___name2__GetNamesOfMaintenanceProcedures(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__RunMaintenanceProcedure:
		return (void*)soap_instantiate___name2__RunMaintenanceProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetOperationMode:
		return (void*)soap_instantiate___name2__GetOperationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__IsChipDocked:
		return (void*)soap_instantiate___name2__IsChipDocked(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__IsSamplePlateTrayIn:
		return (void*)soap_instantiate___name2__IsSamplePlateTrayIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__HasMessage:
		return (void*)soap_instantiate___name2__HasMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetMessage:
		return (void*)soap_instantiate___name2__GetMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__HasErrors:
		return (void*)soap_instantiate___name2__HasErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetErrors:
		return (void*)soap_instantiate___name2__GetErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__HasWarnings:
		return (void*)soap_instantiate___name2__HasWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___name2__GetWarnings:
		return (void*)soap_instantiate___name2__GetWarnings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsse__EncodedString:
		return (void*)soap_instantiate_wsse__EncodedString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return (void*)soap_instantiate_xenc__EncryptionPropertyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedType:
		return (void*)soap_instantiate_xenc__EncryptedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return (void*)soap_instantiate_xenc__EncryptionMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherDataType:
		return (void*)soap_instantiate_xenc__CipherDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherReferenceType:
		return (void*)soap_instantiate_xenc__CipherReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__TransformsType:
		return (void*)soap_instantiate_xenc__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__AgreementMethodType:
		return (void*)soap_instantiate_xenc__AgreementMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__ReferenceType:
		return (void*)soap_instantiate_xenc__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return (void*)soap_instantiate_xenc__EncryptionPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___xenc__union_ReferenceList:
		return (void*)soap_instantiate___xenc__union_ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xenc__ReferenceList:
		return (void*)soap_instantiate__xenc__ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedDataType:
		return (void*)soap_instantiate_xenc__EncryptedDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return (void*)soap_instantiate_xenc__EncryptedKeyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return (void*)soap_instantiate_wsc__SecurityContextTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		return (void*)soap_instantiate___wsc__DerivedKeyTokenType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return (void*)soap_instantiate_wsc__DerivedKeyTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__PropertiesType:
		return (void*)soap_instantiate_wsc__PropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_AssertionType:
		return (void*)soap_instantiate___saml1__union_AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AssertionType:
		return (void*)soap_instantiate_saml1__AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_ConditionsType:
		return (void*)soap_instantiate___saml1__union_ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ConditionsType:
		return (void*)soap_instantiate_saml1__ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return (void*)soap_instantiate_saml1__ConditionAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_AdviceType:
		return (void*)soap_instantiate___saml1__union_AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AdviceType:
		return (void*)soap_instantiate_saml1__AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__StatementAbstractType:
		return (void*)soap_instantiate_saml1__StatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectType:
		return (void*)soap_instantiate_saml1__SubjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return (void*)soap_instantiate_saml1__SubjectConfirmationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return (void*)soap_instantiate_saml1__SubjectLocalityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return (void*)soap_instantiate_saml1__AuthorityBindingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_EvidenceType:
		return (void*)soap_instantiate___saml1__union_EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__EvidenceType:
		return (void*)soap_instantiate_saml1__EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return (void*)soap_instantiate_saml1__AttributeDesignatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return (void*)soap_instantiate_saml1__AudienceRestrictionConditionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return (void*)soap_instantiate_saml1__DoNotCacheConditionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return (void*)soap_instantiate_saml1__SubjectStatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__NameIdentifierType:
		return (void*)soap_instantiate_saml1__NameIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ActionType:
		return (void*)soap_instantiate_saml1__ActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeType:
		return (void*)soap_instantiate_saml1__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return (void*)soap_instantiate_saml1__AuthenticationStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return (void*)soap_instantiate_saml1__AuthorizationDecisionStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeStatementType:
		return (void*)soap_instantiate_saml1__AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return (void*)soap_instantiate_saml2__BaseIDAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__EncryptedElementType:
		return (void*)soap_instantiate_saml2__EncryptedElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AssertionType:
		return (void*)soap_instantiate___saml2__union_AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AssertionType:
		return (void*)soap_instantiate_saml2__AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectType:
		return (void*)soap_instantiate_saml2__SubjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return (void*)soap_instantiate_saml2__SubjectConfirmationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_ConditionsType:
		return (void*)soap_instantiate___saml2__union_ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ConditionsType:
		return (void*)soap_instantiate_saml2__ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return (void*)soap_instantiate_saml2__ConditionAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AdviceType:
		return (void*)soap_instantiate___saml2__union_AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AdviceType:
		return (void*)soap_instantiate_saml2__AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__StatementAbstractType:
		return (void*)soap_instantiate_saml2__StatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return (void*)soap_instantiate_saml2__SubjectLocalityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthnContextType:
		return (void*)soap_instantiate_saml2__AuthnContextType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_EvidenceType:
		return (void*)soap_instantiate___saml2__union_EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__EvidenceType:
		return (void*)soap_instantiate_saml2__EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AttributeType:
		return (void*)soap_instantiate_saml2__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__NameIDType:
		return (void*)soap_instantiate_saml2__NameIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return (void*)soap_instantiate_saml2__SubjectConfirmationDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return (void*)soap_instantiate_saml2__AudienceRestrictionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__OneTimeUseType:
		return (void*)soap_instantiate_saml2__OneTimeUseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return (void*)soap_instantiate_saml2__ProxyRestrictionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthnStatementType:
		return (void*)soap_instantiate_saml2__AuthnStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return (void*)soap_instantiate_saml2__AuthzDecisionStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ActionType:
		return (void*)soap_instantiate_saml2__ActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		return (void*)soap_instantiate___saml2__union_AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AttributeStatementType:
		return (void*)soap_instantiate_saml2__AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return (void*)soap_instantiate_saml2__KeyInfoConfirmationDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__wsp__AppliesTo_:
		return (void*)soap_instantiate__wsp__AppliesTo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		return (void*)soap_instantiate_wst__RequestedSecurityTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__EntropyType:
		return (void*)soap_instantiate_wst__EntropyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__AuthenticatorType:
		return (void*)soap_instantiate_wst__AuthenticatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		return (void*)soap_instantiate_wst__RequestSecurityTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		return (void*)soap_instantiate_wst__RequestSecurityTokenResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__ClaimsType:
		return (void*)soap_instantiate_wst__ClaimsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__LifetimeType:
		return (void*)soap_instantiate_wst__LifetimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		return (void*)soap_instantiate_wst__RequestSecurityTokenCollectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		return (void*)soap_instantiate_wst__RequestSecurityTokenResponseCollectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestedReferenceType:
		return (void*)soap_instantiate_wst__RequestedReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestedProofTokenType:
		return (void*)soap_instantiate_wst__RequestedProofTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RenewTargetType:
		return (void*)soap_instantiate_wst__RenewTargetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__AllowPostdatingType:
		return (void*)soap_instantiate_wst__AllowPostdatingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RenewingType:
		return (void*)soap_instantiate_wst__RenewingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__CancelTargetType:
		return (void*)soap_instantiate_wst__CancelTargetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		return (void*)soap_instantiate_wst__RequestedTokenCancelledType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__ValidateTargetType:
		return (void*)soap_instantiate_wst__ValidateTargetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__StatusType:
		return (void*)soap_instantiate_wst__StatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__SignChallengeType:
		return (void*)soap_instantiate_wst__SignChallengeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__RequestKETType:
		return (void*)soap_instantiate_wst__RequestKETType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		return (void*)soap_instantiate_wst__KeyExchangeTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__OnBehalfOfType:
		return (void*)soap_instantiate_wst__OnBehalfOfType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__EncryptionType:
		return (void*)soap_instantiate_wst__EncryptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__ProofEncryptionType:
		return (void*)soap_instantiate_wst__ProofEncryptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__UseKeyType:
		return (void*)soap_instantiate_wst__UseKeyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__DelegateToType:
		return (void*)soap_instantiate_wst__DelegateToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__ParticipantsType:
		return (void*)soap_instantiate_wst__ParticipantsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__ParticipantType:
		return (void*)soap_instantiate_wst__ParticipantType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__BinarySecretType:
		return (void*)soap_instantiate_wst__BinarySecretType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__BinaryExchangeType:
		return (void*)soap_instantiate_wst__BinaryExchangeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wst__RequestSecurityToken:
		return (void*)soap_instantiate___wst__RequestSecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wst__RequestSecurityTokenResponse:
		return (void*)soap_instantiate___wst__RequestSecurityTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wst__RequestSecurityTokenCollection:
		return (void*)soap_instantiate___wst__RequestSecurityTokenCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__SequenceType:
		return (void*)soap_instantiate_wsrm__SequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__AckRequestedType:
		return (void*)soap_instantiate_wsrm__AckRequestedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return (void*)soap_instantiate_wsrm__SequenceFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return (void*)soap_instantiate_wsrm__CreateSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return (void*)soap_instantiate_wsrm__CreateSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return (void*)soap_instantiate_wsrm__CloseSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return (void*)soap_instantiate_wsrm__CloseSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return (void*)soap_instantiate_wsrm__TerminateSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return (void*)soap_instantiate_wsrm__TerminateSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__OfferType:
		return (void*)soap_instantiate_wsrm__OfferType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__AcceptType:
		return (void*)soap_instantiate_wsrm__AcceptType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_Final(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_None(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		return (void*)soap_instantiate__wsrm__UsesSequenceSTR(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		return (void*)soap_instantiate__wsrm__UsesSequenceSSL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CreateSequence:
		return (void*)soap_instantiate___wsrm__CreateSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CloseSequence:
		return (void*)soap_instantiate___wsrm__CloseSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__TerminateSequence:
		return (void*)soap_instantiate___wsrm__TerminateSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		return (void*)soap_instantiate___wsrm__CreateSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		return (void*)soap_instantiate___wsrm__CloseSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		return (void*)soap_instantiate___wsrm__TerminateSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		return (void*)soap_instantiate___wsrm__SequenceAcknowledgement(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__AckRequested:
		return (void*)soap_instantiate___wsrm__AckRequested(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__LastMessage:
		return (void*)soap_instantiate___wsrm__LastMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__Signature:
		return (void*)soap_instantiate__ds__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__Transform:
		return (void*)soap_instantiate__ds__Transform(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__KeyInfo:
		return (void*)soap_instantiate__ds__KeyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Assertion:
		return (void*)soap_instantiate__saml1__Assertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Conditions:
		return (void*)soap_instantiate__saml1__Conditions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Condition:
		return (void*)soap_instantiate__saml1__Condition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		return (void*)soap_instantiate__saml1__AudienceRestrictionCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		return (void*)soap_instantiate__saml1__DoNotCacheCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Advice:
		return (void*)soap_instantiate__saml1__Advice(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Statement:
		return (void*)soap_instantiate__saml1__Statement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectStatement:
		return (void*)soap_instantiate__saml1__SubjectStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Subject:
		return (void*)soap_instantiate__saml1__Subject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__NameIdentifier:
		return (void*)soap_instantiate__saml1__NameIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectConfirmation:
		return (void*)soap_instantiate__saml1__SubjectConfirmation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthenticationStatement:
		return (void*)soap_instantiate__saml1__AuthenticationStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectLocality:
		return (void*)soap_instantiate__saml1__SubjectLocality(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthorityBinding:
		return (void*)soap_instantiate__saml1__AuthorityBinding(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		return (void*)soap_instantiate__saml1__AuthorizationDecisionStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Action:
		return (void*)soap_instantiate__saml1__Action(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Evidence:
		return (void*)soap_instantiate__saml1__Evidence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AttributeStatement:
		return (void*)soap_instantiate__saml1__AttributeStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AttributeDesignator:
		return (void*)soap_instantiate__saml1__AttributeDesignator(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Attribute:
		return (void*)soap_instantiate__saml1__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__BaseID:
		return (void*)soap_instantiate__saml2__BaseID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__NameID:
		return (void*)soap_instantiate__saml2__NameID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedID:
		return (void*)soap_instantiate__saml2__EncryptedID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Issuer:
		return (void*)soap_instantiate__saml2__Issuer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Assertion:
		return (void*)soap_instantiate__saml2__Assertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Subject:
		return (void*)soap_instantiate__saml2__Subject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectConfirmation:
		return (void*)soap_instantiate__saml2__SubjectConfirmation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		return (void*)soap_instantiate__saml2__SubjectConfirmationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Conditions:
		return (void*)soap_instantiate__saml2__Conditions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Condition:
		return (void*)soap_instantiate__saml2__Condition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AudienceRestriction:
		return (void*)soap_instantiate__saml2__AudienceRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__OneTimeUse:
		return (void*)soap_instantiate__saml2__OneTimeUse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__ProxyRestriction:
		return (void*)soap_instantiate__saml2__ProxyRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Advice:
		return (void*)soap_instantiate__saml2__Advice(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedAssertion:
		return (void*)soap_instantiate__saml2__EncryptedAssertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Statement:
		return (void*)soap_instantiate__saml2__Statement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthnStatement:
		return (void*)soap_instantiate__saml2__AuthnStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectLocality:
		return (void*)soap_instantiate__saml2__SubjectLocality(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthnContext:
		return (void*)soap_instantiate__saml2__AuthnContext(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		return (void*)soap_instantiate__saml2__AuthzDecisionStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Action:
		return (void*)soap_instantiate__saml2__Action(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Evidence:
		return (void*)soap_instantiate__saml2__Evidence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AttributeStatement:
		return (void*)soap_instantiate__saml2__AttributeStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Attribute:
		return (void*)soap_instantiate__saml2__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedAttribute:
		return (void*)soap_instantiate__saml2__EncryptedAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestSecurityToken:
		return (void*)soap_instantiate__wst__RequestSecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestSecurityTokenResponse:
		return (void*)soap_instantiate__wst__RequestSecurityTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestedSecurityToken:
		return (void*)soap_instantiate__wst__RequestedSecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__BinarySecret:
		return (void*)soap_instantiate__wst__BinarySecret(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Claims:
		return (void*)soap_instantiate__wst__Claims(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Entropy:
		return (void*)soap_instantiate__wst__Entropy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Lifetime:
		return (void*)soap_instantiate__wst__Lifetime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestSecurityTokenCollection:
		return (void*)soap_instantiate__wst__RequestSecurityTokenCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestSecurityTokenResponseCollection:
		return (void*)soap_instantiate__wst__RequestSecurityTokenResponseCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestedAttachedReference:
		return (void*)soap_instantiate__wst__RequestedAttachedReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestedUnattachedReference:
		return (void*)soap_instantiate__wst__RequestedUnattachedReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestedProofToken:
		return (void*)soap_instantiate__wst__RequestedProofToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__IssuedTokens:
		return (void*)soap_instantiate__wst__IssuedTokens(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RenewTarget:
		return (void*)soap_instantiate__wst__RenewTarget(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__AllowPostdating:
		return (void*)soap_instantiate__wst__AllowPostdating(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Renewing:
		return (void*)soap_instantiate__wst__Renewing(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__CancelTarget:
		return (void*)soap_instantiate__wst__CancelTarget(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestedTokenCancelled:
		return (void*)soap_instantiate__wst__RequestedTokenCancelled(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__ValidateTarget:
		return (void*)soap_instantiate__wst__ValidateTarget(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Status:
		return (void*)soap_instantiate__wst__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__SignChallenge:
		return (void*)soap_instantiate__wst__SignChallenge(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__SignChallengeResponse:
		return (void*)soap_instantiate__wst__SignChallengeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__BinaryExchange:
		return (void*)soap_instantiate__wst__BinaryExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__RequestKET:
		return (void*)soap_instantiate__wst__RequestKET(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__KeyExchangeToken:
		return (void*)soap_instantiate__wst__KeyExchangeToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Authenticator:
		return (void*)soap_instantiate__wst__Authenticator(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__OnBehalfOf:
		return (void*)soap_instantiate__wst__OnBehalfOf(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Issuer:
		return (void*)soap_instantiate__wst__Issuer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Encryption:
		return (void*)soap_instantiate__wst__Encryption(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__ProofEncryption:
		return (void*)soap_instantiate__wst__ProofEncryption(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__UseKey:
		return (void*)soap_instantiate__wst__UseKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__DelegateTo:
		return (void*)soap_instantiate__wst__DelegateTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wst__Participants:
		return (void*)soap_instantiate__wst__Participants(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE__tempuri__GetNamesOfMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMethods*>(p->ptr), _tempuri__GetNamesOfMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMethods*>(p->ptr), _tempuri__GetNamesOfMethods);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMethodsResponse*>(p->ptr), _tempuri__GetNamesOfMethodsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMethodsResponse*>(p->ptr), _tempuri__GetNamesOfMethodsResponse);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMethodsOfAssayType*>(p->ptr), _tempuri__GetNamesOfMethodsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMethodsOfAssayType*>(p->ptr), _tempuri__GetNamesOfMethodsOfAssayType);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMethodsOfAssayTypeResponse*>(p->ptr), _tempuri__GetNamesOfMethodsOfAssayTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMethodsOfAssayTypeResponse*>(p->ptr), _tempuri__GetNamesOfMethodsOfAssayTypeResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypesOfAllMethods*>(p->ptr), _tempuri__GetAssayTypesOfAllMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypesOfAllMethods*>(p->ptr), _tempuri__GetAssayTypesOfAllMethods);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypesOfAllMethodsResponse*>(p->ptr), _tempuri__GetAssayTypesOfAllMethodsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypesOfAllMethodsResponse*>(p->ptr), _tempuri__GetAssayTypesOfAllMethodsResponse);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNameOfCurrentMethod*>(p->ptr), _tempuri__GetNameOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNameOfCurrentMethod*>(p->ptr), _tempuri__GetNameOfCurrentMethod);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNameOfCurrentMethodResponse*>(p->ptr), _tempuri__GetNameOfCurrentMethodResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNameOfCurrentMethodResponse*>(p->ptr), _tempuri__GetNameOfCurrentMethodResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfCurrentMethod*>(p->ptr), _tempuri__GetAssayTypeOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfCurrentMethod*>(p->ptr), _tempuri__GetAssayTypeOfCurrentMethod);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfCurrentMethodResponse*>(p->ptr), _tempuri__GetAssayTypeOfCurrentMethodResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfCurrentMethodResponse*>(p->ptr), _tempuri__GetAssayTypeOfCurrentMethodResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfMethod*>(p->ptr), _tempuri__GetAssayTypeOfMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfMethod*>(p->ptr), _tempuri__GetAssayTypeOfMethod);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfMethodResponse*>(p->ptr), _tempuri__GetAssayTypeOfMethodResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfMethodResponse*>(p->ptr), _tempuri__GetAssayTypeOfMethodResponse);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfRunsets*>(p->ptr), _tempuri__GetNamesOfRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfRunsets*>(p->ptr), _tempuri__GetNamesOfRunsets);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfRunsetsResponse*>(p->ptr), _tempuri__GetNamesOfRunsetsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfRunsetsResponse*>(p->ptr), _tempuri__GetNamesOfRunsetsResponse);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfRunsetsOfAssayType*>(p->ptr), _tempuri__GetNamesOfRunsetsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfRunsetsOfAssayType*>(p->ptr), _tempuri__GetNamesOfRunsetsOfAssayType);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfRunsetsOfAssayTypeResponse*>(p->ptr), _tempuri__GetNamesOfRunsetsOfAssayTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfRunsetsOfAssayTypeResponse*>(p->ptr), _tempuri__GetNamesOfRunsetsOfAssayTypeResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypesOfAllRunsets*>(p->ptr), _tempuri__GetAssayTypesOfAllRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypesOfAllRunsets*>(p->ptr), _tempuri__GetAssayTypesOfAllRunsets);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypesOfAllRunsetsResponse*>(p->ptr), _tempuri__GetAssayTypesOfAllRunsetsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypesOfAllRunsetsResponse*>(p->ptr), _tempuri__GetAssayTypesOfAllRunsetsResponse);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNameOfCurrentRunset*>(p->ptr), _tempuri__GetNameOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNameOfCurrentRunset*>(p->ptr), _tempuri__GetNameOfCurrentRunset);
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNameOfCurrentRunsetResponse*>(p->ptr), _tempuri__GetNameOfCurrentRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNameOfCurrentRunsetResponse*>(p->ptr), _tempuri__GetNameOfCurrentRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfCurrentRunset*>(p->ptr), _tempuri__GetAssayTypeOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfCurrentRunset*>(p->ptr), _tempuri__GetAssayTypeOfCurrentRunset);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfCurrentRunsetResponse*>(p->ptr), _tempuri__GetAssayTypeOfCurrentRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfCurrentRunsetResponse*>(p->ptr), _tempuri__GetAssayTypeOfCurrentRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfRunset*>(p->ptr), _tempuri__GetAssayTypeOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfRunset*>(p->ptr), _tempuri__GetAssayTypeOfRunset);
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetAssayTypeOfRunsetResponse*>(p->ptr), _tempuri__GetAssayTypeOfRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetAssayTypeOfRunsetResponse*>(p->ptr), _tempuri__GetAssayTypeOfRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetMethodNamesOfRunset*>(p->ptr), _tempuri__GetMethodNamesOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetMethodNamesOfRunset*>(p->ptr), _tempuri__GetMethodNamesOfRunset);
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetMethodNamesOfRunsetResponse*>(p->ptr), _tempuri__GetMethodNamesOfRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetMethodNamesOfRunsetResponse*>(p->ptr), _tempuri__GetMethodNamesOfRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__SelectMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SelectMethod*>(p->ptr), _tempuri__SelectMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SelectMethod*>(p->ptr), _tempuri__SelectMethod);
		break;
	case SOAP_TYPE__tempuri__SelectMethodResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SelectMethodResponse*>(p->ptr), _tempuri__SelectMethodResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SelectMethodResponse*>(p->ptr), _tempuri__SelectMethodResponse);
		break;
	case SOAP_TYPE__tempuri__SelectRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SelectRunset*>(p->ptr), _tempuri__SelectRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SelectRunset*>(p->ptr), _tempuri__SelectRunset);
		break;
	case SOAP_TYPE__tempuri__SelectRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SelectRunsetResponse*>(p->ptr), _tempuri__SelectRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SelectRunsetResponse*>(p->ptr), _tempuri__SelectRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__CreateRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__CreateRunset*>(p->ptr), _tempuri__CreateRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__CreateRunset*>(p->ptr), _tempuri__CreateRunset);
		break;
	case SOAP_TYPE__tempuri__CreateRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__CreateRunsetResponse*>(p->ptr), _tempuri__CreateRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__CreateRunsetResponse*>(p->ptr), _tempuri__CreateRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SetSamplePlateId*>(p->ptr), _tempuri__SetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SetSamplePlateId*>(p->ptr), _tempuri__SetSamplePlateId);
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SetSamplePlateIdResponse*>(p->ptr), _tempuri__SetSamplePlateIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SetSamplePlateIdResponse*>(p->ptr), _tempuri__SetSamplePlateIdResponse);
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetSamplePlateId*>(p->ptr), _tempuri__GetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetSamplePlateId*>(p->ptr), _tempuri__GetSamplePlateId);
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetSamplePlateIdResponse*>(p->ptr), _tempuri__GetSamplePlateIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetSamplePlateIdResponse*>(p->ptr), _tempuri__GetSamplePlateIdResponse);
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetCurrentSamplePlateId*>(p->ptr), _tempuri__GetCurrentSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetCurrentSamplePlateId*>(p->ptr), _tempuri__GetCurrentSamplePlateId);
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetCurrentSamplePlateIdResponse*>(p->ptr), _tempuri__GetCurrentSamplePlateIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetCurrentSamplePlateIdResponse*>(p->ptr), _tempuri__GetCurrentSamplePlateIdResponse);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOut:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__MoveSamplePlateTrayOut*>(p->ptr), _tempuri__MoveSamplePlateTrayOut);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__MoveSamplePlateTrayOut*>(p->ptr), _tempuri__MoveSamplePlateTrayOut);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__MoveSamplePlateTrayOutResponse*>(p->ptr), _tempuri__MoveSamplePlateTrayOutResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__MoveSamplePlateTrayOutResponse*>(p->ptr), _tempuri__MoveSamplePlateTrayOutResponse);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__MoveSamplePlateTrayIn*>(p->ptr), _tempuri__MoveSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__MoveSamplePlateTrayIn*>(p->ptr), _tempuri__MoveSamplePlateTrayIn);
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__MoveSamplePlateTrayInResponse*>(p->ptr), _tempuri__MoveSamplePlateTrayInResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__MoveSamplePlateTrayInResponse*>(p->ptr), _tempuri__MoveSamplePlateTrayInResponse);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__StartSelectedRunset*>(p->ptr), _tempuri__StartSelectedRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__StartSelectedRunset*>(p->ptr), _tempuri__StartSelectedRunset);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__StartSelectedRunsetResponse*>(p->ptr), _tempuri__StartSelectedRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__StartSelectedRunsetResponse*>(p->ptr), _tempuri__StartSelectedRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFrom:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__StartSelectedRunsetFrom*>(p->ptr), _tempuri__StartSelectedRunsetFrom);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__StartSelectedRunsetFrom*>(p->ptr), _tempuri__StartSelectedRunsetFrom);
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__StartSelectedRunsetFromResponse*>(p->ptr), _tempuri__StartSelectedRunsetFromResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__StartSelectedRunsetFromResponse*>(p->ptr), _tempuri__StartSelectedRunsetFromResponse);
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__PauseRunsetAfter*>(p->ptr), _tempuri__PauseRunsetAfter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__PauseRunsetAfter*>(p->ptr), _tempuri__PauseRunsetAfter);
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__PauseRunsetAfterResponse*>(p->ptr), _tempuri__PauseRunsetAfterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__PauseRunsetAfterResponse*>(p->ptr), _tempuri__PauseRunsetAfterResponse);
		break;
	case SOAP_TYPE__tempuri__ResumeRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ResumeRunset*>(p->ptr), _tempuri__ResumeRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ResumeRunset*>(p->ptr), _tempuri__ResumeRunset);
		break;
	case SOAP_TYPE__tempuri__ResumeRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ResumeRunsetResponse*>(p->ptr), _tempuri__ResumeRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ResumeRunsetResponse*>(p->ptr), _tempuri__ResumeRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__ResetRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ResetRunset*>(p->ptr), _tempuri__ResetRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ResetRunset*>(p->ptr), _tempuri__ResetRunset);
		break;
	case SOAP_TYPE__tempuri__ResetRunsetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ResetRunsetResponse*>(p->ptr), _tempuri__ResetRunsetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ResetRunsetResponse*>(p->ptr), _tempuri__ResetRunsetResponse);
		break;
	case SOAP_TYPE__tempuri__AbortScript:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AbortScript*>(p->ptr), _tempuri__AbortScript);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AbortScript*>(p->ptr), _tempuri__AbortScript);
		break;
	case SOAP_TYPE__tempuri__AbortScriptResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AbortScriptResponse*>(p->ptr), _tempuri__AbortScriptResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AbortScriptResponse*>(p->ptr), _tempuri__AbortScriptResponse);
		break;
	case SOAP_TYPE__tempuri__LeaveStandby:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LeaveStandby*>(p->ptr), _tempuri__LeaveStandby);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LeaveStandby*>(p->ptr), _tempuri__LeaveStandby);
		break;
	case SOAP_TYPE__tempuri__LeaveStandbyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LeaveStandbyResponse*>(p->ptr), _tempuri__LeaveStandbyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LeaveStandbyResponse*>(p->ptr), _tempuri__LeaveStandbyResponse);
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SetStandbyAfterFinish*>(p->ptr), _tempuri__SetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SetStandbyAfterFinish*>(p->ptr), _tempuri__SetStandbyAfterFinish);
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__SetStandbyAfterFinishResponse*>(p->ptr), _tempuri__SetStandbyAfterFinishResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__SetStandbyAfterFinishResponse*>(p->ptr), _tempuri__SetStandbyAfterFinishResponse);
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetStandbyAfterFinish*>(p->ptr), _tempuri__GetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetStandbyAfterFinish*>(p->ptr), _tempuri__GetStandbyAfterFinish);
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetStandbyAfterFinishResponse*>(p->ptr), _tempuri__GetStandbyAfterFinishResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetStandbyAfterFinishResponse*>(p->ptr), _tempuri__GetStandbyAfterFinishResponse);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMaintenanceProcedures*>(p->ptr), _tempuri__GetNamesOfMaintenanceProcedures);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMaintenanceProcedures*>(p->ptr), _tempuri__GetNamesOfMaintenanceProcedures);
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetNamesOfMaintenanceProceduresResponse*>(p->ptr), _tempuri__GetNamesOfMaintenanceProceduresResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetNamesOfMaintenanceProceduresResponse*>(p->ptr), _tempuri__GetNamesOfMaintenanceProceduresResponse);
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__RunMaintenanceProcedure*>(p->ptr), _tempuri__RunMaintenanceProcedure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__RunMaintenanceProcedure*>(p->ptr), _tempuri__RunMaintenanceProcedure);
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__RunMaintenanceProcedureResponse*>(p->ptr), _tempuri__RunMaintenanceProcedureResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__RunMaintenanceProcedureResponse*>(p->ptr), _tempuri__RunMaintenanceProcedureResponse);
		break;
	case SOAP_TYPE__tempuri__GetOperationMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetOperationMode*>(p->ptr), _tempuri__GetOperationMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetOperationMode*>(p->ptr), _tempuri__GetOperationMode);
		break;
	case SOAP_TYPE__tempuri__GetOperationModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetOperationModeResponse*>(p->ptr), _tempuri__GetOperationModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetOperationModeResponse*>(p->ptr), _tempuri__GetOperationModeResponse);
		break;
	case SOAP_TYPE__tempuri__IsChipDocked:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__IsChipDocked*>(p->ptr), _tempuri__IsChipDocked);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__IsChipDocked*>(p->ptr), _tempuri__IsChipDocked);
		break;
	case SOAP_TYPE__tempuri__IsChipDockedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__IsChipDockedResponse*>(p->ptr), _tempuri__IsChipDockedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__IsChipDockedResponse*>(p->ptr), _tempuri__IsChipDockedResponse);
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__IsSamplePlateTrayIn*>(p->ptr), _tempuri__IsSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__IsSamplePlateTrayIn*>(p->ptr), _tempuri__IsSamplePlateTrayIn);
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__IsSamplePlateTrayInResponse*>(p->ptr), _tempuri__IsSamplePlateTrayInResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__IsSamplePlateTrayInResponse*>(p->ptr), _tempuri__IsSamplePlateTrayInResponse);
		break;
	case SOAP_TYPE__tempuri__HasMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasMessage*>(p->ptr), _tempuri__HasMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasMessage*>(p->ptr), _tempuri__HasMessage);
		break;
	case SOAP_TYPE__tempuri__HasMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasMessageResponse*>(p->ptr), _tempuri__HasMessageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasMessageResponse*>(p->ptr), _tempuri__HasMessageResponse);
		break;
	case SOAP_TYPE__tempuri__GetMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetMessage*>(p->ptr), _tempuri__GetMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetMessage*>(p->ptr), _tempuri__GetMessage);
		break;
	case SOAP_TYPE__tempuri__GetMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetMessageResponse*>(p->ptr), _tempuri__GetMessageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetMessageResponse*>(p->ptr), _tempuri__GetMessageResponse);
		break;
	case SOAP_TYPE__tempuri__HasErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasErrors*>(p->ptr), _tempuri__HasErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasErrors*>(p->ptr), _tempuri__HasErrors);
		break;
	case SOAP_TYPE__tempuri__HasErrorsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasErrorsResponse*>(p->ptr), _tempuri__HasErrorsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasErrorsResponse*>(p->ptr), _tempuri__HasErrorsResponse);
		break;
	case SOAP_TYPE__tempuri__GetErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetErrors*>(p->ptr), _tempuri__GetErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetErrors*>(p->ptr), _tempuri__GetErrors);
		break;
	case SOAP_TYPE__tempuri__GetErrorsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetErrorsResponse*>(p->ptr), _tempuri__GetErrorsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetErrorsResponse*>(p->ptr), _tempuri__GetErrorsResponse);
		break;
	case SOAP_TYPE__tempuri__HasWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasWarnings*>(p->ptr), _tempuri__HasWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasWarnings*>(p->ptr), _tempuri__HasWarnings);
		break;
	case SOAP_TYPE__tempuri__HasWarningsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__HasWarningsResponse*>(p->ptr), _tempuri__HasWarningsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__HasWarningsResponse*>(p->ptr), _tempuri__HasWarningsResponse);
		break;
	case SOAP_TYPE__tempuri__GetWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetWarnings*>(p->ptr), _tempuri__GetWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetWarnings*>(p->ptr), _tempuri__GetWarnings);
		break;
	case SOAP_TYPE__tempuri__GetWarningsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetWarningsResponse*>(p->ptr), _tempuri__GetWarningsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetWarningsResponse*>(p->ptr), _tempuri__GetWarningsResponse);
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<arr__ArrayOfstring*>(p->ptr), arr__ArrayOfstring);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<arr__ArrayOfstring*>(p->ptr), arr__ArrayOfstring);
		break;
	case SOAP_TYPE___name__GetNamesOfMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNamesOfMethods*>(p->ptr), struct __name__GetNamesOfMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNamesOfMethods*>(p->ptr), struct __name__GetNamesOfMethods);
		break;
	case SOAP_TYPE___name__GetNamesOfMethodsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNamesOfMethodsOfAssayType*>(p->ptr), struct __name__GetNamesOfMethodsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNamesOfMethodsOfAssayType*>(p->ptr), struct __name__GetNamesOfMethodsOfAssayType);
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypesOfAllMethods*>(p->ptr), struct __name__GetAssayTypesOfAllMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypesOfAllMethods*>(p->ptr), struct __name__GetAssayTypesOfAllMethods);
		break;
	case SOAP_TYPE___name__GetNameOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNameOfCurrentMethod*>(p->ptr), struct __name__GetNameOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNameOfCurrentMethod*>(p->ptr), struct __name__GetNameOfCurrentMethod);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypeOfCurrentMethod*>(p->ptr), struct __name__GetAssayTypeOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypeOfCurrentMethod*>(p->ptr), struct __name__GetAssayTypeOfCurrentMethod);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypeOfMethod*>(p->ptr), struct __name__GetAssayTypeOfMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypeOfMethod*>(p->ptr), struct __name__GetAssayTypeOfMethod);
		break;
	case SOAP_TYPE___name__GetNamesOfRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNamesOfRunsets*>(p->ptr), struct __name__GetNamesOfRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNamesOfRunsets*>(p->ptr), struct __name__GetNamesOfRunsets);
		break;
	case SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNamesOfRunsetsOfAssayType*>(p->ptr), struct __name__GetNamesOfRunsetsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNamesOfRunsetsOfAssayType*>(p->ptr), struct __name__GetNamesOfRunsetsOfAssayType);
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypesOfAllRunsets*>(p->ptr), struct __name__GetAssayTypesOfAllRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypesOfAllRunsets*>(p->ptr), struct __name__GetAssayTypesOfAllRunsets);
		break;
	case SOAP_TYPE___name__GetNameOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNameOfCurrentRunset*>(p->ptr), struct __name__GetNameOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNameOfCurrentRunset*>(p->ptr), struct __name__GetNameOfCurrentRunset);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypeOfCurrentRunset*>(p->ptr), struct __name__GetAssayTypeOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypeOfCurrentRunset*>(p->ptr), struct __name__GetAssayTypeOfCurrentRunset);
		break;
	case SOAP_TYPE___name__GetAssayTypeOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetAssayTypeOfRunset*>(p->ptr), struct __name__GetAssayTypeOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetAssayTypeOfRunset*>(p->ptr), struct __name__GetAssayTypeOfRunset);
		break;
	case SOAP_TYPE___name__GetMethodNamesOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetMethodNamesOfRunset*>(p->ptr), struct __name__GetMethodNamesOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetMethodNamesOfRunset*>(p->ptr), struct __name__GetMethodNamesOfRunset);
		break;
	case SOAP_TYPE___name__SelectMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__SelectMethod*>(p->ptr), struct __name__SelectMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__SelectMethod*>(p->ptr), struct __name__SelectMethod);
		break;
	case SOAP_TYPE___name__SelectRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__SelectRunset*>(p->ptr), struct __name__SelectRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__SelectRunset*>(p->ptr), struct __name__SelectRunset);
		break;
	case SOAP_TYPE___name__CreateRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__CreateRunset*>(p->ptr), struct __name__CreateRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__CreateRunset*>(p->ptr), struct __name__CreateRunset);
		break;
	case SOAP_TYPE___name__SetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__SetSamplePlateId*>(p->ptr), struct __name__SetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__SetSamplePlateId*>(p->ptr), struct __name__SetSamplePlateId);
		break;
	case SOAP_TYPE___name__GetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetSamplePlateId*>(p->ptr), struct __name__GetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetSamplePlateId*>(p->ptr), struct __name__GetSamplePlateId);
		break;
	case SOAP_TYPE___name__GetCurrentSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetCurrentSamplePlateId*>(p->ptr), struct __name__GetCurrentSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetCurrentSamplePlateId*>(p->ptr), struct __name__GetCurrentSamplePlateId);
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayOut:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__MoveSamplePlateTrayOut*>(p->ptr), struct __name__MoveSamplePlateTrayOut);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__MoveSamplePlateTrayOut*>(p->ptr), struct __name__MoveSamplePlateTrayOut);
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__MoveSamplePlateTrayIn*>(p->ptr), struct __name__MoveSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__MoveSamplePlateTrayIn*>(p->ptr), struct __name__MoveSamplePlateTrayIn);
		break;
	case SOAP_TYPE___name__StartSelectedRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__StartSelectedRunset*>(p->ptr), struct __name__StartSelectedRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__StartSelectedRunset*>(p->ptr), struct __name__StartSelectedRunset);
		break;
	case SOAP_TYPE___name__StartSelectedRunsetFrom:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__StartSelectedRunsetFrom*>(p->ptr), struct __name__StartSelectedRunsetFrom);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__StartSelectedRunsetFrom*>(p->ptr), struct __name__StartSelectedRunsetFrom);
		break;
	case SOAP_TYPE___name__PauseRunsetAfter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__PauseRunsetAfter*>(p->ptr), struct __name__PauseRunsetAfter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__PauseRunsetAfter*>(p->ptr), struct __name__PauseRunsetAfter);
		break;
	case SOAP_TYPE___name__ResumeRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__ResumeRunset*>(p->ptr), struct __name__ResumeRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__ResumeRunset*>(p->ptr), struct __name__ResumeRunset);
		break;
	case SOAP_TYPE___name__ResetRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__ResetRunset*>(p->ptr), struct __name__ResetRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__ResetRunset*>(p->ptr), struct __name__ResetRunset);
		break;
	case SOAP_TYPE___name__AbortScript:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__AbortScript*>(p->ptr), struct __name__AbortScript);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__AbortScript*>(p->ptr), struct __name__AbortScript);
		break;
	case SOAP_TYPE___name__LeaveStandby:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__LeaveStandby*>(p->ptr), struct __name__LeaveStandby);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__LeaveStandby*>(p->ptr), struct __name__LeaveStandby);
		break;
	case SOAP_TYPE___name__SetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__SetStandbyAfterFinish*>(p->ptr), struct __name__SetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__SetStandbyAfterFinish*>(p->ptr), struct __name__SetStandbyAfterFinish);
		break;
	case SOAP_TYPE___name__GetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetStandbyAfterFinish*>(p->ptr), struct __name__GetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetStandbyAfterFinish*>(p->ptr), struct __name__GetStandbyAfterFinish);
		break;
	case SOAP_TYPE___name__GetNamesOfMaintenanceProcedures:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetNamesOfMaintenanceProcedures*>(p->ptr), struct __name__GetNamesOfMaintenanceProcedures);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetNamesOfMaintenanceProcedures*>(p->ptr), struct __name__GetNamesOfMaintenanceProcedures);
		break;
	case SOAP_TYPE___name__RunMaintenanceProcedure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__RunMaintenanceProcedure*>(p->ptr), struct __name__RunMaintenanceProcedure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__RunMaintenanceProcedure*>(p->ptr), struct __name__RunMaintenanceProcedure);
		break;
	case SOAP_TYPE___name__GetOperationMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetOperationMode*>(p->ptr), struct __name__GetOperationMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetOperationMode*>(p->ptr), struct __name__GetOperationMode);
		break;
	case SOAP_TYPE___name__IsChipDocked:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__IsChipDocked*>(p->ptr), struct __name__IsChipDocked);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__IsChipDocked*>(p->ptr), struct __name__IsChipDocked);
		break;
	case SOAP_TYPE___name__IsSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__IsSamplePlateTrayIn*>(p->ptr), struct __name__IsSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__IsSamplePlateTrayIn*>(p->ptr), struct __name__IsSamplePlateTrayIn);
		break;
	case SOAP_TYPE___name__HasMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__HasMessage*>(p->ptr), struct __name__HasMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__HasMessage*>(p->ptr), struct __name__HasMessage);
		break;
	case SOAP_TYPE___name__GetMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetMessage*>(p->ptr), struct __name__GetMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetMessage*>(p->ptr), struct __name__GetMessage);
		break;
	case SOAP_TYPE___name__HasErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__HasErrors*>(p->ptr), struct __name__HasErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__HasErrors*>(p->ptr), struct __name__HasErrors);
		break;
	case SOAP_TYPE___name__GetErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetErrors*>(p->ptr), struct __name__GetErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetErrors*>(p->ptr), struct __name__GetErrors);
		break;
	case SOAP_TYPE___name__HasWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__HasWarnings*>(p->ptr), struct __name__HasWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__HasWarnings*>(p->ptr), struct __name__HasWarnings);
		break;
	case SOAP_TYPE___name__GetWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name__GetWarnings*>(p->ptr), struct __name__GetWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name__GetWarnings*>(p->ptr), struct __name__GetWarnings);
		break;
	case SOAP_TYPE___name2__GetNamesOfMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNamesOfMethods*>(p->ptr), struct __name2__GetNamesOfMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNamesOfMethods*>(p->ptr), struct __name2__GetNamesOfMethods);
		break;
	case SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNamesOfMethodsOfAssayType*>(p->ptr), struct __name2__GetNamesOfMethodsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNamesOfMethodsOfAssayType*>(p->ptr), struct __name2__GetNamesOfMethodsOfAssayType);
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllMethods:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypesOfAllMethods*>(p->ptr), struct __name2__GetAssayTypesOfAllMethods);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypesOfAllMethods*>(p->ptr), struct __name2__GetAssayTypesOfAllMethods);
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNameOfCurrentMethod*>(p->ptr), struct __name2__GetNameOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNameOfCurrentMethod*>(p->ptr), struct __name2__GetNameOfCurrentMethod);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypeOfCurrentMethod*>(p->ptr), struct __name2__GetAssayTypeOfCurrentMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypeOfCurrentMethod*>(p->ptr), struct __name2__GetAssayTypeOfCurrentMethod);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypeOfMethod*>(p->ptr), struct __name2__GetAssayTypeOfMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypeOfMethod*>(p->ptr), struct __name2__GetAssayTypeOfMethod);
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNamesOfRunsets*>(p->ptr), struct __name2__GetNamesOfRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNamesOfRunsets*>(p->ptr), struct __name2__GetNamesOfRunsets);
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNamesOfRunsetsOfAssayType*>(p->ptr), struct __name2__GetNamesOfRunsetsOfAssayType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNamesOfRunsetsOfAssayType*>(p->ptr), struct __name2__GetNamesOfRunsetsOfAssayType);
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllRunsets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypesOfAllRunsets*>(p->ptr), struct __name2__GetAssayTypesOfAllRunsets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypesOfAllRunsets*>(p->ptr), struct __name2__GetAssayTypesOfAllRunsets);
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNameOfCurrentRunset*>(p->ptr), struct __name2__GetNameOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNameOfCurrentRunset*>(p->ptr), struct __name2__GetNameOfCurrentRunset);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypeOfCurrentRunset*>(p->ptr), struct __name2__GetAssayTypeOfCurrentRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypeOfCurrentRunset*>(p->ptr), struct __name2__GetAssayTypeOfCurrentRunset);
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetAssayTypeOfRunset*>(p->ptr), struct __name2__GetAssayTypeOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetAssayTypeOfRunset*>(p->ptr), struct __name2__GetAssayTypeOfRunset);
		break;
	case SOAP_TYPE___name2__GetMethodNamesOfRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetMethodNamesOfRunset*>(p->ptr), struct __name2__GetMethodNamesOfRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetMethodNamesOfRunset*>(p->ptr), struct __name2__GetMethodNamesOfRunset);
		break;
	case SOAP_TYPE___name2__SelectMethod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__SelectMethod*>(p->ptr), struct __name2__SelectMethod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__SelectMethod*>(p->ptr), struct __name2__SelectMethod);
		break;
	case SOAP_TYPE___name2__SelectRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__SelectRunset*>(p->ptr), struct __name2__SelectRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__SelectRunset*>(p->ptr), struct __name2__SelectRunset);
		break;
	case SOAP_TYPE___name2__CreateRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__CreateRunset*>(p->ptr), struct __name2__CreateRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__CreateRunset*>(p->ptr), struct __name2__CreateRunset);
		break;
	case SOAP_TYPE___name2__SetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__SetSamplePlateId*>(p->ptr), struct __name2__SetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__SetSamplePlateId*>(p->ptr), struct __name2__SetSamplePlateId);
		break;
	case SOAP_TYPE___name2__GetSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetSamplePlateId*>(p->ptr), struct __name2__GetSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetSamplePlateId*>(p->ptr), struct __name2__GetSamplePlateId);
		break;
	case SOAP_TYPE___name2__GetCurrentSamplePlateId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetCurrentSamplePlateId*>(p->ptr), struct __name2__GetCurrentSamplePlateId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetCurrentSamplePlateId*>(p->ptr), struct __name2__GetCurrentSamplePlateId);
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayOut:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__MoveSamplePlateTrayOut*>(p->ptr), struct __name2__MoveSamplePlateTrayOut);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__MoveSamplePlateTrayOut*>(p->ptr), struct __name2__MoveSamplePlateTrayOut);
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__MoveSamplePlateTrayIn*>(p->ptr), struct __name2__MoveSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__MoveSamplePlateTrayIn*>(p->ptr), struct __name2__MoveSamplePlateTrayIn);
		break;
	case SOAP_TYPE___name2__StartSelectedRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__StartSelectedRunset*>(p->ptr), struct __name2__StartSelectedRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__StartSelectedRunset*>(p->ptr), struct __name2__StartSelectedRunset);
		break;
	case SOAP_TYPE___name2__StartSelectedRunsetFrom:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__StartSelectedRunsetFrom*>(p->ptr), struct __name2__StartSelectedRunsetFrom);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__StartSelectedRunsetFrom*>(p->ptr), struct __name2__StartSelectedRunsetFrom);
		break;
	case SOAP_TYPE___name2__PauseRunsetAfter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__PauseRunsetAfter*>(p->ptr), struct __name2__PauseRunsetAfter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__PauseRunsetAfter*>(p->ptr), struct __name2__PauseRunsetAfter);
		break;
	case SOAP_TYPE___name2__ResumeRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__ResumeRunset*>(p->ptr), struct __name2__ResumeRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__ResumeRunset*>(p->ptr), struct __name2__ResumeRunset);
		break;
	case SOAP_TYPE___name2__ResetRunset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__ResetRunset*>(p->ptr), struct __name2__ResetRunset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__ResetRunset*>(p->ptr), struct __name2__ResetRunset);
		break;
	case SOAP_TYPE___name2__AbortScript:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__AbortScript*>(p->ptr), struct __name2__AbortScript);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__AbortScript*>(p->ptr), struct __name2__AbortScript);
		break;
	case SOAP_TYPE___name2__LeaveStandby:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__LeaveStandby*>(p->ptr), struct __name2__LeaveStandby);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__LeaveStandby*>(p->ptr), struct __name2__LeaveStandby);
		break;
	case SOAP_TYPE___name2__SetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__SetStandbyAfterFinish*>(p->ptr), struct __name2__SetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__SetStandbyAfterFinish*>(p->ptr), struct __name2__SetStandbyAfterFinish);
		break;
	case SOAP_TYPE___name2__GetStandbyAfterFinish:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetStandbyAfterFinish*>(p->ptr), struct __name2__GetStandbyAfterFinish);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetStandbyAfterFinish*>(p->ptr), struct __name2__GetStandbyAfterFinish);
		break;
	case SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetNamesOfMaintenanceProcedures*>(p->ptr), struct __name2__GetNamesOfMaintenanceProcedures);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetNamesOfMaintenanceProcedures*>(p->ptr), struct __name2__GetNamesOfMaintenanceProcedures);
		break;
	case SOAP_TYPE___name2__RunMaintenanceProcedure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__RunMaintenanceProcedure*>(p->ptr), struct __name2__RunMaintenanceProcedure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__RunMaintenanceProcedure*>(p->ptr), struct __name2__RunMaintenanceProcedure);
		break;
	case SOAP_TYPE___name2__GetOperationMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetOperationMode*>(p->ptr), struct __name2__GetOperationMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetOperationMode*>(p->ptr), struct __name2__GetOperationMode);
		break;
	case SOAP_TYPE___name2__IsChipDocked:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__IsChipDocked*>(p->ptr), struct __name2__IsChipDocked);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__IsChipDocked*>(p->ptr), struct __name2__IsChipDocked);
		break;
	case SOAP_TYPE___name2__IsSamplePlateTrayIn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__IsSamplePlateTrayIn*>(p->ptr), struct __name2__IsSamplePlateTrayIn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__IsSamplePlateTrayIn*>(p->ptr), struct __name2__IsSamplePlateTrayIn);
		break;
	case SOAP_TYPE___name2__HasMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__HasMessage*>(p->ptr), struct __name2__HasMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__HasMessage*>(p->ptr), struct __name2__HasMessage);
		break;
	case SOAP_TYPE___name2__GetMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetMessage*>(p->ptr), struct __name2__GetMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetMessage*>(p->ptr), struct __name2__GetMessage);
		break;
	case SOAP_TYPE___name2__HasErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__HasErrors*>(p->ptr), struct __name2__HasErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__HasErrors*>(p->ptr), struct __name2__HasErrors);
		break;
	case SOAP_TYPE___name2__GetErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetErrors*>(p->ptr), struct __name2__GetErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetErrors*>(p->ptr), struct __name2__GetErrors);
		break;
	case SOAP_TYPE___name2__HasWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__HasWarnings*>(p->ptr), struct __name2__HasWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__HasWarnings*>(p->ptr), struct __name2__HasWarnings);
		break;
	case SOAP_TYPE___name2__GetWarnings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __name2__GetWarnings*>(p->ptr), struct __name2__GetWarnings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __name2__GetWarnings*>(p->ptr), struct __name2__GetWarnings);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsu__Timestamp*>(p->ptr), struct _wsu__Timestamp);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsu__Timestamp*>(p->ptr), struct _wsu__Timestamp);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsse__EncodedString*>(p->ptr), struct wsse__EncodedString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsse__EncodedString*>(p->ptr), struct wsse__EncodedString);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__UsernameToken*>(p->ptr), struct _wsse__UsernameToken);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__UsernameToken*>(p->ptr), struct _wsse__UsernameToken);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__BinarySecurityToken*>(p->ptr), struct _wsse__BinarySecurityToken);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__BinarySecurityToken*>(p->ptr), struct _wsse__BinarySecurityToken);
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Reference*>(p->ptr), struct _wsse__Reference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Reference*>(p->ptr), struct _wsse__Reference);
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Embedded*>(p->ptr), struct _wsse__Embedded);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Embedded*>(p->ptr), struct _wsse__Embedded);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__KeyIdentifier*>(p->ptr), struct _wsse__KeyIdentifier);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__KeyIdentifier*>(p->ptr), struct _wsse__KeyIdentifier);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__SecurityTokenReference*>(p->ptr), struct _wsse__SecurityTokenReference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__SecurityTokenReference*>(p->ptr), struct _wsse__SecurityTokenReference);
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr), struct _c14n__InclusiveNamespaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr), struct _c14n__InclusiveNamespaces);
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignedInfoType*>(p->ptr), struct ds__SignedInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignedInfoType*>(p->ptr), struct ds__SignedInfoType);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__CanonicalizationMethodType*>(p->ptr), struct ds__CanonicalizationMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__CanonicalizationMethodType*>(p->ptr), struct ds__CanonicalizationMethodType);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureMethodType*>(p->ptr), struct ds__SignatureMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureMethodType*>(p->ptr), struct ds__SignatureMethodType);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__ReferenceType*>(p->ptr), struct ds__ReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__ReferenceType*>(p->ptr), struct ds__ReferenceType);
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformsType*>(p->ptr), struct ds__TransformsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformsType*>(p->ptr), struct ds__TransformsType);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__DigestMethodType*>(p->ptr), struct ds__DigestMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__DigestMethodType*>(p->ptr), struct ds__DigestMethodType);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyValueType*>(p->ptr), struct ds__KeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyValueType*>(p->ptr), struct ds__KeyValueType);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__RetrievalMethodType*>(p->ptr), struct ds__RetrievalMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__RetrievalMethodType*>(p->ptr), struct ds__RetrievalMethodType);
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__X509DataType*>(p->ptr), struct ds__X509DataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__X509DataType*>(p->ptr), struct ds__X509DataType);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__X509IssuerSerialType*>(p->ptr), struct ds__X509IssuerSerialType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__X509IssuerSerialType*>(p->ptr), struct ds__X509IssuerSerialType);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__DSAKeyValueType*>(p->ptr), struct ds__DSAKeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__DSAKeyValueType*>(p->ptr), struct ds__DSAKeyValueType);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__RSAKeyValueType*>(p->ptr), struct ds__RSAKeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__RSAKeyValueType*>(p->ptr), struct ds__RSAKeyValueType);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionPropertyType*>(p->ptr), struct xenc__EncryptionPropertyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionPropertyType*>(p->ptr), struct xenc__EncryptionPropertyType);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedType*>(p->ptr), struct xenc__EncryptedType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedType*>(p->ptr), struct xenc__EncryptedType);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionMethodType*>(p->ptr), struct xenc__EncryptionMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionMethodType*>(p->ptr), struct xenc__EncryptionMethodType);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__CipherDataType*>(p->ptr), struct xenc__CipherDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__CipherDataType*>(p->ptr), struct xenc__CipherDataType);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__CipherReferenceType*>(p->ptr), struct xenc__CipherReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__CipherReferenceType*>(p->ptr), struct xenc__CipherReferenceType);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__TransformsType*>(p->ptr), struct xenc__TransformsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__TransformsType*>(p->ptr), struct xenc__TransformsType);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__AgreementMethodType*>(p->ptr), struct xenc__AgreementMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__AgreementMethodType*>(p->ptr), struct xenc__AgreementMethodType);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__ReferenceType*>(p->ptr), struct xenc__ReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__ReferenceType*>(p->ptr), struct xenc__ReferenceType);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr), struct xenc__EncryptionPropertiesType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr), struct xenc__EncryptionPropertiesType);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __xenc__union_ReferenceList*>(p->ptr), struct __xenc__union_ReferenceList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __xenc__union_ReferenceList*>(p->ptr), struct __xenc__union_ReferenceList);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _xenc__ReferenceList*>(p->ptr), struct _xenc__ReferenceList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _xenc__ReferenceList*>(p->ptr), struct _xenc__ReferenceList);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedDataType*>(p->ptr), struct xenc__EncryptedDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedDataType*>(p->ptr), struct xenc__EncryptedDataType);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedKeyType*>(p->ptr), struct xenc__EncryptedKeyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedKeyType*>(p->ptr), struct xenc__EncryptedKeyType);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__SecurityContextTokenType*>(p->ptr), struct wsc__SecurityContextTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__SecurityContextTokenType*>(p->ptr), struct wsc__SecurityContextTokenType);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr), struct __wsc__DerivedKeyTokenType_sequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr), struct __wsc__DerivedKeyTokenType_sequence);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr), struct wsc__DerivedKeyTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr), struct wsc__DerivedKeyTokenType);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__PropertiesType*>(p->ptr), struct wsc__PropertiesType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__PropertiesType*>(p->ptr), struct wsc__PropertiesType);
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_AssertionType*>(p->ptr), struct __saml1__union_AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_AssertionType*>(p->ptr), struct __saml1__union_AssertionType);
		break;
	case SOAP_TYPE_saml1__AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_ConditionsType*>(p->ptr), struct __saml1__union_ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_ConditionsType*>(p->ptr), struct __saml1__union_ConditionsType);
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_AdviceType*>(p->ptr), struct __saml1__union_AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_AdviceType*>(p->ptr), struct __saml1__union_AdviceType);
		break;
	case SOAP_TYPE_saml1__AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		break;
	case SOAP_TYPE_saml1__SubjectType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_EvidenceType*>(p->ptr), struct __saml1__union_EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_EvidenceType*>(p->ptr), struct __saml1__union_EvidenceType);
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		break;
	case SOAP_TYPE_saml1__ActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		break;
	case SOAP_TYPE_saml1__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AssertionType*>(p->ptr), struct __saml2__union_AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AssertionType*>(p->ptr), struct __saml2__union_AssertionType);
		break;
	case SOAP_TYPE_saml2__AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		break;
	case SOAP_TYPE_saml2__SubjectType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_ConditionsType*>(p->ptr), struct __saml2__union_ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_ConditionsType*>(p->ptr), struct __saml2__union_ConditionsType);
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AdviceType*>(p->ptr), struct __saml2__union_AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AdviceType*>(p->ptr), struct __saml2__union_AdviceType);
		break;
	case SOAP_TYPE_saml2__AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_EvidenceType*>(p->ptr), struct __saml2__union_EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_EvidenceType*>(p->ptr), struct __saml2__union_EvidenceType);
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		break;
	case SOAP_TYPE_saml2__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		break;
	case SOAP_TYPE_saml2__NameIDType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		break;
	case SOAP_TYPE_saml2__ActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AttributeStatementType*>(p->ptr), struct __saml2__union_AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AttributeStatementType*>(p->ptr), struct __saml2__union_AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__KeyInfoConfirmationDataType*>(p->ptr), struct saml2__KeyInfoConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__KeyInfoConfirmationDataType*>(p->ptr), struct saml2__KeyInfoConfirmationDataType);
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Security*>(p->ptr), struct _wsse__Security);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Security*>(p->ptr), struct _wsse__Security);
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Password*>(p->ptr), struct _wsse__Password);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Password*>(p->ptr), struct _wsse__Password);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE__wsp__AppliesTo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsp__AppliesTo_*>(p->ptr), struct _wsp__AppliesTo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsp__AppliesTo_*>(p->ptr), struct _wsp__AppliesTo_);
		break;
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedSecurityTokenType*>(p->ptr), struct wst__RequestedSecurityTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedSecurityTokenType*>(p->ptr), struct wst__RequestedSecurityTokenType);
		break;
	case SOAP_TYPE_wst__EntropyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__EntropyType*>(p->ptr), struct wst__EntropyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__EntropyType*>(p->ptr), struct wst__EntropyType);
		break;
	case SOAP_TYPE_wst__AuthenticatorType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__AuthenticatorType*>(p->ptr), struct wst__AuthenticatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__AuthenticatorType*>(p->ptr), struct wst__AuthenticatorType);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenType*>(p->ptr), struct wst__RequestSecurityTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenType*>(p->ptr), struct wst__RequestSecurityTokenType);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenResponseType*>(p->ptr), struct wst__RequestSecurityTokenResponseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenResponseType*>(p->ptr), struct wst__RequestSecurityTokenResponseType);
		break;
	case SOAP_TYPE_wst__ClaimsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ClaimsType*>(p->ptr), struct wst__ClaimsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ClaimsType*>(p->ptr), struct wst__ClaimsType);
		break;
	case SOAP_TYPE_wst__LifetimeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__LifetimeType*>(p->ptr), struct wst__LifetimeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__LifetimeType*>(p->ptr), struct wst__LifetimeType);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenCollectionType*>(p->ptr), struct wst__RequestSecurityTokenCollectionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenCollectionType*>(p->ptr), struct wst__RequestSecurityTokenCollectionType);
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		break;
	case SOAP_TYPE_wst__RequestedReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		break;
	case SOAP_TYPE_wst__RequestedProofTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedProofTokenType*>(p->ptr), struct wst__RequestedProofTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedProofTokenType*>(p->ptr), struct wst__RequestedProofTokenType);
		break;
	case SOAP_TYPE_wst__RenewTargetType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RenewTargetType*>(p->ptr), struct wst__RenewTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RenewTargetType*>(p->ptr), struct wst__RenewTargetType);
		break;
	case SOAP_TYPE_wst__AllowPostdatingType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__AllowPostdatingType*>(p->ptr), struct wst__AllowPostdatingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__AllowPostdatingType*>(p->ptr), struct wst__AllowPostdatingType);
		break;
	case SOAP_TYPE_wst__RenewingType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RenewingType*>(p->ptr), struct wst__RenewingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RenewingType*>(p->ptr), struct wst__RenewingType);
		break;
	case SOAP_TYPE_wst__CancelTargetType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__CancelTargetType*>(p->ptr), struct wst__CancelTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__CancelTargetType*>(p->ptr), struct wst__CancelTargetType);
		break;
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedTokenCancelledType*>(p->ptr), struct wst__RequestedTokenCancelledType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedTokenCancelledType*>(p->ptr), struct wst__RequestedTokenCancelledType);
		break;
	case SOAP_TYPE_wst__ValidateTargetType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ValidateTargetType*>(p->ptr), struct wst__ValidateTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ValidateTargetType*>(p->ptr), struct wst__ValidateTargetType);
		break;
	case SOAP_TYPE_wst__StatusType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__StatusType*>(p->ptr), struct wst__StatusType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__StatusType*>(p->ptr), struct wst__StatusType);
		break;
	case SOAP_TYPE_wst__SignChallengeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		break;
	case SOAP_TYPE_wst__RequestKETType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestKETType*>(p->ptr), struct wst__RequestKETType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestKETType*>(p->ptr), struct wst__RequestKETType);
		break;
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__KeyExchangeTokenType*>(p->ptr), struct wst__KeyExchangeTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__KeyExchangeTokenType*>(p->ptr), struct wst__KeyExchangeTokenType);
		break;
	case SOAP_TYPE_wst__OnBehalfOfType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__OnBehalfOfType*>(p->ptr), struct wst__OnBehalfOfType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__OnBehalfOfType*>(p->ptr), struct wst__OnBehalfOfType);
		break;
	case SOAP_TYPE_wst__EncryptionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__EncryptionType*>(p->ptr), struct wst__EncryptionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__EncryptionType*>(p->ptr), struct wst__EncryptionType);
		break;
	case SOAP_TYPE_wst__ProofEncryptionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ProofEncryptionType*>(p->ptr), struct wst__ProofEncryptionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ProofEncryptionType*>(p->ptr), struct wst__ProofEncryptionType);
		break;
	case SOAP_TYPE_wst__UseKeyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__UseKeyType*>(p->ptr), struct wst__UseKeyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__UseKeyType*>(p->ptr), struct wst__UseKeyType);
		break;
	case SOAP_TYPE_wst__DelegateToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__DelegateToType*>(p->ptr), struct wst__DelegateToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__DelegateToType*>(p->ptr), struct wst__DelegateToType);
		break;
	case SOAP_TYPE_wst__ParticipantsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ParticipantsType*>(p->ptr), struct wst__ParticipantsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ParticipantsType*>(p->ptr), struct wst__ParticipantsType);
		break;
	case SOAP_TYPE_wst__ParticipantType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ParticipantType*>(p->ptr), struct wst__ParticipantType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ParticipantType*>(p->ptr), struct wst__ParticipantType);
		break;
	case SOAP_TYPE_wst__BinarySecretType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__BinarySecretType*>(p->ptr), struct wst__BinarySecretType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__BinarySecretType*>(p->ptr), struct wst__BinarySecretType);
		break;
	case SOAP_TYPE_wst__BinaryExchangeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__BinaryExchangeType*>(p->ptr), struct wst__BinaryExchangeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__BinaryExchangeType*>(p->ptr), struct wst__BinaryExchangeType);
		break;
	case SOAP_TYPE___wst__RequestSecurityToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wst__RequestSecurityToken*>(p->ptr), struct __wst__RequestSecurityToken);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wst__RequestSecurityToken*>(p->ptr), struct __wst__RequestSecurityToken);
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wst__RequestSecurityTokenResponse*>(p->ptr), struct __wst__RequestSecurityTokenResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wst__RequestSecurityTokenResponse*>(p->ptr), struct __wst__RequestSecurityTokenResponse);
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenCollection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wst__RequestSecurityTokenCollection*>(p->ptr), struct __wst__RequestSecurityTokenCollection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wst__RequestSecurityTokenCollection*>(p->ptr), struct __wst__RequestSecurityTokenCollection);
		break;
	case SOAP_TYPE_wsrm__SequenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__SequenceType*>(p->ptr), struct wsrm__SequenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__SequenceType*>(p->ptr), struct wsrm__SequenceType);
		break;
	case SOAP_TYPE_wsrm__AckRequestedType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__AckRequestedType*>(p->ptr), struct wsrm__AckRequestedType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__AckRequestedType*>(p->ptr), struct wsrm__AckRequestedType);
		break;
	case SOAP_TYPE_wsrm__SequenceFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__SequenceFaultType*>(p->ptr), struct wsrm__SequenceFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__SequenceFaultType*>(p->ptr), struct wsrm__SequenceFaultType);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__CreateSequenceType*>(p->ptr), struct wsrm__CreateSequenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__CreateSequenceType*>(p->ptr), struct wsrm__CreateSequenceType);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__CreateSequenceResponseType*>(p->ptr), struct wsrm__CreateSequenceResponseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__CreateSequenceResponseType*>(p->ptr), struct wsrm__CreateSequenceResponseType);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__CloseSequenceType*>(p->ptr), struct wsrm__CloseSequenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__CloseSequenceType*>(p->ptr), struct wsrm__CloseSequenceType);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__CloseSequenceResponseType*>(p->ptr), struct wsrm__CloseSequenceResponseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__CloseSequenceResponseType*>(p->ptr), struct wsrm__CloseSequenceResponseType);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__TerminateSequenceType*>(p->ptr), struct wsrm__TerminateSequenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__TerminateSequenceType*>(p->ptr), struct wsrm__TerminateSequenceType);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__TerminateSequenceResponseType*>(p->ptr), struct wsrm__TerminateSequenceResponseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__TerminateSequenceResponseType*>(p->ptr), struct wsrm__TerminateSequenceResponseType);
		break;
	case SOAP_TYPE_wsrm__OfferType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__OfferType*>(p->ptr), struct wsrm__OfferType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__OfferType*>(p->ptr), struct wsrm__OfferType);
		break;
	case SOAP_TYPE_wsrm__AcceptType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsrm__AcceptType*>(p->ptr), struct wsrm__AcceptType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsrm__AcceptType*>(p->ptr), struct wsrm__AcceptType);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__SequenceAcknowledgement_Final*>(p->ptr), struct _wsrm__SequenceAcknowledgement_Final);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__SequenceAcknowledgement_Final*>(p->ptr), struct _wsrm__SequenceAcknowledgement_Final);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*>(p->ptr), struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*>(p->ptr), struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__SequenceAcknowledgement_None*>(p->ptr), struct _wsrm__SequenceAcknowledgement_None);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__SequenceAcknowledgement_None*>(p->ptr), struct _wsrm__SequenceAcknowledgement_None);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__SequenceAcknowledgement*>(p->ptr), struct _wsrm__SequenceAcknowledgement);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__SequenceAcknowledgement*>(p->ptr), struct _wsrm__SequenceAcknowledgement);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__UsesSequenceSTR*>(p->ptr), struct _wsrm__UsesSequenceSTR);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__UsesSequenceSTR*>(p->ptr), struct _wsrm__UsesSequenceSTR);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsrm__UsesSequenceSSL*>(p->ptr), struct _wsrm__UsesSequenceSSL);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsrm__UsesSequenceSSL*>(p->ptr), struct _wsrm__UsesSequenceSSL);
		break;
	case SOAP_TYPE___wsrm__CreateSequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__CreateSequence*>(p->ptr), struct __wsrm__CreateSequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__CreateSequence*>(p->ptr), struct __wsrm__CreateSequence);
		break;
	case SOAP_TYPE___wsrm__CloseSequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__CloseSequence*>(p->ptr), struct __wsrm__CloseSequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__CloseSequence*>(p->ptr), struct __wsrm__CloseSequence);
		break;
	case SOAP_TYPE___wsrm__TerminateSequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__TerminateSequence*>(p->ptr), struct __wsrm__TerminateSequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__TerminateSequence*>(p->ptr), struct __wsrm__TerminateSequence);
		break;
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__CreateSequenceResponse*>(p->ptr), struct __wsrm__CreateSequenceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__CreateSequenceResponse*>(p->ptr), struct __wsrm__CreateSequenceResponse);
		break;
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__CloseSequenceResponse*>(p->ptr), struct __wsrm__CloseSequenceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__CloseSequenceResponse*>(p->ptr), struct __wsrm__CloseSequenceResponse);
		break;
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__TerminateSequenceResponse*>(p->ptr), struct __wsrm__TerminateSequenceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__TerminateSequenceResponse*>(p->ptr), struct __wsrm__TerminateSequenceResponse);
		break;
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__SequenceAcknowledgement*>(p->ptr), struct __wsrm__SequenceAcknowledgement);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__SequenceAcknowledgement*>(p->ptr), struct __wsrm__SequenceAcknowledgement);
		break;
	case SOAP_TYPE___wsrm__AckRequested:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__AckRequested*>(p->ptr), struct __wsrm__AckRequested);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__AckRequested*>(p->ptr), struct __wsrm__AckRequested);
		break;
	case SOAP_TYPE___wsrm__LastMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsrm__LastMessage*>(p->ptr), struct __wsrm__LastMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsrm__LastMessage*>(p->ptr), struct __wsrm__LastMessage);
		break;
	case SOAP_TYPE__ds__Signature:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		break;
	case SOAP_TYPE__ds__Transform:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		break;
	case SOAP_TYPE__saml1__Assertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		break;
	case SOAP_TYPE__saml1__Conditions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		break;
	case SOAP_TYPE__saml1__Condition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		break;
	case SOAP_TYPE__saml1__Advice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		break;
	case SOAP_TYPE__saml1__Statement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		break;
	case SOAP_TYPE__saml1__Subject:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		break;
	case SOAP_TYPE__saml1__Action:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		break;
	case SOAP_TYPE__saml1__Evidence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		break;
	case SOAP_TYPE__saml1__Attribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		break;
	case SOAP_TYPE__saml2__BaseID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		break;
	case SOAP_TYPE__saml2__NameID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE__saml2__Issuer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE__saml2__Assertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		break;
	case SOAP_TYPE__saml2__Subject:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		break;
	case SOAP_TYPE__saml2__Conditions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		break;
	case SOAP_TYPE__saml2__Condition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		break;
	case SOAP_TYPE__saml2__Advice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE__saml2__Statement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		break;
	case SOAP_TYPE__saml2__Action:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		break;
	case SOAP_TYPE__saml2__Evidence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		break;
	case SOAP_TYPE__saml2__Attribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE__wst__RequestSecurityToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenType*>(p->ptr), struct wst__RequestSecurityTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenType*>(p->ptr), struct wst__RequestSecurityTokenType);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenResponseType*>(p->ptr), struct wst__RequestSecurityTokenResponseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenResponseType*>(p->ptr), struct wst__RequestSecurityTokenResponseType);
		break;
	case SOAP_TYPE__wst__RequestedSecurityToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedSecurityTokenType*>(p->ptr), struct wst__RequestedSecurityTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedSecurityTokenType*>(p->ptr), struct wst__RequestedSecurityTokenType);
		break;
	case SOAP_TYPE__wst__BinarySecret:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__BinarySecretType*>(p->ptr), struct wst__BinarySecretType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__BinarySecretType*>(p->ptr), struct wst__BinarySecretType);
		break;
	case SOAP_TYPE__wst__Claims:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ClaimsType*>(p->ptr), struct wst__ClaimsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ClaimsType*>(p->ptr), struct wst__ClaimsType);
		break;
	case SOAP_TYPE__wst__Entropy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__EntropyType*>(p->ptr), struct wst__EntropyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__EntropyType*>(p->ptr), struct wst__EntropyType);
		break;
	case SOAP_TYPE__wst__Lifetime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__LifetimeType*>(p->ptr), struct wst__LifetimeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__LifetimeType*>(p->ptr), struct wst__LifetimeType);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenCollection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenCollectionType*>(p->ptr), struct wst__RequestSecurityTokenCollectionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenCollectionType*>(p->ptr), struct wst__RequestSecurityTokenCollectionType);
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponseCollection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		break;
	case SOAP_TYPE__wst__RequestedAttachedReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		break;
	case SOAP_TYPE__wst__RequestedUnattachedReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedReferenceType*>(p->ptr), struct wst__RequestedReferenceType);
		break;
	case SOAP_TYPE__wst__RequestedProofToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedProofTokenType*>(p->ptr), struct wst__RequestedProofTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedProofTokenType*>(p->ptr), struct wst__RequestedProofTokenType);
		break;
	case SOAP_TYPE__wst__IssuedTokens:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestSecurityTokenResponseCollectionType*>(p->ptr), struct wst__RequestSecurityTokenResponseCollectionType);
		break;
	case SOAP_TYPE__wst__RenewTarget:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RenewTargetType*>(p->ptr), struct wst__RenewTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RenewTargetType*>(p->ptr), struct wst__RenewTargetType);
		break;
	case SOAP_TYPE__wst__AllowPostdating:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__AllowPostdatingType*>(p->ptr), struct wst__AllowPostdatingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__AllowPostdatingType*>(p->ptr), struct wst__AllowPostdatingType);
		break;
	case SOAP_TYPE__wst__Renewing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RenewingType*>(p->ptr), struct wst__RenewingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RenewingType*>(p->ptr), struct wst__RenewingType);
		break;
	case SOAP_TYPE__wst__CancelTarget:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__CancelTargetType*>(p->ptr), struct wst__CancelTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__CancelTargetType*>(p->ptr), struct wst__CancelTargetType);
		break;
	case SOAP_TYPE__wst__RequestedTokenCancelled:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestedTokenCancelledType*>(p->ptr), struct wst__RequestedTokenCancelledType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestedTokenCancelledType*>(p->ptr), struct wst__RequestedTokenCancelledType);
		break;
	case SOAP_TYPE__wst__ValidateTarget:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ValidateTargetType*>(p->ptr), struct wst__ValidateTargetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ValidateTargetType*>(p->ptr), struct wst__ValidateTargetType);
		break;
	case SOAP_TYPE__wst__Status:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__StatusType*>(p->ptr), struct wst__StatusType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__StatusType*>(p->ptr), struct wst__StatusType);
		break;
	case SOAP_TYPE__wst__SignChallenge:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		break;
	case SOAP_TYPE__wst__SignChallengeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__SignChallengeType*>(p->ptr), struct wst__SignChallengeType);
		break;
	case SOAP_TYPE__wst__BinaryExchange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__BinaryExchangeType*>(p->ptr), struct wst__BinaryExchangeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__BinaryExchangeType*>(p->ptr), struct wst__BinaryExchangeType);
		break;
	case SOAP_TYPE__wst__RequestKET:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__RequestKETType*>(p->ptr), struct wst__RequestKETType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__RequestKETType*>(p->ptr), struct wst__RequestKETType);
		break;
	case SOAP_TYPE__wst__KeyExchangeToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__KeyExchangeTokenType*>(p->ptr), struct wst__KeyExchangeTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__KeyExchangeTokenType*>(p->ptr), struct wst__KeyExchangeTokenType);
		break;
	case SOAP_TYPE__wst__Authenticator:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__AuthenticatorType*>(p->ptr), struct wst__AuthenticatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__AuthenticatorType*>(p->ptr), struct wst__AuthenticatorType);
		break;
	case SOAP_TYPE__wst__OnBehalfOf:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__OnBehalfOfType*>(p->ptr), struct wst__OnBehalfOfType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__OnBehalfOfType*>(p->ptr), struct wst__OnBehalfOfType);
		break;
	case SOAP_TYPE__wst__Issuer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wst__Encryption:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__EncryptionType*>(p->ptr), struct wst__EncryptionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__EncryptionType*>(p->ptr), struct wst__EncryptionType);
		break;
	case SOAP_TYPE__wst__ProofEncryption:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ProofEncryptionType*>(p->ptr), struct wst__ProofEncryptionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ProofEncryptionType*>(p->ptr), struct wst__ProofEncryptionType);
		break;
	case SOAP_TYPE__wst__UseKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__UseKeyType*>(p->ptr), struct wst__UseKeyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__UseKeyType*>(p->ptr), struct wst__UseKeyType);
		break;
	case SOAP_TYPE__wst__DelegateTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__DelegateToType*>(p->ptr), struct wst__DelegateToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__DelegateToType*>(p->ptr), struct wst__DelegateToType);
		break;
	case SOAP_TYPE__wst__Participants:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wst__ParticipantsType*>(p->ptr), struct wst__ParticipantsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wst__ParticipantsType*>(p->ptr), struct wst__ParticipantsType);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMethods type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMethods*)p = *(_tempuri__GetNamesOfMethods*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMethodsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMethodsResponse*)p = *(_tempuri__GetNamesOfMethodsResponse*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMethodsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMethodsOfAssayType*)p = *(_tempuri__GetNamesOfMethodsOfAssayType*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMethodsOfAssayTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMethodsOfAssayTypeResponse*)p = *(_tempuri__GetNamesOfMethodsOfAssayTypeResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypesOfAllMethods type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypesOfAllMethods*)p = *(_tempuri__GetAssayTypesOfAllMethods*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypesOfAllMethodsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypesOfAllMethodsResponse*)p = *(_tempuri__GetAssayTypesOfAllMethodsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNameOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNameOfCurrentMethod*)p = *(_tempuri__GetNameOfCurrentMethod*)q;
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNameOfCurrentMethodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNameOfCurrentMethodResponse*)p = *(_tempuri__GetNameOfCurrentMethodResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfCurrentMethod*)p = *(_tempuri__GetAssayTypeOfCurrentMethod*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfCurrentMethodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfCurrentMethodResponse*)p = *(_tempuri__GetAssayTypeOfCurrentMethodResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfMethod type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfMethod*)p = *(_tempuri__GetAssayTypeOfMethod*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfMethodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfMethodResponse*)p = *(_tempuri__GetAssayTypeOfMethodResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfRunsets type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfRunsets*)p = *(_tempuri__GetNamesOfRunsets*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfRunsetsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfRunsetsResponse*)p = *(_tempuri__GetNamesOfRunsetsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfRunsetsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfRunsetsOfAssayType*)p = *(_tempuri__GetNamesOfRunsetsOfAssayType*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfRunsetsOfAssayTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse*)p = *(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypesOfAllRunsets type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypesOfAllRunsets*)p = *(_tempuri__GetAssayTypesOfAllRunsets*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypesOfAllRunsetsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypesOfAllRunsetsResponse*)p = *(_tempuri__GetAssayTypesOfAllRunsetsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNameOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNameOfCurrentRunset*)p = *(_tempuri__GetNameOfCurrentRunset*)q;
		break;
	case SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNameOfCurrentRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNameOfCurrentRunsetResponse*)p = *(_tempuri__GetNameOfCurrentRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfCurrentRunset*)p = *(_tempuri__GetAssayTypeOfCurrentRunset*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfCurrentRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfCurrentRunsetResponse*)p = *(_tempuri__GetAssayTypeOfCurrentRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfRunset*)p = *(_tempuri__GetAssayTypeOfRunset*)q;
		break;
	case SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetAssayTypeOfRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetAssayTypeOfRunsetResponse*)p = *(_tempuri__GetAssayTypeOfRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetMethodNamesOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetMethodNamesOfRunset*)p = *(_tempuri__GetMethodNamesOfRunset*)q;
		break;
	case SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetMethodNamesOfRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetMethodNamesOfRunsetResponse*)p = *(_tempuri__GetMethodNamesOfRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__SelectMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SelectMethod type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SelectMethod*)p = *(_tempuri__SelectMethod*)q;
		break;
	case SOAP_TYPE__tempuri__SelectMethodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SelectMethodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SelectMethodResponse*)p = *(_tempuri__SelectMethodResponse*)q;
		break;
	case SOAP_TYPE__tempuri__SelectRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SelectRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SelectRunset*)p = *(_tempuri__SelectRunset*)q;
		break;
	case SOAP_TYPE__tempuri__SelectRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SelectRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SelectRunsetResponse*)p = *(_tempuri__SelectRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__CreateRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__CreateRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__CreateRunset*)p = *(_tempuri__CreateRunset*)q;
		break;
	case SOAP_TYPE__tempuri__CreateRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__CreateRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__CreateRunsetResponse*)p = *(_tempuri__CreateRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetSamplePlateId*)p = *(_tempuri__SetSamplePlateId*)q;
		break;
	case SOAP_TYPE__tempuri__SetSamplePlateIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetSamplePlateIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetSamplePlateIdResponse*)p = *(_tempuri__SetSamplePlateIdResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetSamplePlateId*)p = *(_tempuri__GetSamplePlateId*)q;
		break;
	case SOAP_TYPE__tempuri__GetSamplePlateIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetSamplePlateIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetSamplePlateIdResponse*)p = *(_tempuri__GetSamplePlateIdResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetCurrentSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetCurrentSamplePlateId*)p = *(_tempuri__GetCurrentSamplePlateId*)q;
		break;
	case SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetCurrentSamplePlateIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetCurrentSamplePlateIdResponse*)p = *(_tempuri__GetCurrentSamplePlateIdResponse*)q;
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__MoveSamplePlateTrayOut type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__MoveSamplePlateTrayOut*)p = *(_tempuri__MoveSamplePlateTrayOut*)q;
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__MoveSamplePlateTrayOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__MoveSamplePlateTrayOutResponse*)p = *(_tempuri__MoveSamplePlateTrayOutResponse*)q;
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__MoveSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__MoveSamplePlateTrayIn*)p = *(_tempuri__MoveSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__MoveSamplePlateTrayInResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__MoveSamplePlateTrayInResponse*)p = *(_tempuri__MoveSamplePlateTrayInResponse*)q;
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__StartSelectedRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__StartSelectedRunset*)p = *(_tempuri__StartSelectedRunset*)q;
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__StartSelectedRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__StartSelectedRunsetResponse*)p = *(_tempuri__StartSelectedRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFrom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__StartSelectedRunsetFrom type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__StartSelectedRunsetFrom*)p = *(_tempuri__StartSelectedRunsetFrom*)q;
		break;
	case SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__StartSelectedRunsetFromResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__StartSelectedRunsetFromResponse*)p = *(_tempuri__StartSelectedRunsetFromResponse*)q;
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__PauseRunsetAfter type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__PauseRunsetAfter*)p = *(_tempuri__PauseRunsetAfter*)q;
		break;
	case SOAP_TYPE__tempuri__PauseRunsetAfterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__PauseRunsetAfterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__PauseRunsetAfterResponse*)p = *(_tempuri__PauseRunsetAfterResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ResumeRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ResumeRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ResumeRunset*)p = *(_tempuri__ResumeRunset*)q;
		break;
	case SOAP_TYPE__tempuri__ResumeRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ResumeRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ResumeRunsetResponse*)p = *(_tempuri__ResumeRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ResetRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ResetRunset type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ResetRunset*)p = *(_tempuri__ResetRunset*)q;
		break;
	case SOAP_TYPE__tempuri__ResetRunsetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ResetRunsetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ResetRunsetResponse*)p = *(_tempuri__ResetRunsetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AbortScript:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AbortScript type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AbortScript*)p = *(_tempuri__AbortScript*)q;
		break;
	case SOAP_TYPE__tempuri__AbortScriptResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AbortScriptResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AbortScriptResponse*)p = *(_tempuri__AbortScriptResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LeaveStandby:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LeaveStandby type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LeaveStandby*)p = *(_tempuri__LeaveStandby*)q;
		break;
	case SOAP_TYPE__tempuri__LeaveStandbyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LeaveStandbyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LeaveStandbyResponse*)p = *(_tempuri__LeaveStandbyResponse*)q;
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetStandbyAfterFinish*)p = *(_tempuri__SetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetStandbyAfterFinishResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetStandbyAfterFinishResponse*)p = *(_tempuri__SetStandbyAfterFinishResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetStandbyAfterFinish*)p = *(_tempuri__GetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetStandbyAfterFinishResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetStandbyAfterFinishResponse*)p = *(_tempuri__GetStandbyAfterFinishResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMaintenanceProcedures type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMaintenanceProcedures*)p = *(_tempuri__GetNamesOfMaintenanceProcedures*)q;
		break;
	case SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetNamesOfMaintenanceProceduresResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetNamesOfMaintenanceProceduresResponse*)p = *(_tempuri__GetNamesOfMaintenanceProceduresResponse*)q;
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__RunMaintenanceProcedure type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__RunMaintenanceProcedure*)p = *(_tempuri__RunMaintenanceProcedure*)q;
		break;
	case SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__RunMaintenanceProcedureResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__RunMaintenanceProcedureResponse*)p = *(_tempuri__RunMaintenanceProcedureResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetOperationMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetOperationMode type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetOperationMode*)p = *(_tempuri__GetOperationMode*)q;
		break;
	case SOAP_TYPE__tempuri__GetOperationModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetOperationModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetOperationModeResponse*)p = *(_tempuri__GetOperationModeResponse*)q;
		break;
	case SOAP_TYPE__tempuri__IsChipDocked:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__IsChipDocked type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__IsChipDocked*)p = *(_tempuri__IsChipDocked*)q;
		break;
	case SOAP_TYPE__tempuri__IsChipDockedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__IsChipDockedResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__IsChipDockedResponse*)p = *(_tempuri__IsChipDockedResponse*)q;
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__IsSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__IsSamplePlateTrayIn*)p = *(_tempuri__IsSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__IsSamplePlateTrayInResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__IsSamplePlateTrayInResponse*)p = *(_tempuri__IsSamplePlateTrayInResponse*)q;
		break;
	case SOAP_TYPE__tempuri__HasMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasMessage type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasMessage*)p = *(_tempuri__HasMessage*)q;
		break;
	case SOAP_TYPE__tempuri__HasMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasMessageResponse*)p = *(_tempuri__HasMessageResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetMessage type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetMessage*)p = *(_tempuri__GetMessage*)q;
		break;
	case SOAP_TYPE__tempuri__GetMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetMessageResponse*)p = *(_tempuri__GetMessageResponse*)q;
		break;
	case SOAP_TYPE__tempuri__HasErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasErrors type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasErrors*)p = *(_tempuri__HasErrors*)q;
		break;
	case SOAP_TYPE__tempuri__HasErrorsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasErrorsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasErrorsResponse*)p = *(_tempuri__HasErrorsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetErrors type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetErrors*)p = *(_tempuri__GetErrors*)q;
		break;
	case SOAP_TYPE__tempuri__GetErrorsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetErrorsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetErrorsResponse*)p = *(_tempuri__GetErrorsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__HasWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasWarnings type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasWarnings*)p = *(_tempuri__HasWarnings*)q;
		break;
	case SOAP_TYPE__tempuri__HasWarningsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__HasWarningsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__HasWarningsResponse*)p = *(_tempuri__HasWarningsResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetWarnings type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetWarnings*)p = *(_tempuri__GetWarnings*)q;
		break;
	case SOAP_TYPE__tempuri__GetWarningsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetWarningsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetWarningsResponse*)p = *(_tempuri__GetWarningsResponse*)q;
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy arr__ArrayOfstring type=%d location=%p object=%p\n", t, p, q));
		*(arr__ArrayOfstring*)p = *(arr__ArrayOfstring*)q;
		break;
	case SOAP_TYPE___name__GetNamesOfMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNamesOfMethods type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNamesOfMethods*)p = *(struct __name__GetNamesOfMethods*)q;
		break;
	case SOAP_TYPE___name__GetNamesOfMethodsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNamesOfMethodsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNamesOfMethodsOfAssayType*)p = *(struct __name__GetNamesOfMethodsOfAssayType*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypesOfAllMethods type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypesOfAllMethods*)p = *(struct __name__GetAssayTypesOfAllMethods*)q;
		break;
	case SOAP_TYPE___name__GetNameOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNameOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNameOfCurrentMethod*)p = *(struct __name__GetNameOfCurrentMethod*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypeOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypeOfCurrentMethod*)p = *(struct __name__GetAssayTypeOfCurrentMethod*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypeOfMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypeOfMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypeOfMethod*)p = *(struct __name__GetAssayTypeOfMethod*)q;
		break;
	case SOAP_TYPE___name__GetNamesOfRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNamesOfRunsets type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNamesOfRunsets*)p = *(struct __name__GetNamesOfRunsets*)q;
		break;
	case SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNamesOfRunsetsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNamesOfRunsetsOfAssayType*)p = *(struct __name__GetNamesOfRunsetsOfAssayType*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypesOfAllRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypesOfAllRunsets type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypesOfAllRunsets*)p = *(struct __name__GetAssayTypesOfAllRunsets*)q;
		break;
	case SOAP_TYPE___name__GetNameOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNameOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNameOfCurrentRunset*)p = *(struct __name__GetNameOfCurrentRunset*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypeOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypeOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypeOfCurrentRunset*)p = *(struct __name__GetAssayTypeOfCurrentRunset*)q;
		break;
	case SOAP_TYPE___name__GetAssayTypeOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetAssayTypeOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetAssayTypeOfRunset*)p = *(struct __name__GetAssayTypeOfRunset*)q;
		break;
	case SOAP_TYPE___name__GetMethodNamesOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetMethodNamesOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetMethodNamesOfRunset*)p = *(struct __name__GetMethodNamesOfRunset*)q;
		break;
	case SOAP_TYPE___name__SelectMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__SelectMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__SelectMethod*)p = *(struct __name__SelectMethod*)q;
		break;
	case SOAP_TYPE___name__SelectRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__SelectRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__SelectRunset*)p = *(struct __name__SelectRunset*)q;
		break;
	case SOAP_TYPE___name__CreateRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__CreateRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__CreateRunset*)p = *(struct __name__CreateRunset*)q;
		break;
	case SOAP_TYPE___name__SetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__SetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__SetSamplePlateId*)p = *(struct __name__SetSamplePlateId*)q;
		break;
	case SOAP_TYPE___name__GetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetSamplePlateId*)p = *(struct __name__GetSamplePlateId*)q;
		break;
	case SOAP_TYPE___name__GetCurrentSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetCurrentSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetCurrentSamplePlateId*)p = *(struct __name__GetCurrentSamplePlateId*)q;
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__MoveSamplePlateTrayOut type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__MoveSamplePlateTrayOut*)p = *(struct __name__MoveSamplePlateTrayOut*)q;
		break;
	case SOAP_TYPE___name__MoveSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__MoveSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__MoveSamplePlateTrayIn*)p = *(struct __name__MoveSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE___name__StartSelectedRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__StartSelectedRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__StartSelectedRunset*)p = *(struct __name__StartSelectedRunset*)q;
		break;
	case SOAP_TYPE___name__StartSelectedRunsetFrom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__StartSelectedRunsetFrom type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__StartSelectedRunsetFrom*)p = *(struct __name__StartSelectedRunsetFrom*)q;
		break;
	case SOAP_TYPE___name__PauseRunsetAfter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__PauseRunsetAfter type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__PauseRunsetAfter*)p = *(struct __name__PauseRunsetAfter*)q;
		break;
	case SOAP_TYPE___name__ResumeRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__ResumeRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__ResumeRunset*)p = *(struct __name__ResumeRunset*)q;
		break;
	case SOAP_TYPE___name__ResetRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__ResetRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__ResetRunset*)p = *(struct __name__ResetRunset*)q;
		break;
	case SOAP_TYPE___name__AbortScript:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__AbortScript type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__AbortScript*)p = *(struct __name__AbortScript*)q;
		break;
	case SOAP_TYPE___name__LeaveStandby:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__LeaveStandby type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__LeaveStandby*)p = *(struct __name__LeaveStandby*)q;
		break;
	case SOAP_TYPE___name__SetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__SetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__SetStandbyAfterFinish*)p = *(struct __name__SetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE___name__GetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetStandbyAfterFinish*)p = *(struct __name__GetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE___name__GetNamesOfMaintenanceProcedures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetNamesOfMaintenanceProcedures type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetNamesOfMaintenanceProcedures*)p = *(struct __name__GetNamesOfMaintenanceProcedures*)q;
		break;
	case SOAP_TYPE___name__RunMaintenanceProcedure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__RunMaintenanceProcedure type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__RunMaintenanceProcedure*)p = *(struct __name__RunMaintenanceProcedure*)q;
		break;
	case SOAP_TYPE___name__GetOperationMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetOperationMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetOperationMode*)p = *(struct __name__GetOperationMode*)q;
		break;
	case SOAP_TYPE___name__IsChipDocked:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__IsChipDocked type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__IsChipDocked*)p = *(struct __name__IsChipDocked*)q;
		break;
	case SOAP_TYPE___name__IsSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__IsSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__IsSamplePlateTrayIn*)p = *(struct __name__IsSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE___name__HasMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__HasMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__HasMessage*)p = *(struct __name__HasMessage*)q;
		break;
	case SOAP_TYPE___name__GetMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetMessage*)p = *(struct __name__GetMessage*)q;
		break;
	case SOAP_TYPE___name__HasErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__HasErrors type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__HasErrors*)p = *(struct __name__HasErrors*)q;
		break;
	case SOAP_TYPE___name__GetErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetErrors type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetErrors*)p = *(struct __name__GetErrors*)q;
		break;
	case SOAP_TYPE___name__HasWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__HasWarnings type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__HasWarnings*)p = *(struct __name__HasWarnings*)q;
		break;
	case SOAP_TYPE___name__GetWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name__GetWarnings type=%d location=%p object=%p\n", t, p, q));
		*(struct __name__GetWarnings*)p = *(struct __name__GetWarnings*)q;
		break;
	case SOAP_TYPE___name2__GetNamesOfMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNamesOfMethods type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNamesOfMethods*)p = *(struct __name2__GetNamesOfMethods*)q;
		break;
	case SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNamesOfMethodsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNamesOfMethodsOfAssayType*)p = *(struct __name2__GetNamesOfMethodsOfAssayType*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllMethods:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypesOfAllMethods type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypesOfAllMethods*)p = *(struct __name2__GetAssayTypesOfAllMethods*)q;
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNameOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNameOfCurrentMethod*)p = *(struct __name2__GetNameOfCurrentMethod*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypeOfCurrentMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypeOfCurrentMethod*)p = *(struct __name2__GetAssayTypeOfCurrentMethod*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypeOfMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypeOfMethod*)p = *(struct __name2__GetAssayTypeOfMethod*)q;
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNamesOfRunsets type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNamesOfRunsets*)p = *(struct __name2__GetNamesOfRunsets*)q;
		break;
	case SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNamesOfRunsetsOfAssayType type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNamesOfRunsetsOfAssayType*)p = *(struct __name2__GetNamesOfRunsetsOfAssayType*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypesOfAllRunsets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypesOfAllRunsets type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypesOfAllRunsets*)p = *(struct __name2__GetAssayTypesOfAllRunsets*)q;
		break;
	case SOAP_TYPE___name2__GetNameOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNameOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNameOfCurrentRunset*)p = *(struct __name2__GetNameOfCurrentRunset*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypeOfCurrentRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypeOfCurrentRunset*)p = *(struct __name2__GetAssayTypeOfCurrentRunset*)q;
		break;
	case SOAP_TYPE___name2__GetAssayTypeOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetAssayTypeOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetAssayTypeOfRunset*)p = *(struct __name2__GetAssayTypeOfRunset*)q;
		break;
	case SOAP_TYPE___name2__GetMethodNamesOfRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetMethodNamesOfRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetMethodNamesOfRunset*)p = *(struct __name2__GetMethodNamesOfRunset*)q;
		break;
	case SOAP_TYPE___name2__SelectMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__SelectMethod type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__SelectMethod*)p = *(struct __name2__SelectMethod*)q;
		break;
	case SOAP_TYPE___name2__SelectRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__SelectRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__SelectRunset*)p = *(struct __name2__SelectRunset*)q;
		break;
	case SOAP_TYPE___name2__CreateRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__CreateRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__CreateRunset*)p = *(struct __name2__CreateRunset*)q;
		break;
	case SOAP_TYPE___name2__SetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__SetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__SetSamplePlateId*)p = *(struct __name2__SetSamplePlateId*)q;
		break;
	case SOAP_TYPE___name2__GetSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetSamplePlateId*)p = *(struct __name2__GetSamplePlateId*)q;
		break;
	case SOAP_TYPE___name2__GetCurrentSamplePlateId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetCurrentSamplePlateId type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetCurrentSamplePlateId*)p = *(struct __name2__GetCurrentSamplePlateId*)q;
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__MoveSamplePlateTrayOut type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__MoveSamplePlateTrayOut*)p = *(struct __name2__MoveSamplePlateTrayOut*)q;
		break;
	case SOAP_TYPE___name2__MoveSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__MoveSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__MoveSamplePlateTrayIn*)p = *(struct __name2__MoveSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE___name2__StartSelectedRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__StartSelectedRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__StartSelectedRunset*)p = *(struct __name2__StartSelectedRunset*)q;
		break;
	case SOAP_TYPE___name2__StartSelectedRunsetFrom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__StartSelectedRunsetFrom type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__StartSelectedRunsetFrom*)p = *(struct __name2__StartSelectedRunsetFrom*)q;
		break;
	case SOAP_TYPE___name2__PauseRunsetAfter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__PauseRunsetAfter type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__PauseRunsetAfter*)p = *(struct __name2__PauseRunsetAfter*)q;
		break;
	case SOAP_TYPE___name2__ResumeRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__ResumeRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__ResumeRunset*)p = *(struct __name2__ResumeRunset*)q;
		break;
	case SOAP_TYPE___name2__ResetRunset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__ResetRunset type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__ResetRunset*)p = *(struct __name2__ResetRunset*)q;
		break;
	case SOAP_TYPE___name2__AbortScript:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__AbortScript type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__AbortScript*)p = *(struct __name2__AbortScript*)q;
		break;
	case SOAP_TYPE___name2__LeaveStandby:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__LeaveStandby type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__LeaveStandby*)p = *(struct __name2__LeaveStandby*)q;
		break;
	case SOAP_TYPE___name2__SetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__SetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__SetStandbyAfterFinish*)p = *(struct __name2__SetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE___name2__GetStandbyAfterFinish:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetStandbyAfterFinish type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetStandbyAfterFinish*)p = *(struct __name2__GetStandbyAfterFinish*)q;
		break;
	case SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetNamesOfMaintenanceProcedures type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetNamesOfMaintenanceProcedures*)p = *(struct __name2__GetNamesOfMaintenanceProcedures*)q;
		break;
	case SOAP_TYPE___name2__RunMaintenanceProcedure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__RunMaintenanceProcedure type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__RunMaintenanceProcedure*)p = *(struct __name2__RunMaintenanceProcedure*)q;
		break;
	case SOAP_TYPE___name2__GetOperationMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetOperationMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetOperationMode*)p = *(struct __name2__GetOperationMode*)q;
		break;
	case SOAP_TYPE___name2__IsChipDocked:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__IsChipDocked type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__IsChipDocked*)p = *(struct __name2__IsChipDocked*)q;
		break;
	case SOAP_TYPE___name2__IsSamplePlateTrayIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__IsSamplePlateTrayIn type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__IsSamplePlateTrayIn*)p = *(struct __name2__IsSamplePlateTrayIn*)q;
		break;
	case SOAP_TYPE___name2__HasMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__HasMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__HasMessage*)p = *(struct __name2__HasMessage*)q;
		break;
	case SOAP_TYPE___name2__GetMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetMessage*)p = *(struct __name2__GetMessage*)q;
		break;
	case SOAP_TYPE___name2__HasErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__HasErrors type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__HasErrors*)p = *(struct __name2__HasErrors*)q;
		break;
	case SOAP_TYPE___name2__GetErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetErrors type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetErrors*)p = *(struct __name2__GetErrors*)q;
		break;
	case SOAP_TYPE___name2__HasWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__HasWarnings type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__HasWarnings*)p = *(struct __name2__HasWarnings*)q;
		break;
	case SOAP_TYPE___name2__GetWarnings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __name2__GetWarnings type=%d location=%p object=%p\n", t, p, q));
		*(struct __name2__GetWarnings*)p = *(struct __name2__GetWarnings*)q;
		break;
	case SOAP_TYPE__wsu__Timestamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsu__Timestamp type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
		break;
	case SOAP_TYPE_wsse__EncodedString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsse__EncodedString type=%d location=%p object=%p\n", t, p, q));
		*(struct wsse__EncodedString*)p = *(struct wsse__EncodedString*)q;
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__UsernameToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__BinarySecurityToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
		break;
	case SOAP_TYPE__wsse__Reference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Reference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
		break;
	case SOAP_TYPE__wsse__Embedded:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Embedded type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__KeyIdentifier type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__SecurityTokenReference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
		break;
	case SOAP_TYPE_ds__SignatureType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _c14n__InclusiveNamespaces type=%d location=%p object=%p\n", t, p, q));
		*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
		break;
	case SOAP_TYPE_ds__TransformType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignedInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__CanonicalizationMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
		break;
	case SOAP_TYPE_ds__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
		break;
	case SOAP_TYPE_ds__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DigestMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
		break;
	case SOAP_TYPE_ds__KeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RetrievalMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
		break;
	case SOAP_TYPE_ds__X509DataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509DataType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509IssuerSerialType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertyType*)p = *(struct xenc__EncryptionPropertyType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedType*)p = *(struct xenc__EncryptedType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionMethodType*)p = *(struct xenc__EncryptionMethodType*)q;
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherDataType*)p = *(struct xenc__CipherDataType*)q;
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherReferenceType*)p = *(struct xenc__CipherReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__TransformsType*)p = *(struct xenc__TransformsType*)q;
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__AgreementMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__AgreementMethodType*)p = *(struct xenc__AgreementMethodType*)q;
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__ReferenceType*)p = *(struct xenc__ReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertiesType*)p = *(struct xenc__EncryptionPropertiesType*)q;
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __xenc__union_ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct __xenc__union_ReferenceList*)p = *(struct __xenc__union_ReferenceList*)q;
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xenc__ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct _xenc__ReferenceList*)p = *(struct _xenc__ReferenceList*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedDataType*)p = *(struct xenc__EncryptedDataType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedKeyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedKeyType*)p = *(struct xenc__EncryptedKeyType*)q;
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__SecurityContextTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__SecurityContextTokenType*)p = *(struct wsc__SecurityContextTokenType*)q;
		break;
	case SOAP_TYPE__wsc__union_DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _wsc__union_DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(union _wsc__union_DerivedKeyTokenType*)p = *(union _wsc__union_DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsc__DerivedKeyTokenType_sequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsc__DerivedKeyTokenType_sequence*)p = *(struct __wsc__DerivedKeyTokenType_sequence*)q;
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__DerivedKeyTokenType*)p = *(struct wsc__DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__PropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__PropertiesType*)p = *(struct wsc__PropertiesType*)q;
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_AssertionType*)p = *(struct __saml1__union_AssertionType*)q;
		break;
	case SOAP_TYPE_saml1__AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AssertionType*)p = *(struct saml1__AssertionType*)q;
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_ConditionsType*)p = *(struct __saml1__union_ConditionsType*)q;
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionsType*)p = *(struct saml1__ConditionsType*)q;
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionAbstractType*)p = *(struct saml1__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_AdviceType*)p = *(struct __saml1__union_AdviceType*)q;
		break;
	case SOAP_TYPE_saml1__AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AdviceType*)p = *(struct saml1__AdviceType*)q;
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__StatementAbstractType*)p = *(struct saml1__StatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectType*)p = *(struct saml1__SubjectType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectConfirmationType*)p = *(struct saml1__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectLocalityType*)p = *(struct saml1__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorityBindingType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorityBindingType*)p = *(struct saml1__AuthorityBindingType*)q;
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_EvidenceType*)p = *(struct __saml1__union_EvidenceType*)q;
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__EvidenceType*)p = *(struct saml1__EvidenceType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeDesignatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeDesignatorType*)p = *(struct saml1__AttributeDesignatorType*)q;
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AudienceRestrictionConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AudienceRestrictionConditionType*)p = *(struct saml1__AudienceRestrictionConditionType*)q;
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__DoNotCacheConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__DoNotCacheConditionType*)p = *(struct saml1__DoNotCacheConditionType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectStatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectStatementAbstractType*)p = *(struct saml1__SubjectStatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__NameIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__NameIdentifierType*)p = *(struct saml1__NameIdentifierType*)q;
		break;
	case SOAP_TYPE_saml1__ActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ActionType*)p = *(struct saml1__ActionType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeType*)p = *(struct saml1__AttributeType*)q;
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthenticationStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthenticationStatementType*)p = *(struct saml1__AuthenticationStatementType*)q;
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorizationDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorizationDecisionStatementType*)p = *(struct saml1__AuthorizationDecisionStatementType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeStatementType*)p = *(struct saml1__AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__BaseIDAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__BaseIDAbstractType*)p = *(struct saml2__BaseIDAbstractType*)q;
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AssertionType*)p = *(struct __saml2__union_AssertionType*)q;
		break;
	case SOAP_TYPE_saml2__AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AssertionType*)p = *(struct saml2__AssertionType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectType*)p = *(struct saml2__SubjectType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationType*)p = *(struct saml2__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_ConditionsType*)p = *(struct __saml2__union_ConditionsType*)q;
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionsType*)p = *(struct saml2__ConditionsType*)q;
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionAbstractType*)p = *(struct saml2__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AdviceType*)p = *(struct __saml2__union_AdviceType*)q;
		break;
	case SOAP_TYPE_saml2__AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AdviceType*)p = *(struct saml2__AdviceType*)q;
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__StatementAbstractType*)p = *(struct saml2__StatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectLocalityType*)p = *(struct saml2__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnContextType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnContextType*)p = *(struct saml2__AuthnContextType*)q;
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_EvidenceType*)p = *(struct __saml2__union_EvidenceType*)q;
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EvidenceType*)p = *(struct saml2__EvidenceType*)q;
		break;
	case SOAP_TYPE_saml2__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeType*)p = *(struct saml2__AttributeType*)q;
		break;
	case SOAP_TYPE_saml2__NameIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationDataType*)p = *(struct saml2__SubjectConfirmationDataType*)q;
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AudienceRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AudienceRestrictionType*)p = *(struct saml2__AudienceRestrictionType*)q;
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__OneTimeUseType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__OneTimeUseType*)p = *(struct saml2__OneTimeUseType*)q;
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ProxyRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ProxyRestrictionType*)p = *(struct saml2__ProxyRestrictionType*)q;
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnStatementType*)p = *(struct saml2__AuthnStatementType*)q;
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthzDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthzDecisionStatementType*)p = *(struct saml2__AuthzDecisionStatementType*)q;
		break;
	case SOAP_TYPE_saml2__ActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ActionType*)p = *(struct saml2__ActionType*)q;
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AttributeStatementType*)p = *(struct __saml2__union_AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeStatementType*)p = *(struct saml2__AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__KeyInfoConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__KeyInfoConfirmationDataType*)p = *(struct saml2__KeyInfoConfirmationDataType*)q;
		break;
	case SOAP_TYPE__wsse__Security:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Security type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
		break;
	case SOAP_TYPE__wsse__Password:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Password type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE__wsp__AppliesTo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsp__AppliesTo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsp__AppliesTo_*)p = *(struct _wsp__AppliesTo_*)q;
		break;
	case SOAP_TYPE_wst__RequestedSecurityTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedSecurityTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedSecurityTokenType*)p = *(struct wst__RequestedSecurityTokenType*)q;
		break;
	case SOAP_TYPE_wst__EntropyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__EntropyType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__EntropyType*)p = *(struct wst__EntropyType*)q;
		break;
	case SOAP_TYPE_wst__AuthenticatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__AuthenticatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__AuthenticatorType*)p = *(struct wst__AuthenticatorType*)q;
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenType*)p = *(struct wst__RequestSecurityTokenType*)q;
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenResponseType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenResponseType*)p = *(struct wst__RequestSecurityTokenResponseType*)q;
		break;
	case SOAP_TYPE_wst__ClaimsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ClaimsType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ClaimsType*)p = *(struct wst__ClaimsType*)q;
		break;
	case SOAP_TYPE_wst__LifetimeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__LifetimeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__LifetimeType*)p = *(struct wst__LifetimeType*)q;
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenCollectionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenCollectionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenCollectionType*)p = *(struct wst__RequestSecurityTokenCollectionType*)q;
		break;
	case SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenResponseCollectionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenResponseCollectionType*)p = *(struct wst__RequestSecurityTokenResponseCollectionType*)q;
		break;
	case SOAP_TYPE_wst__RequestedReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedReferenceType*)p = *(struct wst__RequestedReferenceType*)q;
		break;
	case SOAP_TYPE_wst__RequestedProofTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedProofTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedProofTokenType*)p = *(struct wst__RequestedProofTokenType*)q;
		break;
	case SOAP_TYPE_wst__RenewTargetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RenewTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RenewTargetType*)p = *(struct wst__RenewTargetType*)q;
		break;
	case SOAP_TYPE_wst__AllowPostdatingType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__AllowPostdatingType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__AllowPostdatingType*)p = *(struct wst__AllowPostdatingType*)q;
		break;
	case SOAP_TYPE_wst__RenewingType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RenewingType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RenewingType*)p = *(struct wst__RenewingType*)q;
		break;
	case SOAP_TYPE_wst__CancelTargetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__CancelTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__CancelTargetType*)p = *(struct wst__CancelTargetType*)q;
		break;
	case SOAP_TYPE_wst__RequestedTokenCancelledType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedTokenCancelledType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedTokenCancelledType*)p = *(struct wst__RequestedTokenCancelledType*)q;
		break;
	case SOAP_TYPE_wst__ValidateTargetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ValidateTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ValidateTargetType*)p = *(struct wst__ValidateTargetType*)q;
		break;
	case SOAP_TYPE_wst__StatusType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__StatusType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__StatusType*)p = *(struct wst__StatusType*)q;
		break;
	case SOAP_TYPE_wst__SignChallengeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__SignChallengeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__SignChallengeType*)p = *(struct wst__SignChallengeType*)q;
		break;
	case SOAP_TYPE_wst__RequestKETType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestKETType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestKETType*)p = *(struct wst__RequestKETType*)q;
		break;
	case SOAP_TYPE_wst__KeyExchangeTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__KeyExchangeTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__KeyExchangeTokenType*)p = *(struct wst__KeyExchangeTokenType*)q;
		break;
	case SOAP_TYPE_wst__OnBehalfOfType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__OnBehalfOfType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__OnBehalfOfType*)p = *(struct wst__OnBehalfOfType*)q;
		break;
	case SOAP_TYPE_wst__EncryptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__EncryptionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__EncryptionType*)p = *(struct wst__EncryptionType*)q;
		break;
	case SOAP_TYPE_wst__ProofEncryptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ProofEncryptionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ProofEncryptionType*)p = *(struct wst__ProofEncryptionType*)q;
		break;
	case SOAP_TYPE_wst__UseKeyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__UseKeyType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__UseKeyType*)p = *(struct wst__UseKeyType*)q;
		break;
	case SOAP_TYPE_wst__DelegateToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__DelegateToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__DelegateToType*)p = *(struct wst__DelegateToType*)q;
		break;
	case SOAP_TYPE_wst__ParticipantsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ParticipantsType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ParticipantsType*)p = *(struct wst__ParticipantsType*)q;
		break;
	case SOAP_TYPE_wst__ParticipantType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ParticipantType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ParticipantType*)p = *(struct wst__ParticipantType*)q;
		break;
	case SOAP_TYPE_wst__BinarySecretType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__BinarySecretType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__BinarySecretType*)p = *(struct wst__BinarySecretType*)q;
		break;
	case SOAP_TYPE_wst__BinaryExchangeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__BinaryExchangeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__BinaryExchangeType*)p = *(struct wst__BinaryExchangeType*)q;
		break;
	case SOAP_TYPE___wst__RequestSecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wst__RequestSecurityToken type=%d location=%p object=%p\n", t, p, q));
		*(struct __wst__RequestSecurityToken*)p = *(struct __wst__RequestSecurityToken*)q;
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wst__RequestSecurityTokenResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __wst__RequestSecurityTokenResponse*)p = *(struct __wst__RequestSecurityTokenResponse*)q;
		break;
	case SOAP_TYPE___wst__RequestSecurityTokenCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wst__RequestSecurityTokenCollection type=%d location=%p object=%p\n", t, p, q));
		*(struct __wst__RequestSecurityTokenCollection*)p = *(struct __wst__RequestSecurityTokenCollection*)q;
		break;
	case SOAP_TYPE_wsrm__SequenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__SequenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__SequenceType*)p = *(struct wsrm__SequenceType*)q;
		break;
	case SOAP_TYPE_wsrm__AckRequestedType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__AckRequestedType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__AckRequestedType*)p = *(struct wsrm__AckRequestedType*)q;
		break;
	case SOAP_TYPE_wsrm__SequenceFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__SequenceFaultType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__SequenceFaultType*)p = *(struct wsrm__SequenceFaultType*)q;
		break;
	case SOAP_TYPE_wsrm__CreateSequenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__CreateSequenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__CreateSequenceType*)p = *(struct wsrm__CreateSequenceType*)q;
		break;
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__CreateSequenceResponseType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__CreateSequenceResponseType*)p = *(struct wsrm__CreateSequenceResponseType*)q;
		break;
	case SOAP_TYPE_wsrm__CloseSequenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__CloseSequenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__CloseSequenceType*)p = *(struct wsrm__CloseSequenceType*)q;
		break;
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__CloseSequenceResponseType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__CloseSequenceResponseType*)p = *(struct wsrm__CloseSequenceResponseType*)q;
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__TerminateSequenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__TerminateSequenceType*)p = *(struct wsrm__TerminateSequenceType*)q;
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__TerminateSequenceResponseType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__TerminateSequenceResponseType*)p = *(struct wsrm__TerminateSequenceResponseType*)q;
		break;
	case SOAP_TYPE_wsrm__OfferType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__OfferType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__OfferType*)p = *(struct wsrm__OfferType*)q;
		break;
	case SOAP_TYPE_wsrm__AcceptType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsrm__AcceptType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsrm__AcceptType*)p = *(struct wsrm__AcceptType*)q;
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__SequenceAcknowledgement_Final type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__SequenceAcknowledgement_Final*)p = *(struct _wsrm__SequenceAcknowledgement_Final*)q;
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__SequenceAcknowledgement_AcknowledgementRange type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)p = *(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)q;
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__SequenceAcknowledgement_None type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__SequenceAcknowledgement_None*)p = *(struct _wsrm__SequenceAcknowledgement_None*)q;
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__SequenceAcknowledgement type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__SequenceAcknowledgement*)p = *(struct _wsrm__SequenceAcknowledgement*)q;
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__UsesSequenceSTR type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__UsesSequenceSTR*)p = *(struct _wsrm__UsesSequenceSTR*)q;
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsrm__UsesSequenceSSL type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsrm__UsesSequenceSSL*)p = *(struct _wsrm__UsesSequenceSSL*)q;
		break;
	case SOAP_TYPE___wsrm__CreateSequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__CreateSequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__CreateSequence*)p = *(struct __wsrm__CreateSequence*)q;
		break;
	case SOAP_TYPE___wsrm__CloseSequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__CloseSequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__CloseSequence*)p = *(struct __wsrm__CloseSequence*)q;
		break;
	case SOAP_TYPE___wsrm__TerminateSequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__TerminateSequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__TerminateSequence*)p = *(struct __wsrm__TerminateSequence*)q;
		break;
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__CreateSequenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__CreateSequenceResponse*)p = *(struct __wsrm__CreateSequenceResponse*)q;
		break;
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__CloseSequenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__CloseSequenceResponse*)p = *(struct __wsrm__CloseSequenceResponse*)q;
		break;
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__TerminateSequenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__TerminateSequenceResponse*)p = *(struct __wsrm__TerminateSequenceResponse*)q;
		break;
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__SequenceAcknowledgement type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__SequenceAcknowledgement*)p = *(struct __wsrm__SequenceAcknowledgement*)q;
		break;
	case SOAP_TYPE___wsrm__AckRequested:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__AckRequested type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__AckRequested*)p = *(struct __wsrm__AckRequested*)q;
		break;
	case SOAP_TYPE___wsrm__LastMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsrm__LastMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsrm__LastMessage*)p = *(struct __wsrm__LastMessage*)q;
		break;
	case SOAP_TYPE__ds__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__ds__Transform:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE__ds__KeyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	case SOAP_TYPE__saml1__Assertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AssertionType*)p = *(struct saml1__AssertionType*)q;
		break;
	case SOAP_TYPE__saml1__Conditions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionsType*)p = *(struct saml1__ConditionsType*)q;
		break;
	case SOAP_TYPE__saml1__Condition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionAbstractType*)p = *(struct saml1__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AudienceRestrictionConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AudienceRestrictionConditionType*)p = *(struct saml1__AudienceRestrictionConditionType*)q;
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__DoNotCacheConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__DoNotCacheConditionType*)p = *(struct saml1__DoNotCacheConditionType*)q;
		break;
	case SOAP_TYPE__saml1__Advice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AdviceType*)p = *(struct saml1__AdviceType*)q;
		break;
	case SOAP_TYPE__saml1__Statement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__StatementAbstractType*)p = *(struct saml1__StatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectStatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectStatementAbstractType*)p = *(struct saml1__SubjectStatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__Subject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectType*)p = *(struct saml1__SubjectType*)q;
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__NameIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__NameIdentifierType*)p = *(struct saml1__NameIdentifierType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectConfirmationType*)p = *(struct saml1__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthenticationStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthenticationStatementType*)p = *(struct saml1__AuthenticationStatementType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectLocalityType*)p = *(struct saml1__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorityBindingType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorityBindingType*)p = *(struct saml1__AuthorityBindingType*)q;
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorizationDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorizationDecisionStatementType*)p = *(struct saml1__AuthorizationDecisionStatementType*)q;
		break;
	case SOAP_TYPE__saml1__Action:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ActionType*)p = *(struct saml1__ActionType*)q;
		break;
	case SOAP_TYPE__saml1__Evidence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__EvidenceType*)p = *(struct saml1__EvidenceType*)q;
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeStatementType*)p = *(struct saml1__AttributeStatementType*)q;
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeDesignatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeDesignatorType*)p = *(struct saml1__AttributeDesignatorType*)q;
		break;
	case SOAP_TYPE__saml1__Attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeType*)p = *(struct saml1__AttributeType*)q;
		break;
	case SOAP_TYPE__saml2__BaseID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__BaseIDAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__BaseIDAbstractType*)p = *(struct saml2__BaseIDAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__NameID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE__saml2__Issuer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE__saml2__Assertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AssertionType*)p = *(struct saml2__AssertionType*)q;
		break;
	case SOAP_TYPE__saml2__Subject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectType*)p = *(struct saml2__SubjectType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationType*)p = *(struct saml2__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationDataType*)p = *(struct saml2__SubjectConfirmationDataType*)q;
		break;
	case SOAP_TYPE__saml2__Conditions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionsType*)p = *(struct saml2__ConditionsType*)q;
		break;
	case SOAP_TYPE__saml2__Condition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionAbstractType*)p = *(struct saml2__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AudienceRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AudienceRestrictionType*)p = *(struct saml2__AudienceRestrictionType*)q;
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__OneTimeUseType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__OneTimeUseType*)p = *(struct saml2__OneTimeUseType*)q;
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ProxyRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ProxyRestrictionType*)p = *(struct saml2__ProxyRestrictionType*)q;
		break;
	case SOAP_TYPE__saml2__Advice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AdviceType*)p = *(struct saml2__AdviceType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE__saml2__Statement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__StatementAbstractType*)p = *(struct saml2__StatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnStatementType*)p = *(struct saml2__AuthnStatementType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectLocalityType*)p = *(struct saml2__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnContextType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnContextType*)p = *(struct saml2__AuthnContextType*)q;
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthzDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthzDecisionStatementType*)p = *(struct saml2__AuthzDecisionStatementType*)q;
		break;
	case SOAP_TYPE__saml2__Action:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ActionType*)p = *(struct saml2__ActionType*)q;
		break;
	case SOAP_TYPE__saml2__Evidence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EvidenceType*)p = *(struct saml2__EvidenceType*)q;
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeStatementType*)p = *(struct saml2__AttributeStatementType*)q;
		break;
	case SOAP_TYPE__saml2__Attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeType*)p = *(struct saml2__AttributeType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE__wst__RequestSecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenType*)p = *(struct wst__RequestSecurityTokenType*)q;
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenResponseType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenResponseType*)p = *(struct wst__RequestSecurityTokenResponseType*)q;
		break;
	case SOAP_TYPE__wst__RequestedSecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedSecurityTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedSecurityTokenType*)p = *(struct wst__RequestedSecurityTokenType*)q;
		break;
	case SOAP_TYPE__wst__BinarySecret:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__BinarySecretType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__BinarySecretType*)p = *(struct wst__BinarySecretType*)q;
		break;
	case SOAP_TYPE__wst__Claims:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ClaimsType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ClaimsType*)p = *(struct wst__ClaimsType*)q;
		break;
	case SOAP_TYPE__wst__Entropy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__EntropyType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__EntropyType*)p = *(struct wst__EntropyType*)q;
		break;
	case SOAP_TYPE__wst__Lifetime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__LifetimeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__LifetimeType*)p = *(struct wst__LifetimeType*)q;
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenCollectionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenCollectionType*)p = *(struct wst__RequestSecurityTokenCollectionType*)q;
		break;
	case SOAP_TYPE__wst__RequestSecurityTokenResponseCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenResponseCollectionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenResponseCollectionType*)p = *(struct wst__RequestSecurityTokenResponseCollectionType*)q;
		break;
	case SOAP_TYPE__wst__RequestedAttachedReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedReferenceType*)p = *(struct wst__RequestedReferenceType*)q;
		break;
	case SOAP_TYPE__wst__RequestedUnattachedReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedReferenceType*)p = *(struct wst__RequestedReferenceType*)q;
		break;
	case SOAP_TYPE__wst__RequestedProofToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedProofTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedProofTokenType*)p = *(struct wst__RequestedProofTokenType*)q;
		break;
	case SOAP_TYPE__wst__IssuedTokens:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestSecurityTokenResponseCollectionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestSecurityTokenResponseCollectionType*)p = *(struct wst__RequestSecurityTokenResponseCollectionType*)q;
		break;
	case SOAP_TYPE__wst__RenewTarget:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RenewTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RenewTargetType*)p = *(struct wst__RenewTargetType*)q;
		break;
	case SOAP_TYPE__wst__AllowPostdating:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__AllowPostdatingType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__AllowPostdatingType*)p = *(struct wst__AllowPostdatingType*)q;
		break;
	case SOAP_TYPE__wst__Renewing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RenewingType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RenewingType*)p = *(struct wst__RenewingType*)q;
		break;
	case SOAP_TYPE__wst__CancelTarget:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__CancelTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__CancelTargetType*)p = *(struct wst__CancelTargetType*)q;
		break;
	case SOAP_TYPE__wst__RequestedTokenCancelled:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestedTokenCancelledType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestedTokenCancelledType*)p = *(struct wst__RequestedTokenCancelledType*)q;
		break;
	case SOAP_TYPE__wst__ValidateTarget:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ValidateTargetType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ValidateTargetType*)p = *(struct wst__ValidateTargetType*)q;
		break;
	case SOAP_TYPE__wst__Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__StatusType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__StatusType*)p = *(struct wst__StatusType*)q;
		break;
	case SOAP_TYPE__wst__SignChallenge:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__SignChallengeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__SignChallengeType*)p = *(struct wst__SignChallengeType*)q;
		break;
	case SOAP_TYPE__wst__SignChallengeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__SignChallengeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__SignChallengeType*)p = *(struct wst__SignChallengeType*)q;
		break;
	case SOAP_TYPE__wst__BinaryExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__BinaryExchangeType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__BinaryExchangeType*)p = *(struct wst__BinaryExchangeType*)q;
		break;
	case SOAP_TYPE__wst__RequestKET:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__RequestKETType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__RequestKETType*)p = *(struct wst__RequestKETType*)q;
		break;
	case SOAP_TYPE__wst__KeyExchangeToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__KeyExchangeTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__KeyExchangeTokenType*)p = *(struct wst__KeyExchangeTokenType*)q;
		break;
	case SOAP_TYPE__wst__Authenticator:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__AuthenticatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__AuthenticatorType*)p = *(struct wst__AuthenticatorType*)q;
		break;
	case SOAP_TYPE__wst__OnBehalfOf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__OnBehalfOfType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__OnBehalfOfType*)p = *(struct wst__OnBehalfOfType*)q;
		break;
	case SOAP_TYPE__wst__Issuer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wst__Encryption:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__EncryptionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__EncryptionType*)p = *(struct wst__EncryptionType*)q;
		break;
	case SOAP_TYPE__wst__ProofEncryption:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ProofEncryptionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ProofEncryptionType*)p = *(struct wst__ProofEncryptionType*)q;
		break;
	case SOAP_TYPE__wst__UseKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__UseKeyType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__UseKeyType*)p = *(struct wst__UseKeyType*)q;
		break;
	case SOAP_TYPE__wst__DelegateTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__DelegateToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__DelegateToType*)p = *(struct wst__DelegateToType*)q;
		break;
	case SOAP_TYPE__wst__Participants:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wst__ParticipantsType type=%d location=%p object=%p\n", t, p, q));
		*(struct wst__ParticipantsType*)p = *(struct wst__ParticipantsType*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_xsd__duration(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_xsd__duration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__KeySize(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wst__KeySize(soap, tag ? tag : "wst:KeySize", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsrm__IncompleteSequenceBehaviorType[] =
{	{ (LONG64)DiscardEntireSequence, "DiscardEntireSequence" },
	{ (LONG64)DiscardFollowingFirstGap, "DiscardFollowingFirstGap" },
	{ (LONG64)NoDiscard, "NoDiscard" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsrm__IncompleteSequenceBehaviorType2s(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType n)
{
	const char *s = soap_code_str(soap_codes_wsrm__IncompleteSequenceBehaviorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, int id, const enum wsrm__IncompleteSequenceBehaviorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType), type) || soap_send(soap, soap_wsrm__IncompleteSequenceBehaviorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *s, enum wsrm__IncompleteSequenceBehaviorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsrm__IncompleteSequenceBehaviorType, s);
	if (map)
		*a = (enum wsrm__IncompleteSequenceBehaviorType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum wsrm__IncompleteSequenceBehaviorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType * SOAP_FMAC4 soap_in_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, enum wsrm__IncompleteSequenceBehaviorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsrm__IncompleteSequenceBehaviorType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, sizeof(enum wsrm__IncompleteSequenceBehaviorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsrm__IncompleteSequenceBehaviorType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsrm__IncompleteSequenceBehaviorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, sizeof(enum wsrm__IncompleteSequenceBehaviorType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType * SOAP_FMAC4 soap_new_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, int n)
{
	enum wsrm__IncompleteSequenceBehaviorType *a = static_cast<enum wsrm__IncompleteSequenceBehaviorType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsrm__IncompleteSequenceBehaviorType)));
	for (enum wsrm__IncompleteSequenceBehaviorType *p = a; p && n--; ++p)
		soap_default_wsrm__IncompleteSequenceBehaviorType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const enum wsrm__IncompleteSequenceBehaviorType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag ? tag : "wsrm:IncompleteSequenceBehaviorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType * SOAP_FMAC4 soap_get_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsrm__FaultCodes[] =
{	{ (LONG64)wsrm__SequenceTerminated, "wsrm:SequenceTerminated" },
	{ (LONG64)wsrm__UnknownSequence, "wsrm:UnknownSequence" },
	{ (LONG64)wsrm__InvalidAcknowledgement, "wsrm:InvalidAcknowledgement" },
	{ (LONG64)wsrm__MessageNumberRollover, "wsrm:MessageNumberRollover" },
	{ (LONG64)wsrm__LastMessageNumberExceeded, "wsrm:LastMessageNumberExceeded" },
	{ (LONG64)wsrm__CreateSequenceRefused, "wsrm:CreateSequenceRefused" },
	{ (LONG64)wsrm__WSRMRequired, "wsrm:WSRMRequired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsrm__FaultCodes2s(struct soap *soap, enum wsrm__FaultCodes n)
{
	const char *s = soap_code_str(soap_codes_wsrm__FaultCodes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__FaultCodes(struct soap *soap, const char *tag, int id, const enum wsrm__FaultCodes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__FaultCodes), type) || soap_send(soap, soap_wsrm__FaultCodes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsrm__FaultCodes(struct soap *soap, const char *s, enum wsrm__FaultCodes *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsrm__FaultCodes, t);
	if (map)
		*a = (enum wsrm__FaultCodes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsrm__FaultCodes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsrm__FaultCodes * SOAP_FMAC4 soap_in_wsrm__FaultCodes(struct soap *soap, const char *tag, enum wsrm__FaultCodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsrm__FaultCodes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__FaultCodes, sizeof(enum wsrm__FaultCodes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsrm__FaultCodes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsrm__FaultCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__FaultCodes, SOAP_TYPE_wsrm__FaultCodes, sizeof(enum wsrm__FaultCodes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsrm__FaultCodes * SOAP_FMAC4 soap_new_wsrm__FaultCodes(struct soap *soap, int n)
{
	enum wsrm__FaultCodes *a = static_cast<enum wsrm__FaultCodes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsrm__FaultCodes)));
	for (enum wsrm__FaultCodes *p = a; p && n--; ++p)
		soap_default_wsrm__FaultCodes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__FaultCodes(struct soap *soap, const enum wsrm__FaultCodes *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__FaultCodes(soap, tag ? tag : "wsrm:FaultCodes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__FaultCodes * SOAP_FMAC4 soap_get_wsrm__FaultCodes(struct soap *soap, enum wsrm__FaultCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__FaultCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml2__DecisionType[] =
{	{ (LONG64)saml2__DecisionType__Permit, "Permit" },
	{ (LONG64)saml2__DecisionType__Deny, "Deny" },
	{ (LONG64)saml2__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml2__DecisionType2s(struct soap *soap, enum saml2__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml2__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__DecisionType(struct soap *soap, const char *tag, int id, const enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__DecisionType), type) || soap_send(soap, soap_saml2__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml2__DecisionType(struct soap *soap, const char *s, enum saml2__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml2__DecisionType, s);
	if (map)
		*a = (enum saml2__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml2__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_in_saml2__DecisionType(struct soap *soap, const char *tag, enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml2__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml2__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_new_saml2__DecisionType(struct soap *soap, int n)
{
	enum saml2__DecisionType *a = static_cast<enum saml2__DecisionType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum saml2__DecisionType)));
	for (enum saml2__DecisionType *p = a; p && n--; ++p)
		soap_default_saml2__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__DecisionType(struct soap *soap, const enum saml2__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__DecisionType(soap, tag ? tag : "saml2:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_get_saml2__DecisionType(struct soap *soap, enum saml2__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml1__DecisionType[] =
{	{ (LONG64)saml1__DecisionType__Permit, "Permit" },
	{ (LONG64)saml1__DecisionType__Deny, "Deny" },
	{ (LONG64)saml1__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml1__DecisionType2s(struct soap *soap, enum saml1__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml1__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DecisionType(struct soap *soap, const char *tag, int id, const enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DecisionType), type) || soap_send(soap, soap_saml1__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml1__DecisionType(struct soap *soap, const char *s, enum saml1__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml1__DecisionType, s);
	if (map)
		*a = (enum saml1__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml1__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_in_saml1__DecisionType(struct soap *soap, const char *tag, enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml1__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml1__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_new_saml1__DecisionType(struct soap *soap, int n)
{
	enum saml1__DecisionType *a = static_cast<enum saml1__DecisionType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum saml1__DecisionType)));
	for (enum saml1__DecisionType *p = a; p && n--; ++p)
		soap_default_saml1__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DecisionType(struct soap *soap, const enum saml1__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DecisionType(soap, tag ? tag : "saml1:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_get_saml1__DecisionType(struct soap *soap, enum saml1__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsc__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_new_wsc__FaultCodeType(struct soap *soap, int n)
{
	enum wsc__FaultCodeType *a = static_cast<enum wsc__FaultCodeType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsc__FaultCodeType)));
	for (enum wsc__FaultCodeType *p = a; p && n--; ++p)
		soap_default_wsc__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag ? tag : "wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{
	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_new_wsse__FaultcodeEnum(struct soap *soap, int n)
{
	enum wsse__FaultcodeEnum *a = static_cast<enum wsse__FaultcodeEnum *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsse__FaultcodeEnum)));
	for (enum wsse__FaultcodeEnum *p = a; p && n--; ++p)
		soap_default_wsse__FaultcodeEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag ? tag : "wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{
	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsu__tTimestampFault(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_new_wsu__tTimestampFault(struct soap *soap, int n)
{
	enum wsu__tTimestampFault *a = static_cast<enum wsu__tTimestampFault *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsu__tTimestampFault)));
	for (enum wsu__tTimestampFault *p = a; p && n--; ++p)
		soap_default_wsu__tTimestampFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag ? tag : "wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void arr__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->arr__ArrayOfstring::string);
}

void arr__ArrayOfstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->arr__ArrayOfstring::string);
#endif
}

int arr__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_arr__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_arr__ArrayOfstring(struct soap *soap, const char *tag, int id, const arr__ArrayOfstring *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_arr__ArrayOfstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "arr:string", -1, &a->arr__ArrayOfstring::string, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *arr__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_arr__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 arr__ArrayOfstring * SOAP_FMAC4 soap_in_arr__ArrayOfstring(struct soap *soap, const char *tag, arr__ArrayOfstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (arr__ArrayOfstring*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_arr__ArrayOfstring)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (arr__ArrayOfstring *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "arr:string", &a->arr__ArrayOfstring::string, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (arr__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_arr__ArrayOfstring, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 arr__ArrayOfstring * SOAP_FMAC2 soap_instantiate_arr__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_arr__ArrayOfstring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	arr__ArrayOfstring *p;
	size_t k = sizeof(arr__ArrayOfstring);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_arr__ArrayOfstring, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, arr__ArrayOfstring);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, arr__ArrayOfstring, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated arr__ArrayOfstring location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int arr__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_arr__ArrayOfstring(soap, tag ? tag : "arr:ArrayOfstring", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *arr__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_arr__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 arr__ArrayOfstring * SOAP_FMAC4 soap_get_arr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_arr__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetWarningsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetWarningsResponse::GetWarningsResult = NULL;
}

void _tempuri__GetWarningsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetWarningsResponse::GetWarningsResult);
#endif
}

int _tempuri__GetWarningsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetWarningsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetWarningsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetWarningsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetWarningsResponse), type))
		return soap->error;
	if (a->GetWarningsResult)
		soap_element_result(soap, "tempuri:GetWarningsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetWarningsResult", -1, &a->_tempuri__GetWarningsResponse::GetWarningsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetWarningsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetWarningsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetWarningsResponse * SOAP_FMAC4 soap_in__tempuri__GetWarningsResponse(struct soap *soap, const char *tag, _tempuri__GetWarningsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetWarningsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetWarningsResponse, sizeof(_tempuri__GetWarningsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetWarningsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetWarningsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetWarningsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWarningsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetWarningsResult", &a->_tempuri__GetWarningsResponse::GetWarningsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetWarningsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetWarningsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetWarningsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetWarningsResponse, SOAP_TYPE__tempuri__GetWarningsResponse, sizeof(_tempuri__GetWarningsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetWarningsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetWarningsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetWarningsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetWarningsResponse *p;
	size_t k = sizeof(_tempuri__GetWarningsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetWarningsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetWarningsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetWarningsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetWarningsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetWarningsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetWarningsResponse(soap, tag ? tag : "tempuri:GetWarningsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetWarningsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetWarningsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetWarningsResponse * SOAP_FMAC4 soap_get__tempuri__GetWarningsResponse(struct soap *soap, _tempuri__GetWarningsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetWarningsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetWarnings::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetWarnings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetWarnings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetWarnings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetWarnings(struct soap *soap, const char *tag, int id, const _tempuri__GetWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetWarnings), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetWarnings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetWarnings(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetWarnings * SOAP_FMAC4 soap_in__tempuri__GetWarnings(struct soap *soap, const char *tag, _tempuri__GetWarnings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetWarnings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetWarnings, sizeof(_tempuri__GetWarnings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetWarnings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetWarnings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetWarnings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetWarnings, SOAP_TYPE__tempuri__GetWarnings, sizeof(_tempuri__GetWarnings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetWarnings * SOAP_FMAC2 soap_instantiate__tempuri__GetWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetWarnings *p;
	size_t k = sizeof(_tempuri__GetWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetWarnings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetWarnings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetWarnings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetWarnings(soap, tag ? tag : "tempuri:GetWarnings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetWarnings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetWarnings(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetWarnings * SOAP_FMAC4 soap_get__tempuri__GetWarnings(struct soap *soap, _tempuri__GetWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasWarningsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__HasWarningsResponse::HasWarningsResult = NULL;
}

void _tempuri__HasWarningsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__HasWarningsResponse::HasWarningsResult);
#endif
}

int _tempuri__HasWarningsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasWarningsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasWarningsResponse(struct soap *soap, const char *tag, int id, const _tempuri__HasWarningsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasWarningsResponse), type))
		return soap->error;
	if (a->HasWarningsResult)
		soap_element_result(soap, "tempuri:HasWarningsResult");
	if (soap_out_PointerTobool(soap, "tempuri:HasWarningsResult", -1, &a->_tempuri__HasWarningsResponse::HasWarningsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasWarningsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasWarningsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasWarningsResponse * SOAP_FMAC4 soap_in__tempuri__HasWarningsResponse(struct soap *soap, const char *tag, _tempuri__HasWarningsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasWarningsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasWarningsResponse, sizeof(_tempuri__HasWarningsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasWarningsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasWarningsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HasWarningsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HasWarningsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:HasWarningsResult", &a->_tempuri__HasWarningsResponse::HasWarningsResult, "xsd:boolean"))
				{	soap_flag_HasWarningsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:HasWarningsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasWarningsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasWarningsResponse, SOAP_TYPE__tempuri__HasWarningsResponse, sizeof(_tempuri__HasWarningsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasWarningsResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasWarningsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasWarningsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasWarningsResponse *p;
	size_t k = sizeof(_tempuri__HasWarningsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasWarningsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasWarningsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasWarningsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasWarningsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasWarningsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasWarningsResponse(soap, tag ? tag : "tempuri:HasWarningsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasWarningsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasWarningsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasWarningsResponse * SOAP_FMAC4 soap_get__tempuri__HasWarningsResponse(struct soap *soap, _tempuri__HasWarningsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasWarningsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasWarnings::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__HasWarnings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__HasWarnings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasWarnings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasWarnings(struct soap *soap, const char *tag, int id, const _tempuri__HasWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasWarnings), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasWarnings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasWarnings(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasWarnings * SOAP_FMAC4 soap_in__tempuri__HasWarnings(struct soap *soap, const char *tag, _tempuri__HasWarnings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasWarnings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasWarnings, sizeof(_tempuri__HasWarnings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasWarnings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasWarnings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasWarnings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasWarnings, SOAP_TYPE__tempuri__HasWarnings, sizeof(_tempuri__HasWarnings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasWarnings * SOAP_FMAC2 soap_instantiate__tempuri__HasWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasWarnings *p;
	size_t k = sizeof(_tempuri__HasWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasWarnings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasWarnings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasWarnings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasWarnings(soap, tag ? tag : "tempuri:HasWarnings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasWarnings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasWarnings(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasWarnings * SOAP_FMAC4 soap_get__tempuri__HasWarnings(struct soap *soap, _tempuri__HasWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetErrorsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetErrorsResponse::GetErrorsResult = NULL;
}

void _tempuri__GetErrorsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetErrorsResponse::GetErrorsResult);
#endif
}

int _tempuri__GetErrorsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetErrorsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetErrorsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetErrorsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetErrorsResponse), type))
		return soap->error;
	if (a->GetErrorsResult)
		soap_element_result(soap, "tempuri:GetErrorsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetErrorsResult", -1, &a->_tempuri__GetErrorsResponse::GetErrorsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetErrorsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetErrorsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetErrorsResponse * SOAP_FMAC4 soap_in__tempuri__GetErrorsResponse(struct soap *soap, const char *tag, _tempuri__GetErrorsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetErrorsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetErrorsResponse, sizeof(_tempuri__GetErrorsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetErrorsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetErrorsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetErrorsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetErrorsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetErrorsResult", &a->_tempuri__GetErrorsResponse::GetErrorsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetErrorsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetErrorsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetErrorsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetErrorsResponse, SOAP_TYPE__tempuri__GetErrorsResponse, sizeof(_tempuri__GetErrorsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetErrorsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetErrorsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetErrorsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetErrorsResponse *p;
	size_t k = sizeof(_tempuri__GetErrorsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetErrorsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetErrorsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetErrorsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetErrorsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetErrorsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetErrorsResponse(soap, tag ? tag : "tempuri:GetErrorsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetErrorsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetErrorsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetErrorsResponse * SOAP_FMAC4 soap_get__tempuri__GetErrorsResponse(struct soap *soap, _tempuri__GetErrorsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetErrorsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetErrors::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetErrors::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetErrors::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetErrors(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetErrors(struct soap *soap, const char *tag, int id, const _tempuri__GetErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetErrors), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetErrors::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetErrors(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetErrors * SOAP_FMAC4 soap_in__tempuri__GetErrors(struct soap *soap, const char *tag, _tempuri__GetErrors *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetErrors*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetErrors, sizeof(_tempuri__GetErrors), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetErrors)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetErrors *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetErrors *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetErrors, SOAP_TYPE__tempuri__GetErrors, sizeof(_tempuri__GetErrors), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetErrors * SOAP_FMAC2 soap_instantiate__tempuri__GetErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetErrors *p;
	size_t k = sizeof(_tempuri__GetErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetErrors);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetErrors, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetErrors::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetErrors(soap, tag ? tag : "tempuri:GetErrors", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetErrors::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetErrors(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetErrors * SOAP_FMAC4 soap_get__tempuri__GetErrors(struct soap *soap, _tempuri__GetErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasErrorsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__HasErrorsResponse::HasErrorsResult = NULL;
}

void _tempuri__HasErrorsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__HasErrorsResponse::HasErrorsResult);
#endif
}

int _tempuri__HasErrorsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasErrorsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasErrorsResponse(struct soap *soap, const char *tag, int id, const _tempuri__HasErrorsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasErrorsResponse), type))
		return soap->error;
	if (a->HasErrorsResult)
		soap_element_result(soap, "tempuri:HasErrorsResult");
	if (soap_out_PointerTobool(soap, "tempuri:HasErrorsResult", -1, &a->_tempuri__HasErrorsResponse::HasErrorsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasErrorsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasErrorsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasErrorsResponse * SOAP_FMAC4 soap_in__tempuri__HasErrorsResponse(struct soap *soap, const char *tag, _tempuri__HasErrorsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasErrorsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasErrorsResponse, sizeof(_tempuri__HasErrorsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasErrorsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasErrorsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HasErrorsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HasErrorsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:HasErrorsResult", &a->_tempuri__HasErrorsResponse::HasErrorsResult, "xsd:boolean"))
				{	soap_flag_HasErrorsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:HasErrorsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasErrorsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasErrorsResponse, SOAP_TYPE__tempuri__HasErrorsResponse, sizeof(_tempuri__HasErrorsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasErrorsResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasErrorsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasErrorsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasErrorsResponse *p;
	size_t k = sizeof(_tempuri__HasErrorsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasErrorsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasErrorsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasErrorsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasErrorsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasErrorsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasErrorsResponse(soap, tag ? tag : "tempuri:HasErrorsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasErrorsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasErrorsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasErrorsResponse * SOAP_FMAC4 soap_get__tempuri__HasErrorsResponse(struct soap *soap, _tempuri__HasErrorsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasErrorsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasErrors::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__HasErrors::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__HasErrors::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasErrors(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasErrors(struct soap *soap, const char *tag, int id, const _tempuri__HasErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasErrors), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasErrors::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasErrors(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasErrors * SOAP_FMAC4 soap_in__tempuri__HasErrors(struct soap *soap, const char *tag, _tempuri__HasErrors *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasErrors*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasErrors, sizeof(_tempuri__HasErrors), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasErrors)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasErrors *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasErrors *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasErrors, SOAP_TYPE__tempuri__HasErrors, sizeof(_tempuri__HasErrors), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasErrors * SOAP_FMAC2 soap_instantiate__tempuri__HasErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasErrors *p;
	size_t k = sizeof(_tempuri__HasErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasErrors);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasErrors, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasErrors::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasErrors(soap, tag ? tag : "tempuri:HasErrors", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasErrors::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasErrors(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasErrors * SOAP_FMAC4 soap_get__tempuri__HasErrors(struct soap *soap, _tempuri__HasErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetMessageResponse::GetMessageResult = NULL;
}

void _tempuri__GetMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetMessageResponse::GetMessageResult);
#endif
}

int _tempuri__GetMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetMessageResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetMessageResponse), type))
		return soap->error;
	if (a->GetMessageResult)
		soap_element_result(soap, "tempuri:GetMessageResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetMessageResult", -1, &a->_tempuri__GetMessageResponse::GetMessageResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetMessageResponse * SOAP_FMAC4 soap_in__tempuri__GetMessageResponse(struct soap *soap, const char *tag, _tempuri__GetMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetMessageResponse, sizeof(_tempuri__GetMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMessageResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMessageResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetMessageResult", &a->_tempuri__GetMessageResponse::GetMessageResult, "arr:ArrayOfstring"))
				{	soap_flag_GetMessageResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetMessageResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetMessageResponse, SOAP_TYPE__tempuri__GetMessageResponse, sizeof(_tempuri__GetMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetMessageResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetMessageResponse *p;
	size_t k = sizeof(_tempuri__GetMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetMessageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetMessageResponse(soap, tag ? tag : "tempuri:GetMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetMessageResponse * SOAP_FMAC4 soap_get__tempuri__GetMessageResponse(struct soap *soap, _tempuri__GetMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetMessage(struct soap *soap, const char *tag, int id, const _tempuri__GetMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetMessage), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetMessage(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetMessage * SOAP_FMAC4 soap_in__tempuri__GetMessage(struct soap *soap, const char *tag, _tempuri__GetMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetMessage, sizeof(_tempuri__GetMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetMessage, SOAP_TYPE__tempuri__GetMessage, sizeof(_tempuri__GetMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetMessage * SOAP_FMAC2 soap_instantiate__tempuri__GetMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetMessage *p;
	size_t k = sizeof(_tempuri__GetMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetMessage(soap, tag ? tag : "tempuri:GetMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetMessage(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetMessage * SOAP_FMAC4 soap_get__tempuri__GetMessage(struct soap *soap, _tempuri__GetMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__HasMessageResponse::HasMessageResult = NULL;
}

void _tempuri__HasMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__HasMessageResponse::HasMessageResult);
#endif
}

int _tempuri__HasMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasMessageResponse(struct soap *soap, const char *tag, int id, const _tempuri__HasMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasMessageResponse), type))
		return soap->error;
	if (a->HasMessageResult)
		soap_element_result(soap, "tempuri:HasMessageResult");
	if (soap_out_PointerTobool(soap, "tempuri:HasMessageResult", -1, &a->_tempuri__HasMessageResponse::HasMessageResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasMessageResponse * SOAP_FMAC4 soap_in__tempuri__HasMessageResponse(struct soap *soap, const char *tag, _tempuri__HasMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasMessageResponse, sizeof(_tempuri__HasMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HasMessageResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HasMessageResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:HasMessageResult", &a->_tempuri__HasMessageResponse::HasMessageResult, "xsd:boolean"))
				{	soap_flag_HasMessageResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:HasMessageResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasMessageResponse, SOAP_TYPE__tempuri__HasMessageResponse, sizeof(_tempuri__HasMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasMessageResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasMessageResponse *p;
	size_t k = sizeof(_tempuri__HasMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasMessageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasMessageResponse(soap, tag ? tag : "tempuri:HasMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasMessageResponse * SOAP_FMAC4 soap_get__tempuri__HasMessageResponse(struct soap *soap, _tempuri__HasMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__HasMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__HasMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__HasMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__HasMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__HasMessage(struct soap *soap, const char *tag, int id, const _tempuri__HasMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__HasMessage), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__HasMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__HasMessage(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__HasMessage * SOAP_FMAC4 soap_in__tempuri__HasMessage(struct soap *soap, const char *tag, _tempuri__HasMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__HasMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__HasMessage, sizeof(_tempuri__HasMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__HasMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__HasMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__HasMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__HasMessage, SOAP_TYPE__tempuri__HasMessage, sizeof(_tempuri__HasMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__HasMessage * SOAP_FMAC2 soap_instantiate__tempuri__HasMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__HasMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__HasMessage *p;
	size_t k = sizeof(_tempuri__HasMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__HasMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__HasMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__HasMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__HasMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__HasMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__HasMessage(soap, tag ? tag : "tempuri:HasMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__HasMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__HasMessage(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__HasMessage * SOAP_FMAC4 soap_get__tempuri__HasMessage(struct soap *soap, _tempuri__HasMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__HasMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__IsSamplePlateTrayInResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__IsSamplePlateTrayInResponse::IsSamplePlateTrayInResult = NULL;
}

void _tempuri__IsSamplePlateTrayInResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__IsSamplePlateTrayInResponse::IsSamplePlateTrayInResult);
#endif
}

int _tempuri__IsSamplePlateTrayInResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__IsSamplePlateTrayInResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__IsSamplePlateTrayInResponse(struct soap *soap, const char *tag, int id, const _tempuri__IsSamplePlateTrayInResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse), type))
		return soap->error;
	if (a->IsSamplePlateTrayInResult)
		soap_element_result(soap, "tempuri:IsSamplePlateTrayInResult");
	if (soap_out_PointerToint(soap, "tempuri:IsSamplePlateTrayInResult", -1, &a->_tempuri__IsSamplePlateTrayInResponse::IsSamplePlateTrayInResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__IsSamplePlateTrayInResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__IsSamplePlateTrayInResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayInResponse * SOAP_FMAC4 soap_in__tempuri__IsSamplePlateTrayInResponse(struct soap *soap, const char *tag, _tempuri__IsSamplePlateTrayInResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__IsSamplePlateTrayInResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse, sizeof(_tempuri__IsSamplePlateTrayInResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__IsSamplePlateTrayInResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IsSamplePlateTrayInResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IsSamplePlateTrayInResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:IsSamplePlateTrayInResult", &a->_tempuri__IsSamplePlateTrayInResponse::IsSamplePlateTrayInResult, "xsd:int"))
				{	soap_flag_IsSamplePlateTrayInResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:IsSamplePlateTrayInResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__IsSamplePlateTrayInResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse, SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse, sizeof(_tempuri__IsSamplePlateTrayInResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__IsSamplePlateTrayInResponse * SOAP_FMAC2 soap_instantiate__tempuri__IsSamplePlateTrayInResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__IsSamplePlateTrayInResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__IsSamplePlateTrayInResponse *p;
	size_t k = sizeof(_tempuri__IsSamplePlateTrayInResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__IsSamplePlateTrayInResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__IsSamplePlateTrayInResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__IsSamplePlateTrayInResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__IsSamplePlateTrayInResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__IsSamplePlateTrayInResponse(soap, tag ? tag : "tempuri:IsSamplePlateTrayInResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__IsSamplePlateTrayInResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__IsSamplePlateTrayInResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayInResponse * SOAP_FMAC4 soap_get__tempuri__IsSamplePlateTrayInResponse(struct soap *soap, _tempuri__IsSamplePlateTrayInResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__IsSamplePlateTrayInResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__IsSamplePlateTrayIn::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__IsSamplePlateTrayIn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__IsSamplePlateTrayIn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__IsSamplePlateTrayIn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__IsSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const _tempuri__IsSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__IsSamplePlateTrayIn), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__IsSamplePlateTrayIn::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__IsSamplePlateTrayIn(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayIn * SOAP_FMAC4 soap_in__tempuri__IsSamplePlateTrayIn(struct soap *soap, const char *tag, _tempuri__IsSamplePlateTrayIn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__IsSamplePlateTrayIn*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, sizeof(_tempuri__IsSamplePlateTrayIn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__IsSamplePlateTrayIn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__IsSamplePlateTrayIn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__IsSamplePlateTrayIn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, sizeof(_tempuri__IsSamplePlateTrayIn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate__tempuri__IsSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__IsSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__IsSamplePlateTrayIn *p;
	size_t k = sizeof(_tempuri__IsSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__IsSamplePlateTrayIn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__IsSamplePlateTrayIn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__IsSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__IsSamplePlateTrayIn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__IsSamplePlateTrayIn(soap, tag ? tag : "tempuri:IsSamplePlateTrayIn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__IsSamplePlateTrayIn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__IsSamplePlateTrayIn(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayIn * SOAP_FMAC4 soap_get__tempuri__IsSamplePlateTrayIn(struct soap *soap, _tempuri__IsSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__IsSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__IsChipDockedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__IsChipDockedResponse::IsChipDockedResult = NULL;
}

void _tempuri__IsChipDockedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__IsChipDockedResponse::IsChipDockedResult);
#endif
}

int _tempuri__IsChipDockedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__IsChipDockedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__IsChipDockedResponse(struct soap *soap, const char *tag, int id, const _tempuri__IsChipDockedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__IsChipDockedResponse), type))
		return soap->error;
	if (a->IsChipDockedResult)
		soap_element_result(soap, "tempuri:IsChipDockedResult");
	if (soap_out_PointerToint(soap, "tempuri:IsChipDockedResult", -1, &a->_tempuri__IsChipDockedResponse::IsChipDockedResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__IsChipDockedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__IsChipDockedResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__IsChipDockedResponse * SOAP_FMAC4 soap_in__tempuri__IsChipDockedResponse(struct soap *soap, const char *tag, _tempuri__IsChipDockedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__IsChipDockedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__IsChipDockedResponse, sizeof(_tempuri__IsChipDockedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__IsChipDockedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__IsChipDockedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IsChipDockedResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IsChipDockedResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:IsChipDockedResult", &a->_tempuri__IsChipDockedResponse::IsChipDockedResult, "xsd:int"))
				{	soap_flag_IsChipDockedResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:IsChipDockedResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__IsChipDockedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__IsChipDockedResponse, SOAP_TYPE__tempuri__IsChipDockedResponse, sizeof(_tempuri__IsChipDockedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__IsChipDockedResponse * SOAP_FMAC2 soap_instantiate__tempuri__IsChipDockedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__IsChipDockedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__IsChipDockedResponse *p;
	size_t k = sizeof(_tempuri__IsChipDockedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__IsChipDockedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__IsChipDockedResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__IsChipDockedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__IsChipDockedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__IsChipDockedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__IsChipDockedResponse(soap, tag ? tag : "tempuri:IsChipDockedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__IsChipDockedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__IsChipDockedResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__IsChipDockedResponse * SOAP_FMAC4 soap_get__tempuri__IsChipDockedResponse(struct soap *soap, _tempuri__IsChipDockedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__IsChipDockedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__IsChipDocked::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__IsChipDocked::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__IsChipDocked::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__IsChipDocked(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__IsChipDocked(struct soap *soap, const char *tag, int id, const _tempuri__IsChipDocked *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__IsChipDocked), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__IsChipDocked::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__IsChipDocked(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__IsChipDocked * SOAP_FMAC4 soap_in__tempuri__IsChipDocked(struct soap *soap, const char *tag, _tempuri__IsChipDocked *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__IsChipDocked*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__IsChipDocked, sizeof(_tempuri__IsChipDocked), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__IsChipDocked)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__IsChipDocked *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__IsChipDocked *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__IsChipDocked, SOAP_TYPE__tempuri__IsChipDocked, sizeof(_tempuri__IsChipDocked), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__IsChipDocked * SOAP_FMAC2 soap_instantiate__tempuri__IsChipDocked(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__IsChipDocked(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__IsChipDocked *p;
	size_t k = sizeof(_tempuri__IsChipDocked);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__IsChipDocked, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__IsChipDocked);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__IsChipDocked, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__IsChipDocked location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__IsChipDocked::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__IsChipDocked(soap, tag ? tag : "tempuri:IsChipDocked", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__IsChipDocked::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__IsChipDocked(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__IsChipDocked * SOAP_FMAC4 soap_get__tempuri__IsChipDocked(struct soap *soap, _tempuri__IsChipDocked *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__IsChipDocked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetOperationModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetOperationModeResponse::GetOperationModeResult = NULL;
}

void _tempuri__GetOperationModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__GetOperationModeResponse::GetOperationModeResult);
#endif
}

int _tempuri__GetOperationModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetOperationModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetOperationModeResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetOperationModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetOperationModeResponse), type))
		return soap->error;
	if (a->GetOperationModeResult)
		soap_element_result(soap, "tempuri:GetOperationModeResult");
	if (soap_out_PointerToint(soap, "tempuri:GetOperationModeResult", -1, &a->_tempuri__GetOperationModeResponse::GetOperationModeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetOperationModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetOperationModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetOperationModeResponse * SOAP_FMAC4 soap_in__tempuri__GetOperationModeResponse(struct soap *soap, const char *tag, _tempuri__GetOperationModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetOperationModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetOperationModeResponse, sizeof(_tempuri__GetOperationModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetOperationModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetOperationModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetOperationModeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOperationModeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:GetOperationModeResult", &a->_tempuri__GetOperationModeResponse::GetOperationModeResult, "xsd:int"))
				{	soap_flag_GetOperationModeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetOperationModeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetOperationModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetOperationModeResponse, SOAP_TYPE__tempuri__GetOperationModeResponse, sizeof(_tempuri__GetOperationModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetOperationModeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetOperationModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetOperationModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetOperationModeResponse *p;
	size_t k = sizeof(_tempuri__GetOperationModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetOperationModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetOperationModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetOperationModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetOperationModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetOperationModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetOperationModeResponse(soap, tag ? tag : "tempuri:GetOperationModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetOperationModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetOperationModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetOperationModeResponse * SOAP_FMAC4 soap_get__tempuri__GetOperationModeResponse(struct soap *soap, _tempuri__GetOperationModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetOperationModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetOperationMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetOperationMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetOperationMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetOperationMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetOperationMode(struct soap *soap, const char *tag, int id, const _tempuri__GetOperationMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetOperationMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetOperationMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetOperationMode(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetOperationMode * SOAP_FMAC4 soap_in__tempuri__GetOperationMode(struct soap *soap, const char *tag, _tempuri__GetOperationMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetOperationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetOperationMode, sizeof(_tempuri__GetOperationMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetOperationMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetOperationMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetOperationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetOperationMode, SOAP_TYPE__tempuri__GetOperationMode, sizeof(_tempuri__GetOperationMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetOperationMode * SOAP_FMAC2 soap_instantiate__tempuri__GetOperationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetOperationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetOperationMode *p;
	size_t k = sizeof(_tempuri__GetOperationMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetOperationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetOperationMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetOperationMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetOperationMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetOperationMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetOperationMode(soap, tag ? tag : "tempuri:GetOperationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetOperationMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetOperationMode(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetOperationMode * SOAP_FMAC4 soap_get__tempuri__GetOperationMode(struct soap *soap, _tempuri__GetOperationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetOperationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__RunMaintenanceProcedureResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__RunMaintenanceProcedureResponse::RunMaintenanceProcedureResult = NULL;
}

void _tempuri__RunMaintenanceProcedureResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__RunMaintenanceProcedureResponse::RunMaintenanceProcedureResult);
#endif
}

int _tempuri__RunMaintenanceProcedureResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__RunMaintenanceProcedureResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__RunMaintenanceProcedureResponse(struct soap *soap, const char *tag, int id, const _tempuri__RunMaintenanceProcedureResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse), type))
		return soap->error;
	if (a->RunMaintenanceProcedureResult)
		soap_element_result(soap, "tempuri:RunMaintenanceProcedureResult");
	if (soap_out_PointerTobool(soap, "tempuri:RunMaintenanceProcedureResult", -1, &a->_tempuri__RunMaintenanceProcedureResponse::RunMaintenanceProcedureResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__RunMaintenanceProcedureResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__RunMaintenanceProcedureResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedureResponse * SOAP_FMAC4 soap_in__tempuri__RunMaintenanceProcedureResponse(struct soap *soap, const char *tag, _tempuri__RunMaintenanceProcedureResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__RunMaintenanceProcedureResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse, sizeof(_tempuri__RunMaintenanceProcedureResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__RunMaintenanceProcedureResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RunMaintenanceProcedureResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RunMaintenanceProcedureResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:RunMaintenanceProcedureResult", &a->_tempuri__RunMaintenanceProcedureResponse::RunMaintenanceProcedureResult, "xsd:boolean"))
				{	soap_flag_RunMaintenanceProcedureResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:RunMaintenanceProcedureResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__RunMaintenanceProcedureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse, SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse, sizeof(_tempuri__RunMaintenanceProcedureResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__RunMaintenanceProcedureResponse * SOAP_FMAC2 soap_instantiate__tempuri__RunMaintenanceProcedureResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__RunMaintenanceProcedureResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__RunMaintenanceProcedureResponse *p;
	size_t k = sizeof(_tempuri__RunMaintenanceProcedureResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__RunMaintenanceProcedureResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__RunMaintenanceProcedureResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__RunMaintenanceProcedureResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__RunMaintenanceProcedureResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__RunMaintenanceProcedureResponse(soap, tag ? tag : "tempuri:RunMaintenanceProcedureResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__RunMaintenanceProcedureResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__RunMaintenanceProcedureResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedureResponse * SOAP_FMAC4 soap_get__tempuri__RunMaintenanceProcedureResponse(struct soap *soap, _tempuri__RunMaintenanceProcedureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__RunMaintenanceProcedureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__RunMaintenanceProcedure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__RunMaintenanceProcedure::procedureName = NULL;
}

void _tempuri__RunMaintenanceProcedure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__RunMaintenanceProcedure::procedureName);
#endif
}

int _tempuri__RunMaintenanceProcedure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__RunMaintenanceProcedure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__RunMaintenanceProcedure(struct soap *soap, const char *tag, int id, const _tempuri__RunMaintenanceProcedure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__RunMaintenanceProcedure), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:procedureName", -1, &a->_tempuri__RunMaintenanceProcedure::procedureName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__RunMaintenanceProcedure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__RunMaintenanceProcedure(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedure * SOAP_FMAC4 soap_in__tempuri__RunMaintenanceProcedure(struct soap *soap, const char *tag, _tempuri__RunMaintenanceProcedure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__RunMaintenanceProcedure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__RunMaintenanceProcedure, sizeof(_tempuri__RunMaintenanceProcedure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__RunMaintenanceProcedure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__RunMaintenanceProcedure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_procedureName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_procedureName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:procedureName", &a->_tempuri__RunMaintenanceProcedure::procedureName, "xsd:string"))
				{	soap_flag_procedureName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__RunMaintenanceProcedure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__RunMaintenanceProcedure, SOAP_TYPE__tempuri__RunMaintenanceProcedure, sizeof(_tempuri__RunMaintenanceProcedure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate__tempuri__RunMaintenanceProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__RunMaintenanceProcedure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__RunMaintenanceProcedure *p;
	size_t k = sizeof(_tempuri__RunMaintenanceProcedure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__RunMaintenanceProcedure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__RunMaintenanceProcedure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__RunMaintenanceProcedure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__RunMaintenanceProcedure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__RunMaintenanceProcedure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__RunMaintenanceProcedure(soap, tag ? tag : "tempuri:RunMaintenanceProcedure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__RunMaintenanceProcedure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__RunMaintenanceProcedure(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedure * SOAP_FMAC4 soap_get__tempuri__RunMaintenanceProcedure(struct soap *soap, _tempuri__RunMaintenanceProcedure *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__RunMaintenanceProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMaintenanceProceduresResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfMaintenanceProceduresResponse::GetNamesOfMaintenanceProceduresResult = NULL;
}

void _tempuri__GetNamesOfMaintenanceProceduresResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetNamesOfMaintenanceProceduresResponse::GetNamesOfMaintenanceProceduresResult);
#endif
}

int _tempuri__GetNamesOfMaintenanceProceduresResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMaintenanceProceduresResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse), type))
		return soap->error;
	if (a->GetNamesOfMaintenanceProceduresResult)
		soap_element_result(soap, "tempuri:GetNamesOfMaintenanceProceduresResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMaintenanceProceduresResult", -1, &a->_tempuri__GetNamesOfMaintenanceProceduresResponse::GetNamesOfMaintenanceProceduresResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMaintenanceProceduresResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProceduresResponse * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap *soap, const char *tag, _tempuri__GetNamesOfMaintenanceProceduresResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMaintenanceProceduresResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse, sizeof(_tempuri__GetNamesOfMaintenanceProceduresResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMaintenanceProceduresResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNamesOfMaintenanceProceduresResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNamesOfMaintenanceProceduresResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMaintenanceProceduresResult", &a->_tempuri__GetNamesOfMaintenanceProceduresResponse::GetNamesOfMaintenanceProceduresResult, "arr:ArrayOfstring"))
				{	soap_flag_GetNamesOfMaintenanceProceduresResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNamesOfMaintenanceProceduresResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMaintenanceProceduresResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse, sizeof(_tempuri__GetNamesOfMaintenanceProceduresResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMaintenanceProceduresResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMaintenanceProceduresResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMaintenanceProceduresResponse *p;
	size_t k = sizeof(_tempuri__GetNamesOfMaintenanceProceduresResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMaintenanceProceduresResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMaintenanceProceduresResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMaintenanceProceduresResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMaintenanceProceduresResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, tag ? tag : "tempuri:GetNamesOfMaintenanceProceduresResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMaintenanceProceduresResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProceduresResponse * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap *soap, _tempuri__GetNamesOfMaintenanceProceduresResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMaintenanceProceduresResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMaintenanceProcedures::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetNamesOfMaintenanceProcedures::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetNamesOfMaintenanceProcedures::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMaintenanceProcedures(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMaintenanceProcedures::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMaintenanceProcedures(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, _tempuri__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMaintenanceProcedures*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, sizeof(_tempuri__GetNamesOfMaintenanceProcedures), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMaintenanceProcedures *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMaintenanceProcedures *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, sizeof(_tempuri__GetNamesOfMaintenanceProcedures), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMaintenanceProcedures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMaintenanceProcedures *p;
	size_t k = sizeof(_tempuri__GetNamesOfMaintenanceProcedures);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMaintenanceProcedures);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMaintenanceProcedures, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMaintenanceProcedures location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMaintenanceProcedures::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMaintenanceProcedures(soap, tag ? tag : "tempuri:GetNamesOfMaintenanceProcedures", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMaintenanceProcedures::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMaintenanceProcedures(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, _tempuri__GetNamesOfMaintenanceProcedures *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMaintenanceProcedures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetStandbyAfterFinishResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetStandbyAfterFinishResponse::GetStandbyAfterFinishResult = NULL;
}

void _tempuri__GetStandbyAfterFinishResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__GetStandbyAfterFinishResponse::GetStandbyAfterFinishResult);
#endif
}

int _tempuri__GetStandbyAfterFinishResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetStandbyAfterFinishResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetStandbyAfterFinishResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetStandbyAfterFinishResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse), type))
		return soap->error;
	if (a->GetStandbyAfterFinishResult)
		soap_element_result(soap, "tempuri:GetStandbyAfterFinishResult");
	if (soap_out_PointerTobool(soap, "tempuri:GetStandbyAfterFinishResult", -1, &a->_tempuri__GetStandbyAfterFinishResponse::GetStandbyAfterFinishResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetStandbyAfterFinishResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetStandbyAfterFinishResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinishResponse * SOAP_FMAC4 soap_in__tempuri__GetStandbyAfterFinishResponse(struct soap *soap, const char *tag, _tempuri__GetStandbyAfterFinishResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetStandbyAfterFinishResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse, sizeof(_tempuri__GetStandbyAfterFinishResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetStandbyAfterFinishResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetStandbyAfterFinishResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStandbyAfterFinishResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:GetStandbyAfterFinishResult", &a->_tempuri__GetStandbyAfterFinishResponse::GetStandbyAfterFinishResult, "xsd:boolean"))
				{	soap_flag_GetStandbyAfterFinishResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetStandbyAfterFinishResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetStandbyAfterFinishResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse, SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse, sizeof(_tempuri__GetStandbyAfterFinishResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetStandbyAfterFinishResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetStandbyAfterFinishResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetStandbyAfterFinishResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetStandbyAfterFinishResponse *p;
	size_t k = sizeof(_tempuri__GetStandbyAfterFinishResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetStandbyAfterFinishResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetStandbyAfterFinishResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetStandbyAfterFinishResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetStandbyAfterFinishResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetStandbyAfterFinishResponse(soap, tag ? tag : "tempuri:GetStandbyAfterFinishResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetStandbyAfterFinishResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetStandbyAfterFinishResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinishResponse * SOAP_FMAC4 soap_get__tempuri__GetStandbyAfterFinishResponse(struct soap *soap, _tempuri__GetStandbyAfterFinishResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetStandbyAfterFinishResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetStandbyAfterFinish::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetStandbyAfterFinish::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetStandbyAfterFinish::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetStandbyAfterFinish(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const _tempuri__GetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetStandbyAfterFinish), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetStandbyAfterFinish::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetStandbyAfterFinish(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinish * SOAP_FMAC4 soap_in__tempuri__GetStandbyAfterFinish(struct soap *soap, const char *tag, _tempuri__GetStandbyAfterFinish *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetStandbyAfterFinish*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetStandbyAfterFinish, sizeof(_tempuri__GetStandbyAfterFinish), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetStandbyAfterFinish)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetStandbyAfterFinish *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetStandbyAfterFinish *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetStandbyAfterFinish, SOAP_TYPE__tempuri__GetStandbyAfterFinish, sizeof(_tempuri__GetStandbyAfterFinish), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate__tempuri__GetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetStandbyAfterFinish *p;
	size_t k = sizeof(_tempuri__GetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetStandbyAfterFinish);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetStandbyAfterFinish, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetStandbyAfterFinish::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetStandbyAfterFinish(soap, tag ? tag : "tempuri:GetStandbyAfterFinish", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetStandbyAfterFinish::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetStandbyAfterFinish(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinish * SOAP_FMAC4 soap_get__tempuri__GetStandbyAfterFinish(struct soap *soap, _tempuri__GetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetStandbyAfterFinishResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SetStandbyAfterFinishResponse::SetStandbyAfterFinishResult = NULL;
}

void _tempuri__SetStandbyAfterFinishResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__SetStandbyAfterFinishResponse::SetStandbyAfterFinishResult);
#endif
}

int _tempuri__SetStandbyAfterFinishResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetStandbyAfterFinishResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetStandbyAfterFinishResponse(struct soap *soap, const char *tag, int id, const _tempuri__SetStandbyAfterFinishResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse), type))
		return soap->error;
	if (a->SetStandbyAfterFinishResult)
		soap_element_result(soap, "tempuri:SetStandbyAfterFinishResult");
	if (soap_out_PointerTobool(soap, "tempuri:SetStandbyAfterFinishResult", -1, &a->_tempuri__SetStandbyAfterFinishResponse::SetStandbyAfterFinishResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetStandbyAfterFinishResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SetStandbyAfterFinishResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinishResponse * SOAP_FMAC4 soap_in__tempuri__SetStandbyAfterFinishResponse(struct soap *soap, const char *tag, _tempuri__SetStandbyAfterFinishResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetStandbyAfterFinishResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse, sizeof(_tempuri__SetStandbyAfterFinishResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetStandbyAfterFinishResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetStandbyAfterFinishResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetStandbyAfterFinishResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:SetStandbyAfterFinishResult", &a->_tempuri__SetStandbyAfterFinishResponse::SetStandbyAfterFinishResult, "xsd:boolean"))
				{	soap_flag_SetStandbyAfterFinishResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:SetStandbyAfterFinishResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetStandbyAfterFinishResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse, SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse, sizeof(_tempuri__SetStandbyAfterFinishResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetStandbyAfterFinishResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetStandbyAfterFinishResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetStandbyAfterFinishResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetStandbyAfterFinishResponse *p;
	size_t k = sizeof(_tempuri__SetStandbyAfterFinishResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SetStandbyAfterFinishResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SetStandbyAfterFinishResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetStandbyAfterFinishResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SetStandbyAfterFinishResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetStandbyAfterFinishResponse(soap, tag ? tag : "tempuri:SetStandbyAfterFinishResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetStandbyAfterFinishResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetStandbyAfterFinishResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinishResponse * SOAP_FMAC4 soap_get__tempuri__SetStandbyAfterFinishResponse(struct soap *soap, _tempuri__SetStandbyAfterFinishResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetStandbyAfterFinishResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetStandbyAfterFinish::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SetStandbyAfterFinish::goToStandby = NULL;
}

void _tempuri__SetStandbyAfterFinish::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__SetStandbyAfterFinish::goToStandby);
#endif
}

int _tempuri__SetStandbyAfterFinish::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetStandbyAfterFinish(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const _tempuri__SetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetStandbyAfterFinish), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tempuri:goToStandby", -1, &a->_tempuri__SetStandbyAfterFinish::goToStandby, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetStandbyAfterFinish::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SetStandbyAfterFinish(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinish * SOAP_FMAC4 soap_in__tempuri__SetStandbyAfterFinish(struct soap *soap, const char *tag, _tempuri__SetStandbyAfterFinish *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetStandbyAfterFinish*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetStandbyAfterFinish, sizeof(_tempuri__SetStandbyAfterFinish), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetStandbyAfterFinish)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetStandbyAfterFinish *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_goToStandby1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_goToStandby1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:goToStandby", &a->_tempuri__SetStandbyAfterFinish::goToStandby, "xsd:boolean"))
				{	soap_flag_goToStandby1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetStandbyAfterFinish *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetStandbyAfterFinish, SOAP_TYPE__tempuri__SetStandbyAfterFinish, sizeof(_tempuri__SetStandbyAfterFinish), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate__tempuri__SetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetStandbyAfterFinish *p;
	size_t k = sizeof(_tempuri__SetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SetStandbyAfterFinish);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SetStandbyAfterFinish, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SetStandbyAfterFinish::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetStandbyAfterFinish(soap, tag ? tag : "tempuri:SetStandbyAfterFinish", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetStandbyAfterFinish::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetStandbyAfterFinish(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinish * SOAP_FMAC4 soap_get__tempuri__SetStandbyAfterFinish(struct soap *soap, _tempuri__SetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LeaveStandbyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LeaveStandbyResponse::LeaveStandbyResult = NULL;
}

void _tempuri__LeaveStandbyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__LeaveStandbyResponse::LeaveStandbyResult);
#endif
}

int _tempuri__LeaveStandbyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LeaveStandbyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LeaveStandbyResponse(struct soap *soap, const char *tag, int id, const _tempuri__LeaveStandbyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LeaveStandbyResponse), type))
		return soap->error;
	if (a->LeaveStandbyResult)
		soap_element_result(soap, "tempuri:LeaveStandbyResult");
	if (soap_out_PointerTobool(soap, "tempuri:LeaveStandbyResult", -1, &a->_tempuri__LeaveStandbyResponse::LeaveStandbyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LeaveStandbyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__LeaveStandbyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LeaveStandbyResponse * SOAP_FMAC4 soap_in__tempuri__LeaveStandbyResponse(struct soap *soap, const char *tag, _tempuri__LeaveStandbyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LeaveStandbyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LeaveStandbyResponse, sizeof(_tempuri__LeaveStandbyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LeaveStandbyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LeaveStandbyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LeaveStandbyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LeaveStandbyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:LeaveStandbyResult", &a->_tempuri__LeaveStandbyResponse::LeaveStandbyResult, "xsd:boolean"))
				{	soap_flag_LeaveStandbyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LeaveStandbyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LeaveStandbyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LeaveStandbyResponse, SOAP_TYPE__tempuri__LeaveStandbyResponse, sizeof(_tempuri__LeaveStandbyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LeaveStandbyResponse * SOAP_FMAC2 soap_instantiate__tempuri__LeaveStandbyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LeaveStandbyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LeaveStandbyResponse *p;
	size_t k = sizeof(_tempuri__LeaveStandbyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LeaveStandbyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LeaveStandbyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LeaveStandbyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LeaveStandbyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LeaveStandbyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LeaveStandbyResponse(soap, tag ? tag : "tempuri:LeaveStandbyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LeaveStandbyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LeaveStandbyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LeaveStandbyResponse * SOAP_FMAC4 soap_get__tempuri__LeaveStandbyResponse(struct soap *soap, _tempuri__LeaveStandbyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LeaveStandbyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LeaveStandby::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__LeaveStandby::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__LeaveStandby::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LeaveStandby(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LeaveStandby(struct soap *soap, const char *tag, int id, const _tempuri__LeaveStandby *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LeaveStandby), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LeaveStandby::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__LeaveStandby(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LeaveStandby * SOAP_FMAC4 soap_in__tempuri__LeaveStandby(struct soap *soap, const char *tag, _tempuri__LeaveStandby *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LeaveStandby*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LeaveStandby, sizeof(_tempuri__LeaveStandby), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LeaveStandby)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LeaveStandby *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LeaveStandby *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LeaveStandby, SOAP_TYPE__tempuri__LeaveStandby, sizeof(_tempuri__LeaveStandby), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LeaveStandby * SOAP_FMAC2 soap_instantiate__tempuri__LeaveStandby(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LeaveStandby(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LeaveStandby *p;
	size_t k = sizeof(_tempuri__LeaveStandby);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LeaveStandby, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LeaveStandby);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LeaveStandby, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LeaveStandby location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LeaveStandby::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LeaveStandby(soap, tag ? tag : "tempuri:LeaveStandby", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LeaveStandby::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LeaveStandby(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LeaveStandby * SOAP_FMAC4 soap_get__tempuri__LeaveStandby(struct soap *soap, _tempuri__LeaveStandby *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LeaveStandby(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AbortScriptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AbortScriptResponse::AbortScriptResult = NULL;
}

void _tempuri__AbortScriptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__AbortScriptResponse::AbortScriptResult);
#endif
}

int _tempuri__AbortScriptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AbortScriptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AbortScriptResponse(struct soap *soap, const char *tag, int id, const _tempuri__AbortScriptResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AbortScriptResponse), type))
		return soap->error;
	if (a->AbortScriptResult)
		soap_element_result(soap, "tempuri:AbortScriptResult");
	if (soap_out_PointerTobool(soap, "tempuri:AbortScriptResult", -1, &a->_tempuri__AbortScriptResponse::AbortScriptResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AbortScriptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__AbortScriptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AbortScriptResponse * SOAP_FMAC4 soap_in__tempuri__AbortScriptResponse(struct soap *soap, const char *tag, _tempuri__AbortScriptResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AbortScriptResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AbortScriptResponse, sizeof(_tempuri__AbortScriptResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AbortScriptResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AbortScriptResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AbortScriptResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AbortScriptResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:AbortScriptResult", &a->_tempuri__AbortScriptResponse::AbortScriptResult, "xsd:boolean"))
				{	soap_flag_AbortScriptResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AbortScriptResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AbortScriptResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AbortScriptResponse, SOAP_TYPE__tempuri__AbortScriptResponse, sizeof(_tempuri__AbortScriptResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AbortScriptResponse * SOAP_FMAC2 soap_instantiate__tempuri__AbortScriptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AbortScriptResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AbortScriptResponse *p;
	size_t k = sizeof(_tempuri__AbortScriptResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AbortScriptResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AbortScriptResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AbortScriptResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AbortScriptResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AbortScriptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AbortScriptResponse(soap, tag ? tag : "tempuri:AbortScriptResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AbortScriptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AbortScriptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AbortScriptResponse * SOAP_FMAC4 soap_get__tempuri__AbortScriptResponse(struct soap *soap, _tempuri__AbortScriptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AbortScriptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AbortScript::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__AbortScript::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__AbortScript::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AbortScript(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AbortScript(struct soap *soap, const char *tag, int id, const _tempuri__AbortScript *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AbortScript), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AbortScript::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__AbortScript(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AbortScript * SOAP_FMAC4 soap_in__tempuri__AbortScript(struct soap *soap, const char *tag, _tempuri__AbortScript *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AbortScript*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AbortScript, sizeof(_tempuri__AbortScript), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AbortScript)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AbortScript *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AbortScript *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AbortScript, SOAP_TYPE__tempuri__AbortScript, sizeof(_tempuri__AbortScript), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AbortScript * SOAP_FMAC2 soap_instantiate__tempuri__AbortScript(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AbortScript(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AbortScript *p;
	size_t k = sizeof(_tempuri__AbortScript);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AbortScript, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AbortScript);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AbortScript, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AbortScript location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AbortScript::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AbortScript(soap, tag ? tag : "tempuri:AbortScript", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AbortScript::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AbortScript(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AbortScript * SOAP_FMAC4 soap_get__tempuri__AbortScript(struct soap *soap, _tempuri__AbortScript *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AbortScript(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ResetRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ResetRunsetResponse::ResetRunsetResult = NULL;
}

void _tempuri__ResetRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__ResetRunsetResponse::ResetRunsetResult);
#endif
}

int _tempuri__ResetRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ResetRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ResetRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__ResetRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ResetRunsetResponse), type))
		return soap->error;
	if (a->ResetRunsetResult)
		soap_element_result(soap, "tempuri:ResetRunsetResult");
	if (soap_out_PointerTobool(soap, "tempuri:ResetRunsetResult", -1, &a->_tempuri__ResetRunsetResponse::ResetRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ResetRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__ResetRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ResetRunsetResponse * SOAP_FMAC4 soap_in__tempuri__ResetRunsetResponse(struct soap *soap, const char *tag, _tempuri__ResetRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ResetRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ResetRunsetResponse, sizeof(_tempuri__ResetRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ResetRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ResetRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResetRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResetRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:ResetRunsetResult", &a->_tempuri__ResetRunsetResponse::ResetRunsetResult, "xsd:boolean"))
				{	soap_flag_ResetRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ResetRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ResetRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ResetRunsetResponse, SOAP_TYPE__tempuri__ResetRunsetResponse, sizeof(_tempuri__ResetRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ResetRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__ResetRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ResetRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ResetRunsetResponse *p;
	size_t k = sizeof(_tempuri__ResetRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ResetRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ResetRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ResetRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ResetRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ResetRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ResetRunsetResponse(soap, tag ? tag : "tempuri:ResetRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ResetRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ResetRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ResetRunsetResponse * SOAP_FMAC4 soap_get__tempuri__ResetRunsetResponse(struct soap *soap, _tempuri__ResetRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ResetRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ResetRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__ResetRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__ResetRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ResetRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ResetRunset(struct soap *soap, const char *tag, int id, const _tempuri__ResetRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ResetRunset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ResetRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__ResetRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ResetRunset * SOAP_FMAC4 soap_in__tempuri__ResetRunset(struct soap *soap, const char *tag, _tempuri__ResetRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ResetRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ResetRunset, sizeof(_tempuri__ResetRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ResetRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ResetRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ResetRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ResetRunset, SOAP_TYPE__tempuri__ResetRunset, sizeof(_tempuri__ResetRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ResetRunset * SOAP_FMAC2 soap_instantiate__tempuri__ResetRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ResetRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ResetRunset *p;
	size_t k = sizeof(_tempuri__ResetRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ResetRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ResetRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ResetRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ResetRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ResetRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ResetRunset(soap, tag ? tag : "tempuri:ResetRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ResetRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ResetRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ResetRunset * SOAP_FMAC4 soap_get__tempuri__ResetRunset(struct soap *soap, _tempuri__ResetRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ResetRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ResumeRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ResumeRunsetResponse::ResumeRunsetResult = NULL;
}

void _tempuri__ResumeRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__ResumeRunsetResponse::ResumeRunsetResult);
#endif
}

int _tempuri__ResumeRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ResumeRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ResumeRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__ResumeRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ResumeRunsetResponse), type))
		return soap->error;
	if (a->ResumeRunsetResult)
		soap_element_result(soap, "tempuri:ResumeRunsetResult");
	if (soap_out_PointerTobool(soap, "tempuri:ResumeRunsetResult", -1, &a->_tempuri__ResumeRunsetResponse::ResumeRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ResumeRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__ResumeRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ResumeRunsetResponse * SOAP_FMAC4 soap_in__tempuri__ResumeRunsetResponse(struct soap *soap, const char *tag, _tempuri__ResumeRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ResumeRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ResumeRunsetResponse, sizeof(_tempuri__ResumeRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ResumeRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ResumeRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResumeRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResumeRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:ResumeRunsetResult", &a->_tempuri__ResumeRunsetResponse::ResumeRunsetResult, "xsd:boolean"))
				{	soap_flag_ResumeRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ResumeRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ResumeRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ResumeRunsetResponse, SOAP_TYPE__tempuri__ResumeRunsetResponse, sizeof(_tempuri__ResumeRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ResumeRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__ResumeRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ResumeRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ResumeRunsetResponse *p;
	size_t k = sizeof(_tempuri__ResumeRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ResumeRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ResumeRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ResumeRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ResumeRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ResumeRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ResumeRunsetResponse(soap, tag ? tag : "tempuri:ResumeRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ResumeRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ResumeRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ResumeRunsetResponse * SOAP_FMAC4 soap_get__tempuri__ResumeRunsetResponse(struct soap *soap, _tempuri__ResumeRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ResumeRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ResumeRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__ResumeRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__ResumeRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ResumeRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ResumeRunset(struct soap *soap, const char *tag, int id, const _tempuri__ResumeRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ResumeRunset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ResumeRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__ResumeRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ResumeRunset * SOAP_FMAC4 soap_in__tempuri__ResumeRunset(struct soap *soap, const char *tag, _tempuri__ResumeRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ResumeRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ResumeRunset, sizeof(_tempuri__ResumeRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ResumeRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ResumeRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ResumeRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ResumeRunset, SOAP_TYPE__tempuri__ResumeRunset, sizeof(_tempuri__ResumeRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ResumeRunset * SOAP_FMAC2 soap_instantiate__tempuri__ResumeRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ResumeRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ResumeRunset *p;
	size_t k = sizeof(_tempuri__ResumeRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ResumeRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ResumeRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ResumeRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ResumeRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ResumeRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ResumeRunset(soap, tag ? tag : "tempuri:ResumeRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ResumeRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ResumeRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ResumeRunset * SOAP_FMAC4 soap_get__tempuri__ResumeRunset(struct soap *soap, _tempuri__ResumeRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ResumeRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__PauseRunsetAfterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__PauseRunsetAfterResponse::PauseRunsetAfterResult = NULL;
}

void _tempuri__PauseRunsetAfterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__PauseRunsetAfterResponse::PauseRunsetAfterResult);
#endif
}

int _tempuri__PauseRunsetAfterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__PauseRunsetAfterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__PauseRunsetAfterResponse(struct soap *soap, const char *tag, int id, const _tempuri__PauseRunsetAfterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__PauseRunsetAfterResponse), type))
		return soap->error;
	if (a->PauseRunsetAfterResult)
		soap_element_result(soap, "tempuri:PauseRunsetAfterResult");
	if (soap_out_PointerTobool(soap, "tempuri:PauseRunsetAfterResult", -1, &a->_tempuri__PauseRunsetAfterResponse::PauseRunsetAfterResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__PauseRunsetAfterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__PauseRunsetAfterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfterResponse * SOAP_FMAC4 soap_in__tempuri__PauseRunsetAfterResponse(struct soap *soap, const char *tag, _tempuri__PauseRunsetAfterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__PauseRunsetAfterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__PauseRunsetAfterResponse, sizeof(_tempuri__PauseRunsetAfterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__PauseRunsetAfterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__PauseRunsetAfterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PauseRunsetAfterResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PauseRunsetAfterResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:PauseRunsetAfterResult", &a->_tempuri__PauseRunsetAfterResponse::PauseRunsetAfterResult, "xsd:boolean"))
				{	soap_flag_PauseRunsetAfterResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:PauseRunsetAfterResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__PauseRunsetAfterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__PauseRunsetAfterResponse, SOAP_TYPE__tempuri__PauseRunsetAfterResponse, sizeof(_tempuri__PauseRunsetAfterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__PauseRunsetAfterResponse * SOAP_FMAC2 soap_instantiate__tempuri__PauseRunsetAfterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__PauseRunsetAfterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__PauseRunsetAfterResponse *p;
	size_t k = sizeof(_tempuri__PauseRunsetAfterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__PauseRunsetAfterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__PauseRunsetAfterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__PauseRunsetAfterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__PauseRunsetAfterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__PauseRunsetAfterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__PauseRunsetAfterResponse(soap, tag ? tag : "tempuri:PauseRunsetAfterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__PauseRunsetAfterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__PauseRunsetAfterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfterResponse * SOAP_FMAC4 soap_get__tempuri__PauseRunsetAfterResponse(struct soap *soap, _tempuri__PauseRunsetAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__PauseRunsetAfterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__PauseRunsetAfter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__PauseRunsetAfter::pauseMode = NULL;
}

void _tempuri__PauseRunsetAfter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__PauseRunsetAfter::pauseMode);
#endif
}

int _tempuri__PauseRunsetAfter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__PauseRunsetAfter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__PauseRunsetAfter(struct soap *soap, const char *tag, int id, const _tempuri__PauseRunsetAfter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__PauseRunsetAfter), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tempuri:pauseMode", -1, &a->_tempuri__PauseRunsetAfter::pauseMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__PauseRunsetAfter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__PauseRunsetAfter(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfter * SOAP_FMAC4 soap_in__tempuri__PauseRunsetAfter(struct soap *soap, const char *tag, _tempuri__PauseRunsetAfter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__PauseRunsetAfter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__PauseRunsetAfter, sizeof(_tempuri__PauseRunsetAfter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__PauseRunsetAfter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__PauseRunsetAfter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_pauseMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pauseMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:pauseMode", &a->_tempuri__PauseRunsetAfter::pauseMode, "xsd:int"))
				{	soap_flag_pauseMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__PauseRunsetAfter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__PauseRunsetAfter, SOAP_TYPE__tempuri__PauseRunsetAfter, sizeof(_tempuri__PauseRunsetAfter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate__tempuri__PauseRunsetAfter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__PauseRunsetAfter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__PauseRunsetAfter *p;
	size_t k = sizeof(_tempuri__PauseRunsetAfter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__PauseRunsetAfter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__PauseRunsetAfter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__PauseRunsetAfter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__PauseRunsetAfter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__PauseRunsetAfter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__PauseRunsetAfter(soap, tag ? tag : "tempuri:PauseRunsetAfter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__PauseRunsetAfter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__PauseRunsetAfter(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfter * SOAP_FMAC4 soap_get__tempuri__PauseRunsetAfter(struct soap *soap, _tempuri__PauseRunsetAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__PauseRunsetAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__StartSelectedRunsetFromResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__StartSelectedRunsetFromResponse::StartSelectedRunsetFromResult = NULL;
}

void _tempuri__StartSelectedRunsetFromResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__StartSelectedRunsetFromResponse::StartSelectedRunsetFromResult);
#endif
}

int _tempuri__StartSelectedRunsetFromResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__StartSelectedRunsetFromResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__StartSelectedRunsetFromResponse(struct soap *soap, const char *tag, int id, const _tempuri__StartSelectedRunsetFromResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse), type))
		return soap->error;
	if (a->StartSelectedRunsetFromResult)
		soap_element_result(soap, "tempuri:StartSelectedRunsetFromResult");
	if (soap_out_PointerTobool(soap, "tempuri:StartSelectedRunsetFromResult", -1, &a->_tempuri__StartSelectedRunsetFromResponse::StartSelectedRunsetFromResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__StartSelectedRunsetFromResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__StartSelectedRunsetFromResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFromResponse * SOAP_FMAC4 soap_in__tempuri__StartSelectedRunsetFromResponse(struct soap *soap, const char *tag, _tempuri__StartSelectedRunsetFromResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__StartSelectedRunsetFromResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse, sizeof(_tempuri__StartSelectedRunsetFromResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__StartSelectedRunsetFromResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StartSelectedRunsetFromResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartSelectedRunsetFromResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:StartSelectedRunsetFromResult", &a->_tempuri__StartSelectedRunsetFromResponse::StartSelectedRunsetFromResult, "xsd:boolean"))
				{	soap_flag_StartSelectedRunsetFromResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:StartSelectedRunsetFromResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__StartSelectedRunsetFromResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse, SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse, sizeof(_tempuri__StartSelectedRunsetFromResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__StartSelectedRunsetFromResponse * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetFromResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__StartSelectedRunsetFromResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__StartSelectedRunsetFromResponse *p;
	size_t k = sizeof(_tempuri__StartSelectedRunsetFromResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__StartSelectedRunsetFromResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__StartSelectedRunsetFromResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__StartSelectedRunsetFromResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__StartSelectedRunsetFromResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__StartSelectedRunsetFromResponse(soap, tag ? tag : "tempuri:StartSelectedRunsetFromResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__StartSelectedRunsetFromResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__StartSelectedRunsetFromResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFromResponse * SOAP_FMAC4 soap_get__tempuri__StartSelectedRunsetFromResponse(struct soap *soap, _tempuri__StartSelectedRunsetFromResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__StartSelectedRunsetFromResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__StartSelectedRunsetFrom::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__StartSelectedRunsetFrom::methodIndex = NULL;
}

void _tempuri__StartSelectedRunsetFrom::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__StartSelectedRunsetFrom::methodIndex);
#endif
}

int _tempuri__StartSelectedRunsetFrom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__StartSelectedRunsetFrom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__StartSelectedRunsetFrom(struct soap *soap, const char *tag, int id, const _tempuri__StartSelectedRunsetFrom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__StartSelectedRunsetFrom), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tempuri:methodIndex", -1, &a->_tempuri__StartSelectedRunsetFrom::methodIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__StartSelectedRunsetFrom::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__StartSelectedRunsetFrom(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFrom * SOAP_FMAC4 soap_in__tempuri__StartSelectedRunsetFrom(struct soap *soap, const char *tag, _tempuri__StartSelectedRunsetFrom *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__StartSelectedRunsetFrom*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, sizeof(_tempuri__StartSelectedRunsetFrom), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__StartSelectedRunsetFrom)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__StartSelectedRunsetFrom *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodIndex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:methodIndex", &a->_tempuri__StartSelectedRunsetFrom::methodIndex, "xsd:int"))
				{	soap_flag_methodIndex1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__StartSelectedRunsetFrom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, sizeof(_tempuri__StartSelectedRunsetFrom), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetFrom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__StartSelectedRunsetFrom(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__StartSelectedRunsetFrom *p;
	size_t k = sizeof(_tempuri__StartSelectedRunsetFrom);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__StartSelectedRunsetFrom);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__StartSelectedRunsetFrom, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__StartSelectedRunsetFrom location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__StartSelectedRunsetFrom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__StartSelectedRunsetFrom(soap, tag ? tag : "tempuri:StartSelectedRunsetFrom", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__StartSelectedRunsetFrom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__StartSelectedRunsetFrom(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFrom * SOAP_FMAC4 soap_get__tempuri__StartSelectedRunsetFrom(struct soap *soap, _tempuri__StartSelectedRunsetFrom *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__StartSelectedRunsetFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__StartSelectedRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__StartSelectedRunsetResponse::StartSelectedRunsetResult = NULL;
}

void _tempuri__StartSelectedRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__StartSelectedRunsetResponse::StartSelectedRunsetResult);
#endif
}

int _tempuri__StartSelectedRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__StartSelectedRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__StartSelectedRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__StartSelectedRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__StartSelectedRunsetResponse), type))
		return soap->error;
	if (a->StartSelectedRunsetResult)
		soap_element_result(soap, "tempuri:StartSelectedRunsetResult");
	if (soap_out_PointerTobool(soap, "tempuri:StartSelectedRunsetResult", -1, &a->_tempuri__StartSelectedRunsetResponse::StartSelectedRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__StartSelectedRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__StartSelectedRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetResponse * SOAP_FMAC4 soap_in__tempuri__StartSelectedRunsetResponse(struct soap *soap, const char *tag, _tempuri__StartSelectedRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__StartSelectedRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__StartSelectedRunsetResponse, sizeof(_tempuri__StartSelectedRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__StartSelectedRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__StartSelectedRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StartSelectedRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartSelectedRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:StartSelectedRunsetResult", &a->_tempuri__StartSelectedRunsetResponse::StartSelectedRunsetResult, "xsd:boolean"))
				{	soap_flag_StartSelectedRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:StartSelectedRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__StartSelectedRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__StartSelectedRunsetResponse, SOAP_TYPE__tempuri__StartSelectedRunsetResponse, sizeof(_tempuri__StartSelectedRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__StartSelectedRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__StartSelectedRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__StartSelectedRunsetResponse *p;
	size_t k = sizeof(_tempuri__StartSelectedRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__StartSelectedRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__StartSelectedRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__StartSelectedRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__StartSelectedRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__StartSelectedRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__StartSelectedRunsetResponse(soap, tag ? tag : "tempuri:StartSelectedRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__StartSelectedRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__StartSelectedRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetResponse * SOAP_FMAC4 soap_get__tempuri__StartSelectedRunsetResponse(struct soap *soap, _tempuri__StartSelectedRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__StartSelectedRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__StartSelectedRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__StartSelectedRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__StartSelectedRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__StartSelectedRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__StartSelectedRunset(struct soap *soap, const char *tag, int id, const _tempuri__StartSelectedRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__StartSelectedRunset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__StartSelectedRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__StartSelectedRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunset * SOAP_FMAC4 soap_in__tempuri__StartSelectedRunset(struct soap *soap, const char *tag, _tempuri__StartSelectedRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__StartSelectedRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__StartSelectedRunset, sizeof(_tempuri__StartSelectedRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__StartSelectedRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__StartSelectedRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__StartSelectedRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__StartSelectedRunset, SOAP_TYPE__tempuri__StartSelectedRunset, sizeof(_tempuri__StartSelectedRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__StartSelectedRunset * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__StartSelectedRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__StartSelectedRunset *p;
	size_t k = sizeof(_tempuri__StartSelectedRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__StartSelectedRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__StartSelectedRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__StartSelectedRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__StartSelectedRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__StartSelectedRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__StartSelectedRunset(soap, tag ? tag : "tempuri:StartSelectedRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__StartSelectedRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__StartSelectedRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__StartSelectedRunset * SOAP_FMAC4 soap_get__tempuri__StartSelectedRunset(struct soap *soap, _tempuri__StartSelectedRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__StartSelectedRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__MoveSamplePlateTrayInResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__MoveSamplePlateTrayInResponse::MoveSamplePlateTrayInResult = NULL;
}

void _tempuri__MoveSamplePlateTrayInResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__MoveSamplePlateTrayInResponse::MoveSamplePlateTrayInResult);
#endif
}

int _tempuri__MoveSamplePlateTrayInResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__MoveSamplePlateTrayInResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__MoveSamplePlateTrayInResponse(struct soap *soap, const char *tag, int id, const _tempuri__MoveSamplePlateTrayInResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse), type))
		return soap->error;
	if (a->MoveSamplePlateTrayInResult)
		soap_element_result(soap, "tempuri:MoveSamplePlateTrayInResult");
	if (soap_out_PointerTobool(soap, "tempuri:MoveSamplePlateTrayInResult", -1, &a->_tempuri__MoveSamplePlateTrayInResponse::MoveSamplePlateTrayInResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__MoveSamplePlateTrayInResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__MoveSamplePlateTrayInResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayInResponse * SOAP_FMAC4 soap_in__tempuri__MoveSamplePlateTrayInResponse(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayInResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__MoveSamplePlateTrayInResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse, sizeof(_tempuri__MoveSamplePlateTrayInResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__MoveSamplePlateTrayInResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoveSamplePlateTrayInResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveSamplePlateTrayInResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:MoveSamplePlateTrayInResult", &a->_tempuri__MoveSamplePlateTrayInResponse::MoveSamplePlateTrayInResult, "xsd:boolean"))
				{	soap_flag_MoveSamplePlateTrayInResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:MoveSamplePlateTrayInResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayInResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse, SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse, sizeof(_tempuri__MoveSamplePlateTrayInResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__MoveSamplePlateTrayInResponse * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayInResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__MoveSamplePlateTrayInResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__MoveSamplePlateTrayInResponse *p;
	size_t k = sizeof(_tempuri__MoveSamplePlateTrayInResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__MoveSamplePlateTrayInResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__MoveSamplePlateTrayInResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__MoveSamplePlateTrayInResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__MoveSamplePlateTrayInResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__MoveSamplePlateTrayInResponse(soap, tag ? tag : "tempuri:MoveSamplePlateTrayInResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__MoveSamplePlateTrayInResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__MoveSamplePlateTrayInResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayInResponse * SOAP_FMAC4 soap_get__tempuri__MoveSamplePlateTrayInResponse(struct soap *soap, _tempuri__MoveSamplePlateTrayInResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__MoveSamplePlateTrayInResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__MoveSamplePlateTrayIn::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__MoveSamplePlateTrayIn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__MoveSamplePlateTrayIn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__MoveSamplePlateTrayIn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const _tempuri__MoveSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__MoveSamplePlateTrayIn::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__MoveSamplePlateTrayIn(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_in__tempuri__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayIn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__MoveSamplePlateTrayIn*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, sizeof(_tempuri__MoveSamplePlateTrayIn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__MoveSamplePlateTrayIn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__MoveSamplePlateTrayIn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayIn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, sizeof(_tempuri__MoveSamplePlateTrayIn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__MoveSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__MoveSamplePlateTrayIn *p;
	size_t k = sizeof(_tempuri__MoveSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__MoveSamplePlateTrayIn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__MoveSamplePlateTrayIn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__MoveSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__MoveSamplePlateTrayIn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__MoveSamplePlateTrayIn(soap, tag ? tag : "tempuri:MoveSamplePlateTrayIn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__MoveSamplePlateTrayIn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__MoveSamplePlateTrayIn(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_get__tempuri__MoveSamplePlateTrayIn(struct soap *soap, _tempuri__MoveSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__MoveSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__MoveSamplePlateTrayOutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__MoveSamplePlateTrayOutResponse::MoveSamplePlateTrayOutResult = NULL;
}

void _tempuri__MoveSamplePlateTrayOutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__MoveSamplePlateTrayOutResponse::MoveSamplePlateTrayOutResult);
#endif
}

int _tempuri__MoveSamplePlateTrayOutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__MoveSamplePlateTrayOutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__MoveSamplePlateTrayOutResponse(struct soap *soap, const char *tag, int id, const _tempuri__MoveSamplePlateTrayOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse), type))
		return soap->error;
	if (a->MoveSamplePlateTrayOutResult)
		soap_element_result(soap, "tempuri:MoveSamplePlateTrayOutResult");
	if (soap_out_PointerTobool(soap, "tempuri:MoveSamplePlateTrayOutResult", -1, &a->_tempuri__MoveSamplePlateTrayOutResponse::MoveSamplePlateTrayOutResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__MoveSamplePlateTrayOutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__MoveSamplePlateTrayOutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOutResponse * SOAP_FMAC4 soap_in__tempuri__MoveSamplePlateTrayOutResponse(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayOutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__MoveSamplePlateTrayOutResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse, sizeof(_tempuri__MoveSamplePlateTrayOutResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__MoveSamplePlateTrayOutResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MoveSamplePlateTrayOutResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveSamplePlateTrayOutResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:MoveSamplePlateTrayOutResult", &a->_tempuri__MoveSamplePlateTrayOutResponse::MoveSamplePlateTrayOutResult, "xsd:boolean"))
				{	soap_flag_MoveSamplePlateTrayOutResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:MoveSamplePlateTrayOutResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse, SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse, sizeof(_tempuri__MoveSamplePlateTrayOutResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__MoveSamplePlateTrayOutResponse * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__MoveSamplePlateTrayOutResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__MoveSamplePlateTrayOutResponse *p;
	size_t k = sizeof(_tempuri__MoveSamplePlateTrayOutResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__MoveSamplePlateTrayOutResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__MoveSamplePlateTrayOutResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__MoveSamplePlateTrayOutResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__MoveSamplePlateTrayOutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__MoveSamplePlateTrayOutResponse(soap, tag ? tag : "tempuri:MoveSamplePlateTrayOutResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__MoveSamplePlateTrayOutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__MoveSamplePlateTrayOutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOutResponse * SOAP_FMAC4 soap_get__tempuri__MoveSamplePlateTrayOutResponse(struct soap *soap, _tempuri__MoveSamplePlateTrayOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__MoveSamplePlateTrayOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__MoveSamplePlateTrayOut::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__MoveSamplePlateTrayOut::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__MoveSamplePlateTrayOut::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__MoveSamplePlateTrayOut(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, int id, const _tempuri__MoveSamplePlateTrayOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__MoveSamplePlateTrayOut::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__MoveSamplePlateTrayOut(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_in__tempuri__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayOut *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__MoveSamplePlateTrayOut*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, sizeof(_tempuri__MoveSamplePlateTrayOut), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__MoveSamplePlateTrayOut)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__MoveSamplePlateTrayOut *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, sizeof(_tempuri__MoveSamplePlateTrayOut), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__MoveSamplePlateTrayOut(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__MoveSamplePlateTrayOut *p;
	size_t k = sizeof(_tempuri__MoveSamplePlateTrayOut);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__MoveSamplePlateTrayOut);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__MoveSamplePlateTrayOut, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__MoveSamplePlateTrayOut location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__MoveSamplePlateTrayOut::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__MoveSamplePlateTrayOut(soap, tag ? tag : "tempuri:MoveSamplePlateTrayOut", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__MoveSamplePlateTrayOut::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__MoveSamplePlateTrayOut(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_get__tempuri__MoveSamplePlateTrayOut(struct soap *soap, _tempuri__MoveSamplePlateTrayOut *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__MoveSamplePlateTrayOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetCurrentSamplePlateIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetCurrentSamplePlateIdResponse::GetCurrentSamplePlateIdResult = NULL;
}

void _tempuri__GetCurrentSamplePlateIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetCurrentSamplePlateIdResponse::GetCurrentSamplePlateIdResult);
#endif
}

int _tempuri__GetCurrentSamplePlateIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetCurrentSamplePlateIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetCurrentSamplePlateIdResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetCurrentSamplePlateIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse), type))
		return soap->error;
	if (a->GetCurrentSamplePlateIdResult)
		soap_element_result(soap, "tempuri:GetCurrentSamplePlateIdResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetCurrentSamplePlateIdResult", -1, &a->_tempuri__GetCurrentSamplePlateIdResponse::GetCurrentSamplePlateIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetCurrentSamplePlateIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetCurrentSamplePlateIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateIdResponse * SOAP_FMAC4 soap_in__tempuri__GetCurrentSamplePlateIdResponse(struct soap *soap, const char *tag, _tempuri__GetCurrentSamplePlateIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetCurrentSamplePlateIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse, sizeof(_tempuri__GetCurrentSamplePlateIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetCurrentSamplePlateIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetCurrentSamplePlateIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCurrentSamplePlateIdResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetCurrentSamplePlateIdResult", &a->_tempuri__GetCurrentSamplePlateIdResponse::GetCurrentSamplePlateIdResult, "xsd:string"))
				{	soap_flag_GetCurrentSamplePlateIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetCurrentSamplePlateIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetCurrentSamplePlateIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse, SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse, sizeof(_tempuri__GetCurrentSamplePlateIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetCurrentSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetCurrentSamplePlateIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetCurrentSamplePlateIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetCurrentSamplePlateIdResponse *p;
	size_t k = sizeof(_tempuri__GetCurrentSamplePlateIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetCurrentSamplePlateIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetCurrentSamplePlateIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetCurrentSamplePlateIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetCurrentSamplePlateIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetCurrentSamplePlateIdResponse(soap, tag ? tag : "tempuri:GetCurrentSamplePlateIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetCurrentSamplePlateIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetCurrentSamplePlateIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateIdResponse * SOAP_FMAC4 soap_get__tempuri__GetCurrentSamplePlateIdResponse(struct soap *soap, _tempuri__GetCurrentSamplePlateIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetCurrentSamplePlateIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetCurrentSamplePlateId::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetCurrentSamplePlateId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetCurrentSamplePlateId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetCurrentSamplePlateId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetCurrentSamplePlateId(struct soap *soap, const char *tag, int id, const _tempuri__GetCurrentSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetCurrentSamplePlateId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetCurrentSamplePlateId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetCurrentSamplePlateId(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateId * SOAP_FMAC4 soap_in__tempuri__GetCurrentSamplePlateId(struct soap *soap, const char *tag, _tempuri__GetCurrentSamplePlateId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetCurrentSamplePlateId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, sizeof(_tempuri__GetCurrentSamplePlateId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetCurrentSamplePlateId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetCurrentSamplePlateId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetCurrentSamplePlateId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, sizeof(_tempuri__GetCurrentSamplePlateId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__GetCurrentSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetCurrentSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetCurrentSamplePlateId *p;
	size_t k = sizeof(_tempuri__GetCurrentSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetCurrentSamplePlateId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetCurrentSamplePlateId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetCurrentSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetCurrentSamplePlateId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetCurrentSamplePlateId(soap, tag ? tag : "tempuri:GetCurrentSamplePlateId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetCurrentSamplePlateId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetCurrentSamplePlateId(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateId * SOAP_FMAC4 soap_get__tempuri__GetCurrentSamplePlateId(struct soap *soap, _tempuri__GetCurrentSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetCurrentSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetSamplePlateIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetSamplePlateIdResponse::GetSamplePlateIdResult = NULL;
}

void _tempuri__GetSamplePlateIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetSamplePlateIdResponse::GetSamplePlateIdResult);
#endif
}

int _tempuri__GetSamplePlateIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetSamplePlateIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetSamplePlateIdResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetSamplePlateIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetSamplePlateIdResponse), type))
		return soap->error;
	if (a->GetSamplePlateIdResult)
		soap_element_result(soap, "tempuri:GetSamplePlateIdResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetSamplePlateIdResult", -1, &a->_tempuri__GetSamplePlateIdResponse::GetSamplePlateIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetSamplePlateIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetSamplePlateIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetSamplePlateIdResponse * SOAP_FMAC4 soap_in__tempuri__GetSamplePlateIdResponse(struct soap *soap, const char *tag, _tempuri__GetSamplePlateIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetSamplePlateIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetSamplePlateIdResponse, sizeof(_tempuri__GetSamplePlateIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetSamplePlateIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetSamplePlateIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetSamplePlateIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSamplePlateIdResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetSamplePlateIdResult", &a->_tempuri__GetSamplePlateIdResponse::GetSamplePlateIdResult, "xsd:string"))
				{	soap_flag_GetSamplePlateIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetSamplePlateIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetSamplePlateIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetSamplePlateIdResponse, SOAP_TYPE__tempuri__GetSamplePlateIdResponse, sizeof(_tempuri__GetSamplePlateIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetSamplePlateIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetSamplePlateIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetSamplePlateIdResponse *p;
	size_t k = sizeof(_tempuri__GetSamplePlateIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetSamplePlateIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetSamplePlateIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetSamplePlateIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetSamplePlateIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetSamplePlateIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetSamplePlateIdResponse(soap, tag ? tag : "tempuri:GetSamplePlateIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetSamplePlateIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetSamplePlateIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetSamplePlateIdResponse * SOAP_FMAC4 soap_get__tempuri__GetSamplePlateIdResponse(struct soap *soap, _tempuri__GetSamplePlateIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetSamplePlateIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetSamplePlateId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetSamplePlateId::methodIndex = NULL;
}

void _tempuri__GetSamplePlateId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__GetSamplePlateId::methodIndex);
#endif
}

int _tempuri__GetSamplePlateId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetSamplePlateId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetSamplePlateId(struct soap *soap, const char *tag, int id, const _tempuri__GetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetSamplePlateId), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tempuri:methodIndex", -1, &a->_tempuri__GetSamplePlateId::methodIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetSamplePlateId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetSamplePlateId(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetSamplePlateId * SOAP_FMAC4 soap_in__tempuri__GetSamplePlateId(struct soap *soap, const char *tag, _tempuri__GetSamplePlateId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetSamplePlateId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetSamplePlateId, sizeof(_tempuri__GetSamplePlateId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetSamplePlateId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetSamplePlateId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodIndex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:methodIndex", &a->_tempuri__GetSamplePlateId::methodIndex, "xsd:int"))
				{	soap_flag_methodIndex1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetSamplePlateId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetSamplePlateId, SOAP_TYPE__tempuri__GetSamplePlateId, sizeof(_tempuri__GetSamplePlateId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__GetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetSamplePlateId *p;
	size_t k = sizeof(_tempuri__GetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetSamplePlateId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetSamplePlateId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetSamplePlateId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetSamplePlateId(soap, tag ? tag : "tempuri:GetSamplePlateId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetSamplePlateId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetSamplePlateId(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetSamplePlateId * SOAP_FMAC4 soap_get__tempuri__GetSamplePlateId(struct soap *soap, _tempuri__GetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetSamplePlateIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SetSamplePlateIdResponse::SetSamplePlateIdResult = NULL;
}

void _tempuri__SetSamplePlateIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__SetSamplePlateIdResponse::SetSamplePlateIdResult);
#endif
}

int _tempuri__SetSamplePlateIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetSamplePlateIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetSamplePlateIdResponse(struct soap *soap, const char *tag, int id, const _tempuri__SetSamplePlateIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetSamplePlateIdResponse), type))
		return soap->error;
	if (a->SetSamplePlateIdResult)
		soap_element_result(soap, "tempuri:SetSamplePlateIdResult");
	if (soap_out_PointerTobool(soap, "tempuri:SetSamplePlateIdResult", -1, &a->_tempuri__SetSamplePlateIdResponse::SetSamplePlateIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetSamplePlateIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SetSamplePlateIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetSamplePlateIdResponse * SOAP_FMAC4 soap_in__tempuri__SetSamplePlateIdResponse(struct soap *soap, const char *tag, _tempuri__SetSamplePlateIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetSamplePlateIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetSamplePlateIdResponse, sizeof(_tempuri__SetSamplePlateIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetSamplePlateIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetSamplePlateIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetSamplePlateIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetSamplePlateIdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:SetSamplePlateIdResult", &a->_tempuri__SetSamplePlateIdResponse::SetSamplePlateIdResult, "xsd:boolean"))
				{	soap_flag_SetSamplePlateIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:SetSamplePlateIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetSamplePlateIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetSamplePlateIdResponse, SOAP_TYPE__tempuri__SetSamplePlateIdResponse, sizeof(_tempuri__SetSamplePlateIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetSamplePlateIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetSamplePlateIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetSamplePlateIdResponse *p;
	size_t k = sizeof(_tempuri__SetSamplePlateIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SetSamplePlateIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SetSamplePlateIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SetSamplePlateIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetSamplePlateIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SetSamplePlateIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetSamplePlateIdResponse(soap, tag ? tag : "tempuri:SetSamplePlateIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetSamplePlateIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetSamplePlateIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetSamplePlateIdResponse * SOAP_FMAC4 soap_get__tempuri__SetSamplePlateIdResponse(struct soap *soap, _tempuri__SetSamplePlateIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetSamplePlateIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetSamplePlateId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SetSamplePlateId::methodIndex = NULL;
	this->_tempuri__SetSamplePlateId::plateId = NULL;
}

void _tempuri__SetSamplePlateId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tempuri__SetSamplePlateId::methodIndex);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__SetSamplePlateId::plateId);
#endif
}

int _tempuri__SetSamplePlateId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetSamplePlateId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetSamplePlateId(struct soap *soap, const char *tag, int id, const _tempuri__SetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetSamplePlateId), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tempuri:methodIndex", -1, &a->_tempuri__SetSamplePlateId::methodIndex, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:plateId", -1, &a->_tempuri__SetSamplePlateId::plateId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetSamplePlateId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SetSamplePlateId(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetSamplePlateId * SOAP_FMAC4 soap_in__tempuri__SetSamplePlateId(struct soap *soap, const char *tag, _tempuri__SetSamplePlateId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetSamplePlateId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetSamplePlateId, sizeof(_tempuri__SetSamplePlateId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetSamplePlateId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetSamplePlateId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodIndex1 = 1;
	size_t soap_flag_plateId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tempuri:methodIndex", &a->_tempuri__SetSamplePlateId::methodIndex, "xsd:int"))
				{	soap_flag_methodIndex1--;
					continue;
				}
			}
			if (soap_flag_plateId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:plateId", &a->_tempuri__SetSamplePlateId::plateId, "xsd:string"))
				{	soap_flag_plateId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetSamplePlateId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetSamplePlateId, SOAP_TYPE__tempuri__SetSamplePlateId, sizeof(_tempuri__SetSamplePlateId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__SetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetSamplePlateId *p;
	size_t k = sizeof(_tempuri__SetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SetSamplePlateId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SetSamplePlateId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SetSamplePlateId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetSamplePlateId(soap, tag ? tag : "tempuri:SetSamplePlateId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetSamplePlateId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetSamplePlateId(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetSamplePlateId * SOAP_FMAC4 soap_get__tempuri__SetSamplePlateId(struct soap *soap, _tempuri__SetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__CreateRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__CreateRunsetResponse::CreateRunsetResult = NULL;
}

void _tempuri__CreateRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__CreateRunsetResponse::CreateRunsetResult);
#endif
}

int _tempuri__CreateRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__CreateRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__CreateRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__CreateRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__CreateRunsetResponse), type))
		return soap->error;
	if (a->CreateRunsetResult)
		soap_element_result(soap, "tempuri:CreateRunsetResult");
	if (soap_out_PointerTobool(soap, "tempuri:CreateRunsetResult", -1, &a->_tempuri__CreateRunsetResponse::CreateRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__CreateRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__CreateRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__CreateRunsetResponse * SOAP_FMAC4 soap_in__tempuri__CreateRunsetResponse(struct soap *soap, const char *tag, _tempuri__CreateRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__CreateRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__CreateRunsetResponse, sizeof(_tempuri__CreateRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__CreateRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__CreateRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CreateRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreateRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:CreateRunsetResult", &a->_tempuri__CreateRunsetResponse::CreateRunsetResult, "xsd:boolean"))
				{	soap_flag_CreateRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:CreateRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__CreateRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__CreateRunsetResponse, SOAP_TYPE__tempuri__CreateRunsetResponse, sizeof(_tempuri__CreateRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__CreateRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__CreateRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__CreateRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__CreateRunsetResponse *p;
	size_t k = sizeof(_tempuri__CreateRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__CreateRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__CreateRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__CreateRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__CreateRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__CreateRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__CreateRunsetResponse(soap, tag ? tag : "tempuri:CreateRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__CreateRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__CreateRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__CreateRunsetResponse * SOAP_FMAC4 soap_get__tempuri__CreateRunsetResponse(struct soap *soap, _tempuri__CreateRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__CreateRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__CreateRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__CreateRunset::methodNames = NULL;
}

void _tempuri__CreateRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__CreateRunset::methodNames);
#endif
}

int _tempuri__CreateRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__CreateRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__CreateRunset(struct soap *soap, const char *tag, int id, const _tempuri__CreateRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__CreateRunset), type))
		return soap->error;
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:methodNames", -1, &a->_tempuri__CreateRunset::methodNames, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__CreateRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__CreateRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__CreateRunset * SOAP_FMAC4 soap_in__tempuri__CreateRunset(struct soap *soap, const char *tag, _tempuri__CreateRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__CreateRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__CreateRunset, sizeof(_tempuri__CreateRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__CreateRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__CreateRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodNames1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodNames1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:methodNames", &a->_tempuri__CreateRunset::methodNames, "arr:ArrayOfstring"))
				{	soap_flag_methodNames1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__CreateRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__CreateRunset, SOAP_TYPE__tempuri__CreateRunset, sizeof(_tempuri__CreateRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__CreateRunset * SOAP_FMAC2 soap_instantiate__tempuri__CreateRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__CreateRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__CreateRunset *p;
	size_t k = sizeof(_tempuri__CreateRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__CreateRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__CreateRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__CreateRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__CreateRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__CreateRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__CreateRunset(soap, tag ? tag : "tempuri:CreateRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__CreateRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__CreateRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__CreateRunset * SOAP_FMAC4 soap_get__tempuri__CreateRunset(struct soap *soap, _tempuri__CreateRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__CreateRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SelectRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SelectRunsetResponse::SelectRunsetResult = NULL;
}

void _tempuri__SelectRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__SelectRunsetResponse::SelectRunsetResult);
#endif
}

int _tempuri__SelectRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SelectRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SelectRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__SelectRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SelectRunsetResponse), type))
		return soap->error;
	if (a->SelectRunsetResult)
		soap_element_result(soap, "tempuri:SelectRunsetResult");
	if (soap_out_PointerTobool(soap, "tempuri:SelectRunsetResult", -1, &a->_tempuri__SelectRunsetResponse::SelectRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SelectRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SelectRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SelectRunsetResponse * SOAP_FMAC4 soap_in__tempuri__SelectRunsetResponse(struct soap *soap, const char *tag, _tempuri__SelectRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SelectRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SelectRunsetResponse, sizeof(_tempuri__SelectRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SelectRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SelectRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelectRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelectRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:SelectRunsetResult", &a->_tempuri__SelectRunsetResponse::SelectRunsetResult, "xsd:boolean"))
				{	soap_flag_SelectRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:SelectRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SelectRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SelectRunsetResponse, SOAP_TYPE__tempuri__SelectRunsetResponse, sizeof(_tempuri__SelectRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SelectRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__SelectRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SelectRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SelectRunsetResponse *p;
	size_t k = sizeof(_tempuri__SelectRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SelectRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SelectRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SelectRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SelectRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SelectRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SelectRunsetResponse(soap, tag ? tag : "tempuri:SelectRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SelectRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SelectRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SelectRunsetResponse * SOAP_FMAC4 soap_get__tempuri__SelectRunsetResponse(struct soap *soap, _tempuri__SelectRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SelectRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SelectRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SelectRunset::runsetName = NULL;
}

void _tempuri__SelectRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__SelectRunset::runsetName);
#endif
}

int _tempuri__SelectRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SelectRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SelectRunset(struct soap *soap, const char *tag, int id, const _tempuri__SelectRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SelectRunset), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:runsetName", -1, &a->_tempuri__SelectRunset::runsetName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SelectRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SelectRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SelectRunset * SOAP_FMAC4 soap_in__tempuri__SelectRunset(struct soap *soap, const char *tag, _tempuri__SelectRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SelectRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SelectRunset, sizeof(_tempuri__SelectRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SelectRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SelectRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_runsetName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_runsetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:runsetName", &a->_tempuri__SelectRunset::runsetName, "xsd:string"))
				{	soap_flag_runsetName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SelectRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SelectRunset, SOAP_TYPE__tempuri__SelectRunset, sizeof(_tempuri__SelectRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SelectRunset * SOAP_FMAC2 soap_instantiate__tempuri__SelectRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SelectRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SelectRunset *p;
	size_t k = sizeof(_tempuri__SelectRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SelectRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SelectRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SelectRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SelectRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SelectRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SelectRunset(soap, tag ? tag : "tempuri:SelectRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SelectRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SelectRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SelectRunset * SOAP_FMAC4 soap_get__tempuri__SelectRunset(struct soap *soap, _tempuri__SelectRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SelectRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SelectMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SelectMethodResponse::SelectMethodResult = NULL;
}

void _tempuri__SelectMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_tempuri__SelectMethodResponse::SelectMethodResult);
#endif
}

int _tempuri__SelectMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SelectMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SelectMethodResponse(struct soap *soap, const char *tag, int id, const _tempuri__SelectMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SelectMethodResponse), type))
		return soap->error;
	if (a->SelectMethodResult)
		soap_element_result(soap, "tempuri:SelectMethodResult");
	if (soap_out_PointerTobool(soap, "tempuri:SelectMethodResult", -1, &a->_tempuri__SelectMethodResponse::SelectMethodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SelectMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SelectMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SelectMethodResponse * SOAP_FMAC4 soap_in__tempuri__SelectMethodResponse(struct soap *soap, const char *tag, _tempuri__SelectMethodResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SelectMethodResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SelectMethodResponse, sizeof(_tempuri__SelectMethodResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SelectMethodResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SelectMethodResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelectMethodResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelectMethodResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tempuri:SelectMethodResult", &a->_tempuri__SelectMethodResponse::SelectMethodResult, "xsd:boolean"))
				{	soap_flag_SelectMethodResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:SelectMethodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SelectMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SelectMethodResponse, SOAP_TYPE__tempuri__SelectMethodResponse, sizeof(_tempuri__SelectMethodResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SelectMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__SelectMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SelectMethodResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SelectMethodResponse *p;
	size_t k = sizeof(_tempuri__SelectMethodResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SelectMethodResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SelectMethodResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SelectMethodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SelectMethodResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SelectMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SelectMethodResponse(soap, tag ? tag : "tempuri:SelectMethodResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SelectMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SelectMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SelectMethodResponse * SOAP_FMAC4 soap_get__tempuri__SelectMethodResponse(struct soap *soap, _tempuri__SelectMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SelectMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SelectMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__SelectMethod::methodName = NULL;
}

void _tempuri__SelectMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__SelectMethod::methodName);
#endif
}

int _tempuri__SelectMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SelectMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SelectMethod(struct soap *soap, const char *tag, int id, const _tempuri__SelectMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SelectMethod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:methodName", -1, &a->_tempuri__SelectMethod::methodName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SelectMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__SelectMethod(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SelectMethod * SOAP_FMAC4 soap_in__tempuri__SelectMethod(struct soap *soap, const char *tag, _tempuri__SelectMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SelectMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SelectMethod, sizeof(_tempuri__SelectMethod), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SelectMethod)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SelectMethod *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:methodName", &a->_tempuri__SelectMethod::methodName, "xsd:string"))
				{	soap_flag_methodName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SelectMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SelectMethod, SOAP_TYPE__tempuri__SelectMethod, sizeof(_tempuri__SelectMethod), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SelectMethod * SOAP_FMAC2 soap_instantiate__tempuri__SelectMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SelectMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SelectMethod *p;
	size_t k = sizeof(_tempuri__SelectMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__SelectMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__SelectMethod);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__SelectMethod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SelectMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__SelectMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SelectMethod(soap, tag ? tag : "tempuri:SelectMethod", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SelectMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SelectMethod(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SelectMethod * SOAP_FMAC4 soap_get__tempuri__SelectMethod(struct soap *soap, _tempuri__SelectMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SelectMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetMethodNamesOfRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetMethodNamesOfRunsetResponse::GetMethodNamesOfRunsetResult = NULL;
}

void _tempuri__GetMethodNamesOfRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetMethodNamesOfRunsetResponse::GetMethodNamesOfRunsetResult);
#endif
}

int _tempuri__GetMethodNamesOfRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetMethodNamesOfRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetMethodNamesOfRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetMethodNamesOfRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse), type))
		return soap->error;
	if (a->GetMethodNamesOfRunsetResult)
		soap_element_result(soap, "tempuri:GetMethodNamesOfRunsetResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetMethodNamesOfRunsetResult", -1, &a->_tempuri__GetMethodNamesOfRunsetResponse::GetMethodNamesOfRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetMethodNamesOfRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetMethodNamesOfRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunsetResponse * SOAP_FMAC4 soap_in__tempuri__GetMethodNamesOfRunsetResponse(struct soap *soap, const char *tag, _tempuri__GetMethodNamesOfRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetMethodNamesOfRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse, sizeof(_tempuri__GetMethodNamesOfRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetMethodNamesOfRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMethodNamesOfRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMethodNamesOfRunsetResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetMethodNamesOfRunsetResult", &a->_tempuri__GetMethodNamesOfRunsetResponse::GetMethodNamesOfRunsetResult, "arr:ArrayOfstring"))
				{	soap_flag_GetMethodNamesOfRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetMethodNamesOfRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetMethodNamesOfRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse, SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse, sizeof(_tempuri__GetMethodNamesOfRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetMethodNamesOfRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetMethodNamesOfRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetMethodNamesOfRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetMethodNamesOfRunsetResponse *p;
	size_t k = sizeof(_tempuri__GetMethodNamesOfRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetMethodNamesOfRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetMethodNamesOfRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetMethodNamesOfRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetMethodNamesOfRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetMethodNamesOfRunsetResponse(soap, tag ? tag : "tempuri:GetMethodNamesOfRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetMethodNamesOfRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetMethodNamesOfRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunsetResponse * SOAP_FMAC4 soap_get__tempuri__GetMethodNamesOfRunsetResponse(struct soap *soap, _tempuri__GetMethodNamesOfRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetMethodNamesOfRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetMethodNamesOfRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetMethodNamesOfRunset::runsetName = NULL;
}

void _tempuri__GetMethodNamesOfRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetMethodNamesOfRunset::runsetName);
#endif
}

int _tempuri__GetMethodNamesOfRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetMethodNamesOfRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetMethodNamesOfRunset(struct soap *soap, const char *tag, int id, const _tempuri__GetMethodNamesOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetMethodNamesOfRunset), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:runsetName", -1, &a->_tempuri__GetMethodNamesOfRunset::runsetName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetMethodNamesOfRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetMethodNamesOfRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunset * SOAP_FMAC4 soap_in__tempuri__GetMethodNamesOfRunset(struct soap *soap, const char *tag, _tempuri__GetMethodNamesOfRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetMethodNamesOfRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, sizeof(_tempuri__GetMethodNamesOfRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetMethodNamesOfRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetMethodNamesOfRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_runsetName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_runsetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:runsetName", &a->_tempuri__GetMethodNamesOfRunset::runsetName, "xsd:string"))
				{	soap_flag_runsetName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetMethodNamesOfRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, sizeof(_tempuri__GetMethodNamesOfRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetMethodNamesOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetMethodNamesOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetMethodNamesOfRunset *p;
	size_t k = sizeof(_tempuri__GetMethodNamesOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetMethodNamesOfRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetMethodNamesOfRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetMethodNamesOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetMethodNamesOfRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetMethodNamesOfRunset(soap, tag ? tag : "tempuri:GetMethodNamesOfRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetMethodNamesOfRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetMethodNamesOfRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunset * SOAP_FMAC4 soap_get__tempuri__GetMethodNamesOfRunset(struct soap *soap, _tempuri__GetMethodNamesOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetMethodNamesOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfRunsetResponse::GetAssayTypeOfRunsetResult = NULL;
}

void _tempuri__GetAssayTypeOfRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfRunsetResponse::GetAssayTypeOfRunsetResult);
#endif
}

int _tempuri__GetAssayTypeOfRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse), type))
		return soap->error;
	if (a->GetAssayTypeOfRunsetResult)
		soap_element_result(soap, "tempuri:GetAssayTypeOfRunsetResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetAssayTypeOfRunsetResult", -1, &a->_tempuri__GetAssayTypeOfRunsetResponse::GetAssayTypeOfRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunsetResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfRunsetResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse, sizeof(_tempuri__GetAssayTypeOfRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypeOfRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypeOfRunsetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetAssayTypeOfRunsetResult", &a->_tempuri__GetAssayTypeOfRunsetResponse::GetAssayTypeOfRunsetResult, "xsd:string"))
				{	soap_flag_GetAssayTypeOfRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypeOfRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse, SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse, sizeof(_tempuri__GetAssayTypeOfRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfRunsetResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfRunsetResponse(soap, tag ? tag : "tempuri:GetAssayTypeOfRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunsetResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfRunsetResponse(struct soap *soap, _tempuri__GetAssayTypeOfRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfRunset::runsetName = NULL;
}

void _tempuri__GetAssayTypeOfRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfRunset::runsetName);
#endif
}

int _tempuri__GetAssayTypeOfRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfRunset(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfRunset), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:runsetName", -1, &a->_tempuri__GetAssayTypeOfRunset::runsetName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunset * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfRunset(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, sizeof(_tempuri__GetAssayTypeOfRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_runsetName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_runsetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:runsetName", &a->_tempuri__GetAssayTypeOfRunset::runsetName, "xsd:string"))
				{	soap_flag_runsetName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, sizeof(_tempuri__GetAssayTypeOfRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfRunset *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfRunset(soap, tag ? tag : "tempuri:GetAssayTypeOfRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunset * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfRunset(struct soap *soap, _tempuri__GetAssayTypeOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfCurrentRunsetResponse::GetAssayTypeOfCurrentRunsetResult = NULL;
}

void _tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfCurrentRunsetResponse::GetAssayTypeOfCurrentRunsetResult);
#endif
}

int _tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfCurrentRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse), type))
		return soap->error;
	if (a->GetAssayTypeOfCurrentRunsetResult)
		soap_element_result(soap, "tempuri:GetAssayTypeOfCurrentRunsetResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetAssayTypeOfCurrentRunsetResult", -1, &a->_tempuri__GetAssayTypeOfCurrentRunsetResponse::GetAssayTypeOfCurrentRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunsetResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfCurrentRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse, sizeof(_tempuri__GetAssayTypeOfCurrentRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfCurrentRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypeOfCurrentRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypeOfCurrentRunsetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetAssayTypeOfCurrentRunsetResult", &a->_tempuri__GetAssayTypeOfCurrentRunsetResponse::GetAssayTypeOfCurrentRunsetResult, "xsd:string"))
				{	soap_flag_GetAssayTypeOfCurrentRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypeOfCurrentRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse, sizeof(_tempuri__GetAssayTypeOfCurrentRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfCurrentRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfCurrentRunsetResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfCurrentRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfCurrentRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfCurrentRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfCurrentRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfCurrentRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunsetResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap *soap, _tempuri__GetAssayTypeOfCurrentRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfCurrentRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfCurrentRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetAssayTypeOfCurrentRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetAssayTypeOfCurrentRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfCurrentRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfCurrentRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfCurrentRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfCurrentRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, sizeof(_tempuri__GetAssayTypeOfCurrentRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfCurrentRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, sizeof(_tempuri__GetAssayTypeOfCurrentRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfCurrentRunset *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfCurrentRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfCurrentRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfCurrentRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfCurrentRunset(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfCurrentRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfCurrentRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, _tempuri__GetAssayTypeOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNameOfCurrentRunsetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNameOfCurrentRunsetResponse::GetNameOfCurrentRunsetResult = NULL;
}

void _tempuri__GetNameOfCurrentRunsetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetNameOfCurrentRunsetResponse::GetNameOfCurrentRunsetResult);
#endif
}

int _tempuri__GetNameOfCurrentRunsetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNameOfCurrentRunsetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNameOfCurrentRunsetResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNameOfCurrentRunsetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse), type))
		return soap->error;
	if (a->GetNameOfCurrentRunsetResult)
		soap_element_result(soap, "tempuri:GetNameOfCurrentRunsetResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetNameOfCurrentRunsetResult", -1, &a->_tempuri__GetNameOfCurrentRunsetResponse::GetNameOfCurrentRunsetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNameOfCurrentRunsetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNameOfCurrentRunsetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunsetResponse * SOAP_FMAC4 soap_in__tempuri__GetNameOfCurrentRunsetResponse(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentRunsetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNameOfCurrentRunsetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse, sizeof(_tempuri__GetNameOfCurrentRunsetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNameOfCurrentRunsetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNameOfCurrentRunsetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNameOfCurrentRunsetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetNameOfCurrentRunsetResult", &a->_tempuri__GetNameOfCurrentRunsetResponse::GetNameOfCurrentRunsetResult, "xsd:string"))
				{	soap_flag_GetNameOfCurrentRunsetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNameOfCurrentRunsetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNameOfCurrentRunsetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse, SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse, sizeof(_tempuri__GetNameOfCurrentRunsetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNameOfCurrentRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentRunsetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNameOfCurrentRunsetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNameOfCurrentRunsetResponse *p;
	size_t k = sizeof(_tempuri__GetNameOfCurrentRunsetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNameOfCurrentRunsetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNameOfCurrentRunsetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNameOfCurrentRunsetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNameOfCurrentRunsetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNameOfCurrentRunsetResponse(soap, tag ? tag : "tempuri:GetNameOfCurrentRunsetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNameOfCurrentRunsetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNameOfCurrentRunsetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunsetResponse * SOAP_FMAC4 soap_get__tempuri__GetNameOfCurrentRunsetResponse(struct soap *soap, _tempuri__GetNameOfCurrentRunsetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNameOfCurrentRunsetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNameOfCurrentRunset::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetNameOfCurrentRunset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetNameOfCurrentRunset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNameOfCurrentRunset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNameOfCurrentRunset(struct soap *soap, const char *tag, int id, const _tempuri__GetNameOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNameOfCurrentRunset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNameOfCurrentRunset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNameOfCurrentRunset(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunset * SOAP_FMAC4 soap_in__tempuri__GetNameOfCurrentRunset(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentRunset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNameOfCurrentRunset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, sizeof(_tempuri__GetNameOfCurrentRunset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNameOfCurrentRunset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNameOfCurrentRunset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNameOfCurrentRunset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, sizeof(_tempuri__GetNameOfCurrentRunset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNameOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNameOfCurrentRunset *p;
	size_t k = sizeof(_tempuri__GetNameOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNameOfCurrentRunset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNameOfCurrentRunset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNameOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNameOfCurrentRunset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNameOfCurrentRunset(soap, tag ? tag : "tempuri:GetNameOfCurrentRunset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNameOfCurrentRunset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNameOfCurrentRunset(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunset * SOAP_FMAC4 soap_get__tempuri__GetNameOfCurrentRunset(struct soap *soap, _tempuri__GetNameOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNameOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypesOfAllRunsetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypesOfAllRunsetsResponse::GetAssayTypesOfAllRunsetsResult = NULL;
}

void _tempuri__GetAssayTypesOfAllRunsetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetAssayTypesOfAllRunsetsResponse::GetAssayTypesOfAllRunsetsResult);
#endif
}

int _tempuri__GetAssayTypesOfAllRunsetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypesOfAllRunsetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse), type))
		return soap->error;
	if (a->GetAssayTypesOfAllRunsetsResult)
		soap_element_result(soap, "tempuri:GetAssayTypesOfAllRunsetsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetAssayTypesOfAllRunsetsResult", -1, &a->_tempuri__GetAssayTypesOfAllRunsetsResponse::GetAssayTypesOfAllRunsetsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypesOfAllRunsetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsetsResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllRunsetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypesOfAllRunsetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse, sizeof(_tempuri__GetAssayTypesOfAllRunsetsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypesOfAllRunsetsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypesOfAllRunsetsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypesOfAllRunsetsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetAssayTypesOfAllRunsetsResult", &a->_tempuri__GetAssayTypesOfAllRunsetsResponse::GetAssayTypesOfAllRunsetsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetAssayTypesOfAllRunsetsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypesOfAllRunsetsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllRunsetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse, sizeof(_tempuri__GetAssayTypesOfAllRunsetsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypesOfAllRunsetsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypesOfAllRunsetsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypesOfAllRunsetsResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypesOfAllRunsetsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypesOfAllRunsetsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypesOfAllRunsetsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypesOfAllRunsetsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypesOfAllRunsetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, tag ? tag : "tempuri:GetAssayTypesOfAllRunsetsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypesOfAllRunsetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsetsResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap *soap, _tempuri__GetAssayTypesOfAllRunsetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypesOfAllRunsetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypesOfAllRunsets::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetAssayTypesOfAllRunsets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetAssayTypesOfAllRunsets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypesOfAllRunsets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypesOfAllRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypesOfAllRunsets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypesOfAllRunsets(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_in__tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllRunsets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypesOfAllRunsets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, sizeof(_tempuri__GetAssayTypesOfAllRunsets), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypesOfAllRunsets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllRunsets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, sizeof(_tempuri__GetAssayTypesOfAllRunsets), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypesOfAllRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypesOfAllRunsets *p;
	size_t k = sizeof(_tempuri__GetAssayTypesOfAllRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypesOfAllRunsets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypesOfAllRunsets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypesOfAllRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypesOfAllRunsets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypesOfAllRunsets(soap, tag ? tag : "tempuri:GetAssayTypesOfAllRunsets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypesOfAllRunsets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypesOfAllRunsets(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_get__tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, _tempuri__GetAssayTypesOfAllRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypesOfAllRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::GetNamesOfRunsetsOfAssayTypeResult = NULL;
}

void _tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::GetNamesOfRunsetsOfAssayTypeResult);
#endif
}

int _tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfRunsetsOfAssayTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse), type))
		return soap->error;
	if (a->GetNamesOfRunsetsOfAssayTypeResult)
		soap_element_result(soap, "tempuri:GetNamesOfRunsetsOfAssayTypeResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfRunsetsOfAssayTypeResult", -1, &a->_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::GetNamesOfRunsetsOfAssayTypeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayTypeResponse * SOAP_FMAC4 soap_in__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsetsOfAssayTypeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfRunsetsOfAssayTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse, sizeof(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfRunsetsOfAssayTypeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNamesOfRunsetsOfAssayTypeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNamesOfRunsetsOfAssayTypeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfRunsetsOfAssayTypeResult", &a->_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::GetNamesOfRunsetsOfAssayTypeResult, "arr:ArrayOfstring"))
				{	soap_flag_GetNamesOfRunsetsOfAssayTypeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNamesOfRunsetsOfAssayTypeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfRunsetsOfAssayTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse, sizeof(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfRunsetsOfAssayTypeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfRunsetsOfAssayTypeResponse *p;
	size_t k = sizeof(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfRunsetsOfAssayTypeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfRunsetsOfAssayTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfRunsetsOfAssayTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, tag ? tag : "tempuri:GetNamesOfRunsetsOfAssayTypeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfRunsetsOfAssayTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayTypeResponse * SOAP_FMAC4 soap_get__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap *soap, _tempuri__GetNamesOfRunsetsOfAssayTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfRunsetsOfAssayType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfRunsetsOfAssayType::assayType = NULL;
}

void _tempuri__GetNamesOfRunsetsOfAssayType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetNamesOfRunsetsOfAssayType::assayType);
#endif
}

int _tempuri__GetNamesOfRunsetsOfAssayType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:assayType", -1, &a->_tempuri__GetNamesOfRunsetsOfAssayType::assayType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfRunsetsOfAssayType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_in__tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfRunsetsOfAssayType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, sizeof(_tempuri__GetNamesOfRunsetsOfAssayType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfRunsetsOfAssayType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assayType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assayType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:assayType", &a->_tempuri__GetNamesOfRunsetsOfAssayType::assayType, "xsd:string"))
				{	soap_flag_assayType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfRunsetsOfAssayType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, sizeof(_tempuri__GetNamesOfRunsetsOfAssayType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfRunsetsOfAssayType *p;
	size_t k = sizeof(_tempuri__GetNamesOfRunsetsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfRunsetsOfAssayType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfRunsetsOfAssayType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfRunsetsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfRunsetsOfAssayType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfRunsetsOfAssayType(soap, tag ? tag : "tempuri:GetNamesOfRunsetsOfAssayType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfRunsetsOfAssayType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfRunsetsOfAssayType(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_get__tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, _tempuri__GetNamesOfRunsetsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfRunsetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfRunsetsResponse::GetNamesOfRunsetsResult = NULL;
}

void _tempuri__GetNamesOfRunsetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetNamesOfRunsetsResponse::GetNamesOfRunsetsResult);
#endif
}

int _tempuri__GetNamesOfRunsetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfRunsetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfRunsetsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfRunsetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse), type))
		return soap->error;
	if (a->GetNamesOfRunsetsResult)
		soap_element_result(soap, "tempuri:GetNamesOfRunsetsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfRunsetsResult", -1, &a->_tempuri__GetNamesOfRunsetsResponse::GetNamesOfRunsetsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfRunsetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfRunsetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsResponse * SOAP_FMAC4 soap_in__tempuri__GetNamesOfRunsetsResponse(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfRunsetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse, sizeof(_tempuri__GetNamesOfRunsetsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfRunsetsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNamesOfRunsetsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNamesOfRunsetsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfRunsetsResult", &a->_tempuri__GetNamesOfRunsetsResponse::GetNamesOfRunsetsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetNamesOfRunsetsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNamesOfRunsetsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfRunsetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse, SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse, sizeof(_tempuri__GetNamesOfRunsetsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfRunsetsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfRunsetsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfRunsetsResponse *p;
	size_t k = sizeof(_tempuri__GetNamesOfRunsetsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfRunsetsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfRunsetsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfRunsetsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfRunsetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfRunsetsResponse(soap, tag ? tag : "tempuri:GetNamesOfRunsetsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfRunsetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfRunsetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsResponse * SOAP_FMAC4 soap_get__tempuri__GetNamesOfRunsetsResponse(struct soap *soap, _tempuri__GetNamesOfRunsetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfRunsetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfRunsets::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetNamesOfRunsets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetNamesOfRunsets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfRunsets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfRunsets(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfRunsets), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfRunsets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfRunsets(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsets * SOAP_FMAC4 soap_in__tempuri__GetNamesOfRunsets(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfRunsets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfRunsets, sizeof(_tempuri__GetNamesOfRunsets), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfRunsets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfRunsets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfRunsets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfRunsets, SOAP_TYPE__tempuri__GetNamesOfRunsets, sizeof(_tempuri__GetNamesOfRunsets), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfRunsets *p;
	size_t k = sizeof(_tempuri__GetNamesOfRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfRunsets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfRunsets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfRunsets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfRunsets(soap, tag ? tag : "tempuri:GetNamesOfRunsets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfRunsets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfRunsets(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsets * SOAP_FMAC4 soap_get__tempuri__GetNamesOfRunsets(struct soap *soap, _tempuri__GetNamesOfRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfMethodResponse::GetAssayTypeOfMethodResult = NULL;
}

void _tempuri__GetAssayTypeOfMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfMethodResponse::GetAssayTypeOfMethodResult);
#endif
}

int _tempuri__GetAssayTypeOfMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfMethodResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse), type))
		return soap->error;
	if (a->GetAssayTypeOfMethodResult)
		soap_element_result(soap, "tempuri:GetAssayTypeOfMethodResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetAssayTypeOfMethodResult", -1, &a->_tempuri__GetAssayTypeOfMethodResponse::GetAssayTypeOfMethodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethodResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfMethodResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfMethodResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfMethodResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse, sizeof(_tempuri__GetAssayTypeOfMethodResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfMethodResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypeOfMethodResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypeOfMethodResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetAssayTypeOfMethodResult", &a->_tempuri__GetAssayTypeOfMethodResponse::GetAssayTypeOfMethodResult, "xsd:string"))
				{	soap_flag_GetAssayTypeOfMethodResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypeOfMethodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse, SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse, sizeof(_tempuri__GetAssayTypeOfMethodResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfMethodResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfMethodResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfMethodResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfMethodResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfMethodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfMethodResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfMethodResponse(soap, tag ? tag : "tempuri:GetAssayTypeOfMethodResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethodResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfMethodResponse(struct soap *soap, _tempuri__GetAssayTypeOfMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfMethod::methodName = NULL;
}

void _tempuri__GetAssayTypeOfMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfMethod::methodName);
#endif
}

int _tempuri__GetAssayTypeOfMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfMethod(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfMethod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:methodName", -1, &a->_tempuri__GetAssayTypeOfMethod::methodName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfMethod(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethod * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfMethod(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, sizeof(_tempuri__GetAssayTypeOfMethod), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfMethod)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfMethod *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_methodName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:methodName", &a->_tempuri__GetAssayTypeOfMethod::methodName, "xsd:string"))
				{	soap_flag_methodName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, sizeof(_tempuri__GetAssayTypeOfMethod), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfMethod *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfMethod);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfMethod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfMethod(soap, tag ? tag : "tempuri:GetAssayTypeOfMethod", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfMethod(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethod * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfMethod(struct soap *soap, _tempuri__GetAssayTypeOfMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfCurrentMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypeOfCurrentMethodResponse::GetAssayTypeOfCurrentMethodResult = NULL;
}

void _tempuri__GetAssayTypeOfCurrentMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetAssayTypeOfCurrentMethodResponse::GetAssayTypeOfCurrentMethodResult);
#endif
}

int _tempuri__GetAssayTypeOfCurrentMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfCurrentMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse), type))
		return soap->error;
	if (a->GetAssayTypeOfCurrentMethodResult)
		soap_element_result(soap, "tempuri:GetAssayTypeOfCurrentMethodResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetAssayTypeOfCurrentMethodResult", -1, &a->_tempuri__GetAssayTypeOfCurrentMethodResponse::GetAssayTypeOfCurrentMethodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfCurrentMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethodResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentMethodResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfCurrentMethodResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse, sizeof(_tempuri__GetAssayTypeOfCurrentMethodResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfCurrentMethodResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypeOfCurrentMethodResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypeOfCurrentMethodResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetAssayTypeOfCurrentMethodResult", &a->_tempuri__GetAssayTypeOfCurrentMethodResponse::GetAssayTypeOfCurrentMethodResult, "xsd:string"))
				{	soap_flag_GetAssayTypeOfCurrentMethodResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypeOfCurrentMethodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse, sizeof(_tempuri__GetAssayTypeOfCurrentMethodResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfCurrentMethodResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfCurrentMethodResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfCurrentMethodResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfCurrentMethodResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfCurrentMethodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfCurrentMethodResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfCurrentMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentMethodResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfCurrentMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethodResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap *soap, _tempuri__GetAssayTypeOfCurrentMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfCurrentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypeOfCurrentMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetAssayTypeOfCurrentMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetAssayTypeOfCurrentMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypeOfCurrentMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypeOfCurrentMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypeOfCurrentMethod(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_in__tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypeOfCurrentMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, sizeof(_tempuri__GetAssayTypeOfCurrentMethod), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypeOfCurrentMethod *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, sizeof(_tempuri__GetAssayTypeOfCurrentMethod), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypeOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypeOfCurrentMethod *p;
	size_t k = sizeof(_tempuri__GetAssayTypeOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypeOfCurrentMethod);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypeOfCurrentMethod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypeOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypeOfCurrentMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypeOfCurrentMethod(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentMethod", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypeOfCurrentMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypeOfCurrentMethod(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_get__tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, _tempuri__GetAssayTypeOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypeOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNameOfCurrentMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNameOfCurrentMethodResponse::GetNameOfCurrentMethodResult = NULL;
}

void _tempuri__GetNameOfCurrentMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetNameOfCurrentMethodResponse::GetNameOfCurrentMethodResult);
#endif
}

int _tempuri__GetNameOfCurrentMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNameOfCurrentMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNameOfCurrentMethodResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNameOfCurrentMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse), type))
		return soap->error;
	if (a->GetNameOfCurrentMethodResult)
		soap_element_result(soap, "tempuri:GetNameOfCurrentMethodResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetNameOfCurrentMethodResult", -1, &a->_tempuri__GetNameOfCurrentMethodResponse::GetNameOfCurrentMethodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNameOfCurrentMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNameOfCurrentMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethodResponse * SOAP_FMAC4 soap_in__tempuri__GetNameOfCurrentMethodResponse(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentMethodResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNameOfCurrentMethodResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse, sizeof(_tempuri__GetNameOfCurrentMethodResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNameOfCurrentMethodResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNameOfCurrentMethodResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNameOfCurrentMethodResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetNameOfCurrentMethodResult", &a->_tempuri__GetNameOfCurrentMethodResponse::GetNameOfCurrentMethodResult, "xsd:string"))
				{	soap_flag_GetNameOfCurrentMethodResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNameOfCurrentMethodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNameOfCurrentMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse, SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse, sizeof(_tempuri__GetNameOfCurrentMethodResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNameOfCurrentMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNameOfCurrentMethodResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNameOfCurrentMethodResponse *p;
	size_t k = sizeof(_tempuri__GetNameOfCurrentMethodResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNameOfCurrentMethodResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNameOfCurrentMethodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNameOfCurrentMethodResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNameOfCurrentMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNameOfCurrentMethodResponse(soap, tag ? tag : "tempuri:GetNameOfCurrentMethodResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNameOfCurrentMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNameOfCurrentMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethodResponse * SOAP_FMAC4 soap_get__tempuri__GetNameOfCurrentMethodResponse(struct soap *soap, _tempuri__GetNameOfCurrentMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNameOfCurrentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNameOfCurrentMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetNameOfCurrentMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetNameOfCurrentMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNameOfCurrentMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNameOfCurrentMethod(struct soap *soap, const char *tag, int id, const _tempuri__GetNameOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNameOfCurrentMethod), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNameOfCurrentMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNameOfCurrentMethod(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethod * SOAP_FMAC4 soap_in__tempuri__GetNameOfCurrentMethod(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNameOfCurrentMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, sizeof(_tempuri__GetNameOfCurrentMethod), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNameOfCurrentMethod)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNameOfCurrentMethod *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNameOfCurrentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, sizeof(_tempuri__GetNameOfCurrentMethod), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNameOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNameOfCurrentMethod *p;
	size_t k = sizeof(_tempuri__GetNameOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNameOfCurrentMethod);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNameOfCurrentMethod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNameOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNameOfCurrentMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNameOfCurrentMethod(soap, tag ? tag : "tempuri:GetNameOfCurrentMethod", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNameOfCurrentMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNameOfCurrentMethod(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethod * SOAP_FMAC4 soap_get__tempuri__GetNameOfCurrentMethod(struct soap *soap, _tempuri__GetNameOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNameOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypesOfAllMethodsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetAssayTypesOfAllMethodsResponse::GetAssayTypesOfAllMethodsResult = NULL;
}

void _tempuri__GetAssayTypesOfAllMethodsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetAssayTypesOfAllMethodsResponse::GetAssayTypesOfAllMethodsResult);
#endif
}

int _tempuri__GetAssayTypesOfAllMethodsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypesOfAllMethodsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypesOfAllMethodsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse), type))
		return soap->error;
	if (a->GetAssayTypesOfAllMethodsResult)
		soap_element_result(soap, "tempuri:GetAssayTypesOfAllMethodsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetAssayTypesOfAllMethodsResult", -1, &a->_tempuri__GetAssayTypesOfAllMethodsResponse::GetAssayTypesOfAllMethodsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypesOfAllMethodsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypesOfAllMethodsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethodsResponse * SOAP_FMAC4 soap_in__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllMethodsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypesOfAllMethodsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse, sizeof(_tempuri__GetAssayTypesOfAllMethodsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypesOfAllMethodsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAssayTypesOfAllMethodsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssayTypesOfAllMethodsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetAssayTypesOfAllMethodsResult", &a->_tempuri__GetAssayTypesOfAllMethodsResponse::GetAssayTypesOfAllMethodsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetAssayTypesOfAllMethodsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetAssayTypesOfAllMethodsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllMethodsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse, sizeof(_tempuri__GetAssayTypesOfAllMethodsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypesOfAllMethodsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypesOfAllMethodsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypesOfAllMethodsResponse *p;
	size_t k = sizeof(_tempuri__GetAssayTypesOfAllMethodsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypesOfAllMethodsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypesOfAllMethodsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypesOfAllMethodsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypesOfAllMethodsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypesOfAllMethodsResponse(soap, tag ? tag : "tempuri:GetAssayTypesOfAllMethodsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypesOfAllMethodsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypesOfAllMethodsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethodsResponse * SOAP_FMAC4 soap_get__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap *soap, _tempuri__GetAssayTypesOfAllMethodsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypesOfAllMethodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetAssayTypesOfAllMethods::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetAssayTypesOfAllMethods::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetAssayTypesOfAllMethods::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetAssayTypesOfAllMethods(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, int id, const _tempuri__GetAssayTypesOfAllMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetAssayTypesOfAllMethods::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetAssayTypesOfAllMethods(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_in__tempuri__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllMethods *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetAssayTypesOfAllMethods*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, sizeof(_tempuri__GetAssayTypesOfAllMethods), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetAssayTypesOfAllMethods *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllMethods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, sizeof(_tempuri__GetAssayTypesOfAllMethods), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetAssayTypesOfAllMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetAssayTypesOfAllMethods *p;
	size_t k = sizeof(_tempuri__GetAssayTypesOfAllMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetAssayTypesOfAllMethods);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetAssayTypesOfAllMethods, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetAssayTypesOfAllMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetAssayTypesOfAllMethods::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetAssayTypesOfAllMethods(soap, tag ? tag : "tempuri:GetAssayTypesOfAllMethods", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetAssayTypesOfAllMethods::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetAssayTypesOfAllMethods(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_get__tempuri__GetAssayTypesOfAllMethods(struct soap *soap, _tempuri__GetAssayTypesOfAllMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetAssayTypesOfAllMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfMethodsOfAssayTypeResponse::GetNamesOfMethodsOfAssayTypeResult = NULL;
}

void _tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetNamesOfMethodsOfAssayTypeResponse::GetNamesOfMethodsOfAssayTypeResult);
#endif
}

int _tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMethodsOfAssayTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse), type))
		return soap->error;
	if (a->GetNamesOfMethodsOfAssayTypeResult)
		soap_element_result(soap, "tempuri:GetNamesOfMethodsOfAssayTypeResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMethodsOfAssayTypeResult", -1, &a->_tempuri__GetNamesOfMethodsOfAssayTypeResponse::GetNamesOfMethodsOfAssayTypeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayTypeResponse * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethodsOfAssayTypeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMethodsOfAssayTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse, sizeof(_tempuri__GetNamesOfMethodsOfAssayTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMethodsOfAssayTypeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNamesOfMethodsOfAssayTypeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNamesOfMethodsOfAssayTypeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMethodsOfAssayTypeResult", &a->_tempuri__GetNamesOfMethodsOfAssayTypeResponse::GetNamesOfMethodsOfAssayTypeResult, "arr:ArrayOfstring"))
				{	soap_flag_GetNamesOfMethodsOfAssayTypeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNamesOfMethodsOfAssayTypeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMethodsOfAssayTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse, sizeof(_tempuri__GetNamesOfMethodsOfAssayTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMethodsOfAssayTypeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMethodsOfAssayTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMethodsOfAssayTypeResponse *p;
	size_t k = sizeof(_tempuri__GetNamesOfMethodsOfAssayTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMethodsOfAssayTypeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMethodsOfAssayTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMethodsOfAssayTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, tag ? tag : "tempuri:GetNamesOfMethodsOfAssayTypeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMethodsOfAssayTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayTypeResponse * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap *soap, _tempuri__GetNamesOfMethodsOfAssayTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMethodsOfAssayTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMethodsOfAssayType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfMethodsOfAssayType::assayType = NULL;
}

void _tempuri__GetNamesOfMethodsOfAssayType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetNamesOfMethodsOfAssayType::assayType);
#endif
}

int _tempuri__GetNamesOfMethodsOfAssayType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMethodsOfAssayType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:assayType", -1, &a->_tempuri__GetNamesOfMethodsOfAssayType::assayType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMethodsOfAssayType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMethodsOfAssayType(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMethodsOfAssayType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, sizeof(_tempuri__GetNamesOfMethodsOfAssayType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMethodsOfAssayType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_assayType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assayType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:assayType", &a->_tempuri__GetNamesOfMethodsOfAssayType::assayType, "xsd:string"))
				{	soap_flag_assayType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMethodsOfAssayType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, sizeof(_tempuri__GetNamesOfMethodsOfAssayType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMethodsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMethodsOfAssayType *p;
	size_t k = sizeof(_tempuri__GetNamesOfMethodsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMethodsOfAssayType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMethodsOfAssayType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMethodsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMethodsOfAssayType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMethodsOfAssayType(soap, tag ? tag : "tempuri:GetNamesOfMethodsOfAssayType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMethodsOfAssayType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMethodsOfAssayType(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, _tempuri__GetNamesOfMethodsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMethodsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMethodsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetNamesOfMethodsResponse::GetNamesOfMethodsResult = NULL;
}

void _tempuri__GetNamesOfMethodsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->_tempuri__GetNamesOfMethodsResponse::GetNamesOfMethodsResult);
#endif
}

int _tempuri__GetNamesOfMethodsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMethodsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMethodsResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMethodsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsResponse), type))
		return soap->error;
	if (a->GetNamesOfMethodsResult)
		soap_element_result(soap, "tempuri:GetNamesOfMethodsResult");
	if (soap_out_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMethodsResult", -1, &a->_tempuri__GetNamesOfMethodsResponse::GetNamesOfMethodsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMethodsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMethodsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsResponse * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMethodsResponse(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethodsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMethodsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMethodsResponse, sizeof(_tempuri__GetNamesOfMethodsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMethodsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMethodsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetNamesOfMethodsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNamesOfMethodsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "tempuri:GetNamesOfMethodsResult", &a->_tempuri__GetNamesOfMethodsResponse::GetNamesOfMethodsResult, "arr:ArrayOfstring"))
				{	soap_flag_GetNamesOfMethodsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetNamesOfMethodsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMethodsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMethodsResponse, SOAP_TYPE__tempuri__GetNamesOfMethodsResponse, sizeof(_tempuri__GetNamesOfMethodsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMethodsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMethodsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMethodsResponse *p;
	size_t k = sizeof(_tempuri__GetNamesOfMethodsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMethodsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMethodsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMethodsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMethodsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMethodsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMethodsResponse(soap, tag ? tag : "tempuri:GetNamesOfMethodsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMethodsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMethodsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsResponse * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMethodsResponse(struct soap *soap, _tempuri__GetNamesOfMethodsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMethodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetNamesOfMethods::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tempuri__GetNamesOfMethods::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetNamesOfMethods::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetNamesOfMethods(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetNamesOfMethods(struct soap *soap, const char *tag, int id, const _tempuri__GetNamesOfMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetNamesOfMethods), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetNamesOfMethods::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tempuri__GetNamesOfMethods(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethods * SOAP_FMAC4 soap_in__tempuri__GetNamesOfMethods(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethods *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetNamesOfMethods*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetNamesOfMethods, sizeof(_tempuri__GetNamesOfMethods), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetNamesOfMethods)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetNamesOfMethods *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetNamesOfMethods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetNamesOfMethods, SOAP_TYPE__tempuri__GetNamesOfMethods, sizeof(_tempuri__GetNamesOfMethods), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetNamesOfMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetNamesOfMethods *p;
	size_t k = sizeof(_tempuri__GetNamesOfMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetNamesOfMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetNamesOfMethods);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetNamesOfMethods, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetNamesOfMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetNamesOfMethods::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetNamesOfMethods(soap, tag ? tag : "tempuri:GetNamesOfMethods", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetNamesOfMethods::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetNamesOfMethods(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethods * SOAP_FMAC4 soap_get__tempuri__GetNamesOfMethods(struct soap *soap, _tempuri__GetNamesOfMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetNamesOfMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__LastMessage(struct soap *soap, struct __wsrm__LastMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__LastMessage(struct soap *soap, const struct __wsrm__LastMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__LastMessage(struct soap *soap, const char *tag, int id, const struct __wsrm__LastMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__LastMessage * SOAP_FMAC4 soap_in___wsrm__LastMessage(struct soap *soap, const char *tag, struct __wsrm__LastMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__LastMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__LastMessage, sizeof(struct __wsrm__LastMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__LastMessage(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __wsrm__LastMessage * SOAP_FMAC2 soap_instantiate___wsrm__LastMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__LastMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__LastMessage *p;
	size_t k = sizeof(struct __wsrm__LastMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__LastMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__LastMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__LastMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__LastMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__LastMessage(struct soap *soap, const struct __wsrm__LastMessage *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__LastMessage(soap, tag ? tag : "-wsrm:LastMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__LastMessage * SOAP_FMAC4 soap_get___wsrm__LastMessage(struct soap *soap, struct __wsrm__LastMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__LastMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__AckRequested(struct soap *soap, struct __wsrm__AckRequested *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__AckRequested(struct soap *soap, const struct __wsrm__AckRequested *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__AckRequested(struct soap *soap, const char *tag, int id, const struct __wsrm__AckRequested *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__AckRequested * SOAP_FMAC4 soap_in___wsrm__AckRequested(struct soap *soap, const char *tag, struct __wsrm__AckRequested *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__AckRequested*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__AckRequested, sizeof(struct __wsrm__AckRequested), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__AckRequested(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __wsrm__AckRequested * SOAP_FMAC2 soap_instantiate___wsrm__AckRequested(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__AckRequested(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__AckRequested *p;
	size_t k = sizeof(struct __wsrm__AckRequested);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__AckRequested, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__AckRequested);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__AckRequested, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__AckRequested location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__AckRequested(struct soap *soap, const struct __wsrm__AckRequested *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__AckRequested(soap, tag ? tag : "-wsrm:AckRequested", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__AckRequested * SOAP_FMAC4 soap_get___wsrm__AckRequested(struct soap *soap, struct __wsrm__AckRequested *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__AckRequested(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__SequenceAcknowledgement(struct soap *soap, struct __wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__SequenceAcknowledgement(struct soap *soap, const struct __wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, const struct __wsrm__SequenceAcknowledgement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_in___wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct __wsrm__SequenceAcknowledgement *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__SequenceAcknowledgement*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__SequenceAcknowledgement, sizeof(struct __wsrm__SequenceAcknowledgement), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__SequenceAcknowledgement(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate___wsrm__SequenceAcknowledgement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__SequenceAcknowledgement(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__SequenceAcknowledgement *p;
	size_t k = sizeof(struct __wsrm__SequenceAcknowledgement);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__SequenceAcknowledgement, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__SequenceAcknowledgement);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__SequenceAcknowledgement, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__SequenceAcknowledgement location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__SequenceAcknowledgement(struct soap *soap, const struct __wsrm__SequenceAcknowledgement *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__SequenceAcknowledgement(soap, tag ? tag : "-wsrm:SequenceAcknowledgement", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_get___wsrm__SequenceAcknowledgement(struct soap *soap, struct __wsrm__SequenceAcknowledgement *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__TerminateSequenceResponse(struct soap *soap, struct __wsrm__TerminateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__TerminateSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__TerminateSequenceResponse(struct soap *soap, const struct __wsrm__TerminateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__TerminateSequenceResponseType(soap, &a->wsrm__TerminateSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__TerminateSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__TerminateSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, "wsrm:TerminateSequenceResponse", -1, &a->wsrm__TerminateSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC4 soap_in___wsrm__TerminateSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__TerminateSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__TerminateSequenceResponse = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__TerminateSequenceResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__TerminateSequenceResponse, sizeof(struct __wsrm__TerminateSequenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__TerminateSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__TerminateSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, "wsrm:TerminateSequenceResponse", &a->wsrm__TerminateSequenceResponse, "wsrm:TerminateSequenceResponseType"))
				{	soap_flag_wsrm__TerminateSequenceResponse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__TerminateSequenceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__TerminateSequenceResponse *p;
	size_t k = sizeof(struct __wsrm__TerminateSequenceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__TerminateSequenceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__TerminateSequenceResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__TerminateSequenceResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__TerminateSequenceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__TerminateSequenceResponse(struct soap *soap, const struct __wsrm__TerminateSequenceResponse *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__TerminateSequenceResponse(soap, tag ? tag : "-wsrm:TerminateSequenceResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC4 soap_get___wsrm__TerminateSequenceResponse(struct soap *soap, struct __wsrm__TerminateSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__TerminateSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CloseSequenceResponse(struct soap *soap, struct __wsrm__CloseSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CloseSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CloseSequenceResponse(struct soap *soap, const struct __wsrm__CloseSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__CloseSequenceResponseType(soap, &a->wsrm__CloseSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CloseSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__CloseSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__CloseSequenceResponseType(soap, "wsrm:CloseSequenceResponse", -1, &a->wsrm__CloseSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequenceResponse * SOAP_FMAC4 soap_in___wsrm__CloseSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__CloseSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__CloseSequenceResponse = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__CloseSequenceResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CloseSequenceResponse, sizeof(struct __wsrm__CloseSequenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CloseSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CloseSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__CloseSequenceResponseType(soap, "wsrm:CloseSequenceResponse", &a->wsrm__CloseSequenceResponse, "wsrm:CloseSequenceResponseType"))
				{	soap_flag_wsrm__CloseSequenceResponse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__CloseSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CloseSequenceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__CloseSequenceResponse *p;
	size_t k = sizeof(struct __wsrm__CloseSequenceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__CloseSequenceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__CloseSequenceResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__CloseSequenceResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__CloseSequenceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CloseSequenceResponse(struct soap *soap, const struct __wsrm__CloseSequenceResponse *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__CloseSequenceResponse(soap, tag ? tag : "-wsrm:CloseSequenceResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequenceResponse * SOAP_FMAC4 soap_get___wsrm__CloseSequenceResponse(struct soap *soap, struct __wsrm__CloseSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CloseSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CreateSequenceResponse(struct soap *soap, struct __wsrm__CreateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CreateSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CreateSequenceResponse(struct soap *soap, const struct __wsrm__CreateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__CreateSequenceResponseType(soap, &a->wsrm__CreateSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CreateSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__CreateSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__CreateSequenceResponseType(soap, "wsrm:CreateSequenceResponse", -1, &a->wsrm__CreateSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequenceResponse * SOAP_FMAC4 soap_in___wsrm__CreateSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__CreateSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__CreateSequenceResponse = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__CreateSequenceResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CreateSequenceResponse, sizeof(struct __wsrm__CreateSequenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CreateSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CreateSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__CreateSequenceResponseType(soap, "wsrm:CreateSequenceResponse", &a->wsrm__CreateSequenceResponse, "wsrm:CreateSequenceResponseType"))
				{	soap_flag_wsrm__CreateSequenceResponse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__CreateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CreateSequenceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__CreateSequenceResponse *p;
	size_t k = sizeof(struct __wsrm__CreateSequenceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__CreateSequenceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__CreateSequenceResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__CreateSequenceResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__CreateSequenceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CreateSequenceResponse(struct soap *soap, const struct __wsrm__CreateSequenceResponse *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__CreateSequenceResponse(soap, tag ? tag : "-wsrm:CreateSequenceResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequenceResponse * SOAP_FMAC4 soap_get___wsrm__CreateSequenceResponse(struct soap *soap, struct __wsrm__CreateSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CreateSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__TerminateSequence(struct soap *soap, struct __wsrm__TerminateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__TerminateSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__TerminateSequence(struct soap *soap, const struct __wsrm__TerminateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__TerminateSequenceType(soap, &a->wsrm__TerminateSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__TerminateSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__TerminateSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__TerminateSequenceType(soap, "wsrm:TerminateSequence", -1, &a->wsrm__TerminateSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequence * SOAP_FMAC4 soap_in___wsrm__TerminateSequence(struct soap *soap, const char *tag, struct __wsrm__TerminateSequence *a, const char *type)
{
	size_t soap_flag_wsrm__TerminateSequence = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__TerminateSequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__TerminateSequence, sizeof(struct __wsrm__TerminateSequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__TerminateSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__TerminateSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__TerminateSequenceType(soap, "wsrm:TerminateSequence", &a->wsrm__TerminateSequence, "wsrm:TerminateSequenceType"))
				{	soap_flag_wsrm__TerminateSequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__TerminateSequence * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__TerminateSequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__TerminateSequence *p;
	size_t k = sizeof(struct __wsrm__TerminateSequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__TerminateSequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__TerminateSequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__TerminateSequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__TerminateSequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__TerminateSequence(struct soap *soap, const struct __wsrm__TerminateSequence *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__TerminateSequence(soap, tag ? tag : "-wsrm:TerminateSequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequence * SOAP_FMAC4 soap_get___wsrm__TerminateSequence(struct soap *soap, struct __wsrm__TerminateSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__TerminateSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CloseSequence(struct soap *soap, struct __wsrm__CloseSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CloseSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CloseSequence(struct soap *soap, const struct __wsrm__CloseSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__CloseSequenceType(soap, &a->wsrm__CloseSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CloseSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__CloseSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__CloseSequenceType(soap, "wsrm:CloseSequence", -1, &a->wsrm__CloseSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequence * SOAP_FMAC4 soap_in___wsrm__CloseSequence(struct soap *soap, const char *tag, struct __wsrm__CloseSequence *a, const char *type)
{
	size_t soap_flag_wsrm__CloseSequence = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__CloseSequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CloseSequence, sizeof(struct __wsrm__CloseSequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CloseSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CloseSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__CloseSequenceType(soap, "wsrm:CloseSequence", &a->wsrm__CloseSequence, "wsrm:CloseSequenceType"))
				{	soap_flag_wsrm__CloseSequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__CloseSequence * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CloseSequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__CloseSequence *p;
	size_t k = sizeof(struct __wsrm__CloseSequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__CloseSequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__CloseSequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__CloseSequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__CloseSequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CloseSequence(struct soap *soap, const struct __wsrm__CloseSequence *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__CloseSequence(soap, tag ? tag : "-wsrm:CloseSequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequence * SOAP_FMAC4 soap_get___wsrm__CloseSequence(struct soap *soap, struct __wsrm__CloseSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CloseSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CreateSequence(struct soap *soap, struct __wsrm__CreateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CreateSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CreateSequence(struct soap *soap, const struct __wsrm__CreateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrm__CreateSequenceType(soap, &a->wsrm__CreateSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CreateSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__CreateSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsrm__CreateSequenceType(soap, "wsrm:CreateSequence", -1, &a->wsrm__CreateSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequence * SOAP_FMAC4 soap_in___wsrm__CreateSequence(struct soap *soap, const char *tag, struct __wsrm__CreateSequence *a, const char *type)
{
	size_t soap_flag_wsrm__CreateSequence = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsrm__CreateSequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CreateSequence, sizeof(struct __wsrm__CreateSequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CreateSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CreateSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__CreateSequenceType(soap, "wsrm:CreateSequence", &a->wsrm__CreateSequence, "wsrm:CreateSequenceType"))
				{	soap_flag_wsrm__CreateSequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsrm__CreateSequence * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CreateSequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsrm__CreateSequence *p;
	size_t k = sizeof(struct __wsrm__CreateSequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsrm__CreateSequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsrm__CreateSequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsrm__CreateSequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsrm__CreateSequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CreateSequence(struct soap *soap, const struct __wsrm__CreateSequence *a, const char *tag, const char *type)
{
	if (soap_out___wsrm__CreateSequence(soap, tag ? tag : "-wsrm:CreateSequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequence * SOAP_FMAC4 soap_get___wsrm__CreateSequence(struct soap *soap, struct __wsrm__CreateSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CreateSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_None(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_None *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_None *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_None *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__SequenceAcknowledgement_None*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, sizeof(struct _wsrm__SequenceAcknowledgement_None), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_None(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_None *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, sizeof(struct _wsrm__SequenceAcknowledgement_None), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_None(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_None(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__SequenceAcknowledgement_None *p;
	size_t k = sizeof(struct _wsrm__SequenceAcknowledgement_None);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__SequenceAcknowledgement_None);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__SequenceAcknowledgement_None, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__SequenceAcknowledgement_None location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_None(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_None *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__SequenceAcknowledgement_None(soap, tag ? tag : "wsrm:SequenceAcknowledgement-None", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_None(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ULONG64(soap, &a->Upper);
	soap_default_ULONG64(soap, &a->Lower);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *type)
{
	soap_set_attr(soap, "Upper", soap_ULONG642s(soap, a->Upper), 1);
	soap_set_attr(soap, "Lower", soap_ULONG642s(soap, a->Lower), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a);
	if (soap_s2ULONG64(soap, soap_attr_value(soap, "Upper", 5, 1), &a->Upper))
		return NULL;
	if (soap_s2ULONG64(soap, soap_attr_value(soap, "Lower", 5, 1), &a->Lower))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *p;
	size_t k = sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__SequenceAcknowledgement_AcknowledgementRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag ? tag : "wsrm:SequenceAcknowledgement-AcknowledgementRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_Final *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_Final *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_Final *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__SequenceAcknowledgement_Final*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, sizeof(struct _wsrm__SequenceAcknowledgement_Final), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_Final(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_Final *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, sizeof(struct _wsrm__SequenceAcknowledgement_Final), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_Final(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_Final(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__SequenceAcknowledgement_Final *p;
	size_t k = sizeof(struct _wsrm__SequenceAcknowledgement_Final);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__SequenceAcknowledgement_Final);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__SequenceAcknowledgement_Final, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__SequenceAcknowledgement_Final location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_Final *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__SequenceAcknowledgement_Final(soap, tag ? tag : "wsrm:SequenceAcknowledgement-Final", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_Final(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__UsesSequenceSSL(struct soap *soap, const struct _wsrm__UsesSequenceSSL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, int id, const struct _wsrm__UsesSequenceSSL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__UsesSequenceSSL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL * SOAP_FMAC4 soap_in__wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSSL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__UsesSequenceSSL*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__UsesSequenceSSL, sizeof(struct _wsrm__UsesSequenceSSL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__UsesSequenceSSL(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSSL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__UsesSequenceSSL, SOAP_TYPE__wsrm__UsesSequenceSSL, sizeof(struct _wsrm__UsesSequenceSSL), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__UsesSequenceSSL * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSSL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__UsesSequenceSSL(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__UsesSequenceSSL *p;
	size_t k = sizeof(struct _wsrm__UsesSequenceSSL);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__UsesSequenceSSL, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__UsesSequenceSSL);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__UsesSequenceSSL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__UsesSequenceSSL location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__UsesSequenceSSL(struct soap *soap, const struct _wsrm__UsesSequenceSSL *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__UsesSequenceSSL(soap, tag ? tag : "wsrm:UsesSequenceSSL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL * SOAP_FMAC4 soap_get__wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__UsesSequenceSSL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__UsesSequenceSTR(struct soap *soap, struct _wsrm__UsesSequenceSTR *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__UsesSequenceSTR(struct soap *soap, const struct _wsrm__UsesSequenceSTR *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__UsesSequenceSTR(struct soap *soap, const char *tag, int id, const struct _wsrm__UsesSequenceSTR *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__UsesSequenceSTR), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSTR * SOAP_FMAC4 soap_in__wsrm__UsesSequenceSTR(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSTR *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__UsesSequenceSTR*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__UsesSequenceSTR, sizeof(struct _wsrm__UsesSequenceSTR), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__UsesSequenceSTR(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSTR *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__UsesSequenceSTR, SOAP_TYPE__wsrm__UsesSequenceSTR, sizeof(struct _wsrm__UsesSequenceSTR), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__UsesSequenceSTR * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSTR(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__UsesSequenceSTR(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__UsesSequenceSTR *p;
	size_t k = sizeof(struct _wsrm__UsesSequenceSTR);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__UsesSequenceSTR, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__UsesSequenceSTR);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__UsesSequenceSTR, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__UsesSequenceSTR location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__UsesSequenceSTR(struct soap *soap, const struct _wsrm__UsesSequenceSTR *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__UsesSequenceSTR(soap, tag ? tag : "wsrm:UsesSequenceSTR", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSTR * SOAP_FMAC4 soap_get__wsrm__UsesSequenceSTR(struct soap *soap, struct _wsrm__UsesSequenceSTR *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__UsesSequenceSTR(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	a->__sizeNack = 0;
	a->Nack = NULL;
	a->Final = NULL;
	a->__sizeAcknowledgementRange = 0;
	a->AcknowledgementRange = NULL;
	a->None = NULL;
	a->netrm__BufferRemaining = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement(struct soap *soap, const struct _wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	if (a->Nack)
	{	int i;
		for (i = 0; i < (int)a->__sizeNack; i++)
		{
			soap_embedded(soap, a->Nack + i, SOAP_TYPE_ULONG64);
		}
	}
	soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, &a->Final);
	if (a->AcknowledgementRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeAcknowledgementRange; i++)
		{
			soap_embedded(soap, a->AcknowledgementRange + i, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange);
			soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a->AcknowledgementRange + i);
		}
	}
	soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(soap, &a->None);
	soap_serialize_PointerToint(soap, &a->netrm__BufferRemaining);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (a->Nack)
	{	int i;
		for (i = 0; i < (int)a->__sizeNack; i++)
			if (soap_out_ULONG64(soap, "wsrm:Nack", -1, a->Nack + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, "wsrm:Final", -1, &a->Final, ""))
		return soap->error;
	if (a->AcknowledgementRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeAcknowledgementRange; i++)
			if (soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:AcknowledgementRange", -1, a->AcknowledgementRange + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, "wsrm:None", -1, &a->None, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "netrm:BufferRemaining", -1, &a->netrm__BufferRemaining, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	struct soap_blist *soap_blist_Nack = NULL;
	size_t soap_flag_Final = 1;
	struct soap_blist *soap_blist_AcknowledgementRange = NULL;
	size_t soap_flag_None = 1;
	size_t soap_flag_netrm__BufferRemaining = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrm__SequenceAcknowledgement*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:Nack", 1, NULL))
			{	if (a->Nack == NULL)
				{	if (soap_blist_Nack == NULL)
						soap_blist_Nack = soap_alloc_block(soap);
					a->Nack = (ULONG64 *)soap_push_block_max(soap, soap_blist_Nack, sizeof(ULONG64));
					if (a->Nack == NULL)
						return NULL;
					soap_default_ULONG64(soap, a->Nack);
				}
				soap_revert(soap);
				if (soap_in_ULONG64(soap, "wsrm:Nack", a->Nack, "xsd:unsignedLong"))
				{	a->__sizeNack++;
					a->Nack = NULL;
					continue;
				}
			}
			if (soap_flag_Final && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, "wsrm:Final", &a->Final, ""))
				{	soap_flag_Final--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:AcknowledgementRange", 1, NULL))
			{	if (a->AcknowledgementRange == NULL)
				{	if (soap_blist_AcknowledgementRange == NULL)
						soap_blist_AcknowledgementRange = soap_alloc_block(soap);
					a->AcknowledgementRange = soap_block<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange>::push(soap, soap_blist_AcknowledgementRange);
					if (a->AcknowledgementRange == NULL)
						return NULL;
					soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a->AcknowledgementRange);
				}
				soap_revert(soap);
				if (soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:AcknowledgementRange", a->AcknowledgementRange, ""))
				{	a->__sizeAcknowledgementRange++;
					a->AcknowledgementRange = NULL;
					continue;
				}
			}
			if (soap_flag_None && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, "wsrm:None", &a->None, ""))
				{	soap_flag_None--;
					continue;
				}
			}
			if (soap_flag_netrm__BufferRemaining && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "netrm:BufferRemaining", &a->netrm__BufferRemaining, "xsd:int"))
				{	soap_flag_netrm__BufferRemaining--;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Nack)
			soap_pop_block(soap, soap_blist_Nack);
		if (a->__sizeNack)
		{	a->Nack = (ULONG64 *)soap_save_block(soap, soap_blist_Nack, NULL, 1);
		}
		else
		{	a->Nack = NULL;
			if (soap_blist_Nack)
				soap_end_block(soap, soap_blist_Nack);
		}
		if (a->AcknowledgementRange)
			soap_block<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange>::pop(soap, soap_blist_AcknowledgementRange);
		if (a->__sizeAcknowledgementRange)
		{	a->AcknowledgementRange = soap_new__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a->__sizeAcknowledgementRange);
			if (!a->AcknowledgementRange)
				return NULL;
			soap_block<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange>::save(soap, soap_blist_AcknowledgementRange, a->AcknowledgementRange);
		}
		else
		{	a->AcknowledgementRange = NULL;
			if (soap_blist_AcknowledgementRange)
				soap_block<struct _wsrm__SequenceAcknowledgement_AcknowledgementRange>::end(soap, soap_blist_AcknowledgementRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement, SOAP_TYPE__wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsrm__SequenceAcknowledgement *p;
	size_t k = sizeof(struct _wsrm__SequenceAcknowledgement);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrm__SequenceAcknowledgement, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsrm__SequenceAcknowledgement);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsrm__SequenceAcknowledgement, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsrm__SequenceAcknowledgement location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement(struct soap *soap, const struct _wsrm__SequenceAcknowledgement *a, const char *tag, const char *type)
{
	if (soap_out__wsrm__SequenceAcknowledgement(soap, tag ? tag : "wsrm:SequenceAcknowledgement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->AcksTo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__AcceptType(struct soap *soap, const struct wsrm__AcceptType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AcksTo, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->AcksTo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__AcceptType(struct soap *soap, const char *tag, int id, const struct wsrm__AcceptType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__AcceptType), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", -1, &a->AcksTo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__AcceptType * SOAP_FMAC4 soap_in_wsrm__AcceptType(struct soap *soap, const char *tag, struct wsrm__AcceptType *a, const char *type)
{
	size_t soap_flag_AcksTo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__AcceptType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__AcceptType, sizeof(struct wsrm__AcceptType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__AcceptType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcksTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", &a->AcksTo, "wsa5:EndpointReferenceType"))
				{	soap_flag_AcksTo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AcksTo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__AcceptType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__AcceptType, SOAP_TYPE_wsrm__AcceptType, sizeof(struct wsrm__AcceptType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__AcceptType * SOAP_FMAC2 soap_instantiate_wsrm__AcceptType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__AcceptType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__AcceptType *p;
	size_t k = sizeof(struct wsrm__AcceptType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__AcceptType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__AcceptType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__AcceptType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__AcceptType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__AcceptType(struct soap *soap, const struct wsrm__AcceptType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__AcceptType(soap, tag ? tag : "wsrm:AcceptType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AcceptType * SOAP_FMAC4 soap_get_wsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__AcceptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__OfferType(struct soap *soap, struct wsrm__OfferType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	soap_default_wsa5__EndpointReferenceType(soap, &a->Endpoint);
	a->Expires = NULL;
	a->IncompleteSequenceBehavior = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__OfferType(struct soap *soap, const struct wsrm__OfferType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_embedded(soap, &a->Endpoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->Endpoint);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, &a->IncompleteSequenceBehavior);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__OfferType(struct soap *soap, const char *tag, int id, const struct wsrm__OfferType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__OfferType), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:Endpoint", -1, &a->Endpoint, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", -1, &a->IncompleteSequenceBehavior, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__OfferType * SOAP_FMAC4 soap_in_wsrm__OfferType(struct soap *soap, const char *tag, struct wsrm__OfferType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Endpoint = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_IncompleteSequenceBehavior = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__OfferType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__OfferType, sizeof(struct wsrm__OfferType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__OfferType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:Endpoint", &a->Endpoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_Endpoint--;
					continue;
				}
			}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap_flag_IncompleteSequenceBehavior && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", &a->IncompleteSequenceBehavior, "wsrm:IncompleteSequenceBehaviorType"))
				{	soap_flag_IncompleteSequenceBehavior--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier || soap_flag_Endpoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__OfferType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__OfferType, SOAP_TYPE_wsrm__OfferType, sizeof(struct wsrm__OfferType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__OfferType * SOAP_FMAC2 soap_instantiate_wsrm__OfferType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__OfferType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__OfferType *p;
	size_t k = sizeof(struct wsrm__OfferType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__OfferType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__OfferType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__OfferType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__OfferType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__OfferType(struct soap *soap, const struct wsrm__OfferType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__OfferType(soap, tag ? tag : "wsrm:OfferType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__OfferType * SOAP_FMAC4 soap_get_wsrm__OfferType(struct soap *soap, struct wsrm__OfferType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__OfferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__TerminateSequenceResponseType(struct soap *soap, const struct wsrm__TerminateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__TerminateSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__TerminateSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__TerminateSequenceResponseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__TerminateSequenceResponseType, sizeof(struct wsrm__TerminateSequenceResponseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__TerminateSequenceResponseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__TerminateSequenceResponseType, SOAP_TYPE_wsrm__TerminateSequenceResponseType, sizeof(struct wsrm__TerminateSequenceResponseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__TerminateSequenceResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__TerminateSequenceResponseType *p;
	size_t k = sizeof(struct wsrm__TerminateSequenceResponseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__TerminateSequenceResponseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__TerminateSequenceResponseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__TerminateSequenceResponseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__TerminateSequenceResponseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__TerminateSequenceResponseType(struct soap *soap, const struct wsrm__TerminateSequenceResponseType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__TerminateSequenceResponseType(soap, tag ? tag : "wsrm:TerminateSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__TerminateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__TerminateSequenceType(struct soap *soap, const struct wsrm__TerminateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__TerminateSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__TerminateSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__TerminateSequenceType), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType * SOAP_FMAC4 soap_in_wsrm__TerminateSequenceType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__TerminateSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__TerminateSequenceType, sizeof(struct wsrm__TerminateSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__TerminateSequenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__TerminateSequenceType, SOAP_TYPE_wsrm__TerminateSequenceType, sizeof(struct wsrm__TerminateSequenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__TerminateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__TerminateSequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__TerminateSequenceType *p;
	size_t k = sizeof(struct wsrm__TerminateSequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__TerminateSequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__TerminateSequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__TerminateSequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__TerminateSequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__TerminateSequenceType(struct soap *soap, const struct wsrm__TerminateSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__TerminateSequenceType(soap, tag ? tag : "wsrm:TerminateSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType * SOAP_FMAC4 soap_get_wsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__TerminateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CloseSequenceResponseType(struct soap *soap, const struct wsrm__CloseSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__CloseSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CloseSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__CloseSequenceResponseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CloseSequenceResponseType, sizeof(struct wsrm__CloseSequenceResponseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CloseSequenceResponseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CloseSequenceResponseType, SOAP_TYPE_wsrm__CloseSequenceResponseType, sizeof(struct wsrm__CloseSequenceResponseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__CloseSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CloseSequenceResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__CloseSequenceResponseType *p;
	size_t k = sizeof(struct wsrm__CloseSequenceResponseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__CloseSequenceResponseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__CloseSequenceResponseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__CloseSequenceResponseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__CloseSequenceResponseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CloseSequenceResponseType(struct soap *soap, const struct wsrm__CloseSequenceResponseType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__CloseSequenceResponseType(soap, tag ? tag : "wsrm:CloseSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CloseSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CloseSequenceType(struct soap *soap, const struct wsrm__CloseSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CloseSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__CloseSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CloseSequenceType), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType * SOAP_FMAC4 soap_in_wsrm__CloseSequenceType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__CloseSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CloseSequenceType, sizeof(struct wsrm__CloseSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CloseSequenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CloseSequenceType, SOAP_TYPE_wsrm__CloseSequenceType, sizeof(struct wsrm__CloseSequenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__CloseSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CloseSequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__CloseSequenceType *p;
	size_t k = sizeof(struct wsrm__CloseSequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__CloseSequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__CloseSequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__CloseSequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__CloseSequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CloseSequenceType(struct soap *soap, const struct wsrm__CloseSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__CloseSequenceType(soap, tag ? tag : "wsrm:CloseSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType * SOAP_FMAC4 soap_get_wsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CloseSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	a->Expires = NULL;
	a->IncompleteSequenceBehavior = NULL;
	a->Accept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CreateSequenceResponseType(struct soap *soap, const struct wsrm__CreateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, &a->IncompleteSequenceBehavior);
	soap_serialize_PointerTowsrm__AcceptType(soap, &a->Accept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__CreateSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CreateSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", -1, &a->IncompleteSequenceBehavior, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__AcceptType(soap, "wsrm:Accept", -1, &a->Accept, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_IncompleteSequenceBehavior = 1;
	size_t soap_flag_Accept = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__CreateSequenceResponseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CreateSequenceResponseType, sizeof(struct wsrm__CreateSequenceResponseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CreateSequenceResponseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap_flag_IncompleteSequenceBehavior && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", &a->IncompleteSequenceBehavior, "wsrm:IncompleteSequenceBehaviorType"))
				{	soap_flag_IncompleteSequenceBehavior--;
					continue;
				}
			}
			if (soap_flag_Accept && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__AcceptType(soap, "wsrm:Accept", &a->Accept, "wsrm:AcceptType"))
				{	soap_flag_Accept--;
					continue;
				}
			}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CreateSequenceResponseType, SOAP_TYPE_wsrm__CreateSequenceResponseType, sizeof(struct wsrm__CreateSequenceResponseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__CreateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CreateSequenceResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__CreateSequenceResponseType *p;
	size_t k = sizeof(struct wsrm__CreateSequenceResponseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__CreateSequenceResponseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__CreateSequenceResponseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__CreateSequenceResponseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__CreateSequenceResponseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CreateSequenceResponseType(struct soap *soap, const struct wsrm__CreateSequenceResponseType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__CreateSequenceResponseType(soap, tag ? tag : "wsrm:CreateSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CreateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->AcksTo);
	a->Expires = NULL;
	a->Offer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CreateSequenceType(struct soap *soap, const struct wsrm__CreateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AcksTo, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->AcksTo);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__OfferType(soap, &a->Offer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CreateSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__CreateSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CreateSequenceType), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", -1, &a->AcksTo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__OfferType(soap, "wsrm:Offer", -1, &a->Offer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType * SOAP_FMAC4 soap_in_wsrm__CreateSequenceType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceType *a, const char *type)
{
	size_t soap_flag_AcksTo = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_Offer = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__CreateSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CreateSequenceType, sizeof(struct wsrm__CreateSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CreateSequenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcksTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", &a->AcksTo, "wsa5:EndpointReferenceType"))
				{	soap_flag_AcksTo--;
					continue;
				}
			}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap_flag_Offer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__OfferType(soap, "wsrm:Offer", &a->Offer, "wsrm:OfferType"))
				{	soap_flag_Offer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AcksTo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CreateSequenceType, SOAP_TYPE_wsrm__CreateSequenceType, sizeof(struct wsrm__CreateSequenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__CreateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CreateSequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__CreateSequenceType *p;
	size_t k = sizeof(struct wsrm__CreateSequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__CreateSequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__CreateSequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__CreateSequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__CreateSequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CreateSequenceType(struct soap *soap, const struct wsrm__CreateSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__CreateSequenceType(soap, tag ? tag : "wsrm:CreateSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType * SOAP_FMAC4 soap_get_wsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CreateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsrm__FaultCodes(soap, &a->FaultCode);
	a->Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__SequenceFaultType(struct soap *soap, const struct wsrm__SequenceFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__SequenceFaultType(struct soap *soap, const char *tag, int id, const struct wsrm__SequenceFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__SequenceFaultType), type))
		return soap->error;
	if (soap_out_wsrm__FaultCodes(soap, "wsrm:FaultCode", -1, &a->FaultCode, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "wsrm:Detail", -1, &a->Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType * SOAP_FMAC4 soap_in_wsrm__SequenceFaultType(struct soap *soap, const char *tag, struct wsrm__SequenceFaultType *a, const char *type)
{
	size_t soap_flag_FaultCode = 1;
	size_t soap_flag_Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__SequenceFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__SequenceFaultType, sizeof(struct wsrm__SequenceFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__SequenceFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FaultCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsrm__FaultCodes(soap, "wsrm:FaultCode", &a->FaultCode, "wsrm:FaultCodes"))
				{	soap_flag_FaultCode--;
					continue;
				}
			}
			if (soap_flag_Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "wsrm:Detail", &a->Detail, ""))
				{	soap_flag_Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FaultCode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__SequenceFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__SequenceFaultType, SOAP_TYPE_wsrm__SequenceFaultType, sizeof(struct wsrm__SequenceFaultType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__SequenceFaultType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__SequenceFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__SequenceFaultType *p;
	size_t k = sizeof(struct wsrm__SequenceFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__SequenceFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__SequenceFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__SequenceFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__SequenceFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__SequenceFaultType(struct soap *soap, const struct wsrm__SequenceFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__SequenceFaultType(soap, tag ? tag : "wsrm:SequenceFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType * SOAP_FMAC4 soap_get_wsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__SequenceFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__AckRequestedType(struct soap *soap, const struct wsrm__AckRequestedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__AckRequestedType(struct soap *soap, const char *tag, int id, const struct wsrm__AckRequestedType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__AckRequestedType), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__AckRequestedType * SOAP_FMAC4 soap_in_wsrm__AckRequestedType(struct soap *soap, const char *tag, struct wsrm__AckRequestedType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__AckRequestedType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__AckRequestedType, sizeof(struct wsrm__AckRequestedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__AckRequestedType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__AckRequestedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__AckRequestedType, SOAP_TYPE_wsrm__AckRequestedType, sizeof(struct wsrm__AckRequestedType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__AckRequestedType * SOAP_FMAC2 soap_instantiate_wsrm__AckRequestedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__AckRequestedType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__AckRequestedType *p;
	size_t k = sizeof(struct wsrm__AckRequestedType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__AckRequestedType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__AckRequestedType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__AckRequestedType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__AckRequestedType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__AckRequestedType(struct soap *soap, const struct wsrm__AckRequestedType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__AckRequestedType(soap, tag ? tag : "wsrm:AckRequestedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AckRequestedType * SOAP_FMAC4 soap_get_wsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__AckRequestedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	soap_default_ULONG64(soap, &a->MessageNumber);
	a->LastMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__SequenceType(struct soap *soap, const struct wsrm__SequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_embedded(soap, &a->MessageNumber, SOAP_TYPE_ULONG64);
	soap_serialize_PointerTo_wsrm__UsesSequenceSSL(soap, &a->LastMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__SequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__SequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__SequenceType), type))
		return soap->error;
	if (!a->Identifier)
	{	if (soap_element_empty(soap, "wsrm:Identifier"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsrm:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_ULONG64(soap, "wsrm:MessageNumber", -1, &a->MessageNumber, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, "wsrm:LastMessage", -1, &a->LastMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__SequenceType * SOAP_FMAC4 soap_in_wsrm__SequenceType(struct soap *soap, const char *tag, struct wsrm__SequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_MessageNumber = 1;
	size_t soap_flag_LastMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrm__SequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__SequenceType, sizeof(struct wsrm__SequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__SequenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrm:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_MessageNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ULONG64(soap, "wsrm:MessageNumber", &a->MessageNumber, "xsd:unsignedLong"))
				{	soap_flag_MessageNumber--;
					continue;
				}
			}
			if (soap_flag_LastMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, "wsrm:LastMessage", &a->LastMessage, ""))
				{	soap_flag_LastMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Identifier || soap_flag_MessageNumber > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrm__SequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__SequenceType, SOAP_TYPE_wsrm__SequenceType, sizeof(struct wsrm__SequenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsrm__SequenceType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__SequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsrm__SequenceType *p;
	size_t k = sizeof(struct wsrm__SequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrm__SequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsrm__SequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsrm__SequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsrm__SequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__SequenceType(struct soap *soap, const struct wsrm__SequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsrm__SequenceType(soap, tag ? tag : "wsrm:SequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceType * SOAP_FMAC4 soap_get_wsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__SequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wst__RequestSecurityTokenCollection(struct soap *soap, struct __wst__RequestSecurityTokenCollection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wst__RequestSecurityTokenCollection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wst__RequestSecurityTokenCollection(struct soap *soap, const struct __wst__RequestSecurityTokenCollection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__RequestSecurityTokenCollectionType(soap, &a->wst__RequestSecurityTokenCollection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wst__RequestSecurityTokenCollection(struct soap *soap, const char *tag, int id, const struct __wst__RequestSecurityTokenCollection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowst__RequestSecurityTokenCollectionType(soap, "wst:RequestSecurityTokenCollection", -1, &a->wst__RequestSecurityTokenCollection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityTokenCollection * SOAP_FMAC4 soap_in___wst__RequestSecurityTokenCollection(struct soap *soap, const char *tag, struct __wst__RequestSecurityTokenCollection *a, const char *type)
{
	size_t soap_flag_wst__RequestSecurityTokenCollection = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wst__RequestSecurityTokenCollection*)soap_id_enter(soap, "", a, SOAP_TYPE___wst__RequestSecurityTokenCollection, sizeof(struct __wst__RequestSecurityTokenCollection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wst__RequestSecurityTokenCollection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wst__RequestSecurityTokenCollection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestSecurityTokenCollectionType(soap, "wst:RequestSecurityTokenCollection", &a->wst__RequestSecurityTokenCollection, "wst:RequestSecurityTokenCollectionType"))
				{	soap_flag_wst__RequestSecurityTokenCollection--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wst__RequestSecurityTokenCollection * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityTokenCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wst__RequestSecurityTokenCollection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wst__RequestSecurityTokenCollection *p;
	size_t k = sizeof(struct __wst__RequestSecurityTokenCollection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wst__RequestSecurityTokenCollection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wst__RequestSecurityTokenCollection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wst__RequestSecurityTokenCollection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wst__RequestSecurityTokenCollection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wst__RequestSecurityTokenCollection(struct soap *soap, const struct __wst__RequestSecurityTokenCollection *a, const char *tag, const char *type)
{
	if (soap_out___wst__RequestSecurityTokenCollection(soap, tag ? tag : "-wst:RequestSecurityTokenCollection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityTokenCollection * SOAP_FMAC4 soap_get___wst__RequestSecurityTokenCollection(struct soap *soap, struct __wst__RequestSecurityTokenCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in___wst__RequestSecurityTokenCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wst__RequestSecurityTokenResponse(struct soap *soap, struct __wst__RequestSecurityTokenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wst__RequestSecurityTokenResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wst__RequestSecurityTokenResponse(struct soap *soap, const struct __wst__RequestSecurityTokenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__RequestSecurityTokenResponseType(soap, &a->wst__RequestSecurityTokenResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wst__RequestSecurityTokenResponse(struct soap *soap, const char *tag, int id, const struct __wst__RequestSecurityTokenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowst__RequestSecurityTokenResponseType(soap, "wst:RequestSecurityTokenResponse", -1, &a->wst__RequestSecurityTokenResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityTokenResponse * SOAP_FMAC4 soap_in___wst__RequestSecurityTokenResponse(struct soap *soap, const char *tag, struct __wst__RequestSecurityTokenResponse *a, const char *type)
{
	size_t soap_flag_wst__RequestSecurityTokenResponse = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wst__RequestSecurityTokenResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___wst__RequestSecurityTokenResponse, sizeof(struct __wst__RequestSecurityTokenResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wst__RequestSecurityTokenResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wst__RequestSecurityTokenResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestSecurityTokenResponseType(soap, "wst:RequestSecurityTokenResponse", &a->wst__RequestSecurityTokenResponse, "wst:RequestSecurityTokenResponseType"))
				{	soap_flag_wst__RequestSecurityTokenResponse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wst__RequestSecurityTokenResponse * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wst__RequestSecurityTokenResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wst__RequestSecurityTokenResponse *p;
	size_t k = sizeof(struct __wst__RequestSecurityTokenResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wst__RequestSecurityTokenResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wst__RequestSecurityTokenResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wst__RequestSecurityTokenResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wst__RequestSecurityTokenResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wst__RequestSecurityTokenResponse(struct soap *soap, const struct __wst__RequestSecurityTokenResponse *a, const char *tag, const char *type)
{
	if (soap_out___wst__RequestSecurityTokenResponse(soap, tag ? tag : "-wst:RequestSecurityTokenResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityTokenResponse * SOAP_FMAC4 soap_get___wst__RequestSecurityTokenResponse(struct soap *soap, struct __wst__RequestSecurityTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wst__RequestSecurityTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wst__RequestSecurityToken(struct soap *soap, struct __wst__RequestSecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wst__RequestSecurityToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wst__RequestSecurityToken(struct soap *soap, const struct __wst__RequestSecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__RequestSecurityTokenType(soap, &a->wst__RequestSecurityToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wst__RequestSecurityToken(struct soap *soap, const char *tag, int id, const struct __wst__RequestSecurityToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowst__RequestSecurityTokenType(soap, "wst:RequestSecurityToken", -1, &a->wst__RequestSecurityToken, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityToken * SOAP_FMAC4 soap_in___wst__RequestSecurityToken(struct soap *soap, const char *tag, struct __wst__RequestSecurityToken *a, const char *type)
{
	size_t soap_flag_wst__RequestSecurityToken = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wst__RequestSecurityToken*)soap_id_enter(soap, "", a, SOAP_TYPE___wst__RequestSecurityToken, sizeof(struct __wst__RequestSecurityToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wst__RequestSecurityToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wst__RequestSecurityToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestSecurityTokenType(soap, "wst:RequestSecurityToken", &a->wst__RequestSecurityToken, "wst:RequestSecurityTokenType"))
				{	soap_flag_wst__RequestSecurityToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wst__RequestSecurityToken * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wst__RequestSecurityToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wst__RequestSecurityToken *p;
	size_t k = sizeof(struct __wst__RequestSecurityToken);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wst__RequestSecurityToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wst__RequestSecurityToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wst__RequestSecurityToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wst__RequestSecurityToken location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wst__RequestSecurityToken(struct soap *soap, const struct __wst__RequestSecurityToken *a, const char *tag, const char *type)
{
	if (soap_out___wst__RequestSecurityToken(soap, tag ? tag : "-wst:RequestSecurityToken", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wst__RequestSecurityToken * SOAP_FMAC4 soap_get___wst__RequestSecurityToken(struct soap *soap, struct __wst__RequestSecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___wst__RequestSecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Participants(struct soap *soap, const struct wst__ParticipantsType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Participants(soap, tag ? tag : "wst:Participants", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__DelegateTo(struct soap *soap, const struct wst__DelegateToType *a, const char *tag, const char *type)
{
	if (soap_out__wst__DelegateTo(soap, tag ? tag : "wst:DelegateTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__UseKey(struct soap *soap, const struct wst__UseKeyType *a, const char *tag, const char *type)
{
	if (soap_out__wst__UseKey(soap, tag ? tag : "wst:UseKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__ProofEncryption(struct soap *soap, const struct wst__ProofEncryptionType *a, const char *tag, const char *type)
{
	if (soap_out__wst__ProofEncryption(soap, tag ? tag : "wst:ProofEncryption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Encryption(struct soap *soap, const struct wst__EncryptionType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Encryption(soap, tag ? tag : "wst:Encryption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Issuer(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Issuer(soap, tag ? tag : "wst:Issuer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__OnBehalfOf(struct soap *soap, const struct wst__OnBehalfOfType *a, const char *tag, const char *type)
{
	if (soap_out__wst__OnBehalfOf(soap, tag ? tag : "wst:OnBehalfOf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Authenticator(struct soap *soap, const struct wst__AuthenticatorType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Authenticator(soap, tag ? tag : "wst:Authenticator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__KeyExchangeToken(struct soap *soap, const struct wst__KeyExchangeTokenType *a, const char *tag, const char *type)
{
	if (soap_out__wst__KeyExchangeToken(soap, tag ? tag : "wst:KeyExchangeToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestKET(struct soap *soap, const struct wst__RequestKETType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestKET(soap, tag ? tag : "wst:RequestKET", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__BinaryExchange(struct soap *soap, const struct wst__BinaryExchangeType *a, const char *tag, const char *type)
{
	if (soap_out__wst__BinaryExchange(soap, tag ? tag : "wst:BinaryExchange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__SignChallengeResponse(struct soap *soap, const struct wst__SignChallengeType *a, const char *tag, const char *type)
{
	if (soap_out__wst__SignChallengeResponse(soap, tag ? tag : "wst:SignChallengeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__SignChallenge(struct soap *soap, const struct wst__SignChallengeType *a, const char *tag, const char *type)
{
	if (soap_out__wst__SignChallenge(soap, tag ? tag : "wst:SignChallenge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Status(struct soap *soap, const struct wst__StatusType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Status(soap, tag ? tag : "wst:Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__ValidateTarget(struct soap *soap, const struct wst__ValidateTargetType *a, const char *tag, const char *type)
{
	if (soap_out__wst__ValidateTarget(soap, tag ? tag : "wst:ValidateTarget", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestedTokenCancelled(struct soap *soap, const struct wst__RequestedTokenCancelledType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestedTokenCancelled(soap, tag ? tag : "wst:RequestedTokenCancelled", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__CancelTarget(struct soap *soap, const struct wst__CancelTargetType *a, const char *tag, const char *type)
{
	if (soap_out__wst__CancelTarget(soap, tag ? tag : "wst:CancelTarget", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Renewing(struct soap *soap, const struct wst__RenewingType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Renewing(soap, tag ? tag : "wst:Renewing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__AllowPostdating(struct soap *soap, const struct wst__AllowPostdatingType *a, const char *tag, const char *type)
{
	if (soap_out__wst__AllowPostdating(soap, tag ? tag : "wst:AllowPostdating", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RenewTarget(struct soap *soap, const struct wst__RenewTargetType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RenewTarget(soap, tag ? tag : "wst:RenewTarget", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__IssuedTokens(struct soap *soap, const struct wst__RequestSecurityTokenResponseCollectionType *a, const char *tag, const char *type)
{
	if (soap_out__wst__IssuedTokens(soap, tag ? tag : "wst:IssuedTokens", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestedProofToken(struct soap *soap, const struct wst__RequestedProofTokenType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestedProofToken(soap, tag ? tag : "wst:RequestedProofToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestedUnattachedReference(struct soap *soap, const struct wst__RequestedReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestedUnattachedReference(soap, tag ? tag : "wst:RequestedUnattachedReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestedAttachedReference(struct soap *soap, const struct wst__RequestedReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestedAttachedReference(soap, tag ? tag : "wst:RequestedAttachedReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestSecurityTokenResponseCollection(struct soap *soap, const struct wst__RequestSecurityTokenResponseCollectionType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestSecurityTokenResponseCollection(soap, tag ? tag : "wst:RequestSecurityTokenResponseCollection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestSecurityTokenCollection(struct soap *soap, const struct wst__RequestSecurityTokenCollectionType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestSecurityTokenCollection(soap, tag ? tag : "wst:RequestSecurityTokenCollection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Lifetime(struct soap *soap, const struct wst__LifetimeType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Lifetime(soap, tag ? tag : "wst:Lifetime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Entropy(struct soap *soap, const struct wst__EntropyType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Entropy(soap, tag ? tag : "wst:Entropy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Claims(struct soap *soap, const struct wst__ClaimsType *a, const char *tag, const char *type)
{
	if (soap_out__wst__Claims(soap, tag ? tag : "wst:Claims", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__BinarySecret(struct soap *soap, const struct wst__BinarySecretType *a, const char *tag, const char *type)
{
	if (soap_out__wst__BinarySecret(soap, tag ? tag : "wst:BinarySecret", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestedSecurityToken(struct soap *soap, const struct wst__RequestedSecurityTokenType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestedSecurityToken(soap, tag ? tag : "wst:RequestedSecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestSecurityTokenResponse(struct soap *soap, const struct wst__RequestSecurityTokenResponseType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestSecurityTokenResponse(soap, tag ? tag : "wst:RequestSecurityTokenResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestSecurityToken(struct soap *soap, const struct wst__RequestSecurityTokenType *a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestSecurityToken(soap, tag ? tag : "wst:RequestSecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__ParticipantType(struct soap *soap, struct wst__ParticipantType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__ParticipantType(struct soap *soap, const struct wst__ParticipantType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__ParticipantType(struct soap *soap, const char *tag, int id, const struct wst__ParticipantType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__ParticipantType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__ParticipantType * SOAP_FMAC4 soap_in_wst__ParticipantType(struct soap *soap, const char *tag, struct wst__ParticipantType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__ParticipantType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__ParticipantType, sizeof(struct wst__ParticipantType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__ParticipantType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__ParticipantType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__ParticipantType, SOAP_TYPE_wst__ParticipantType, sizeof(struct wst__ParticipantType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__ParticipantType * SOAP_FMAC2 soap_instantiate_wst__ParticipantType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__ParticipantType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__ParticipantType *p;
	size_t k = sizeof(struct wst__ParticipantType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__ParticipantType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__ParticipantType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__ParticipantType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__ParticipantType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__ParticipantType(struct soap *soap, const struct wst__ParticipantType *a, const char *tag, const char *type)
{
	if (soap_out_wst__ParticipantType(soap, tag ? tag : "wst:ParticipantType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ParticipantType * SOAP_FMAC4 soap_get_wst__ParticipantType(struct soap *soap, struct wst__ParticipantType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__ParticipantType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__ParticipantsType(struct soap *soap, struct wst__ParticipantsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Primary = NULL;
	a->__sizeParticipant = 0;
	a->Participant = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__ParticipantsType(struct soap *soap, const struct wst__ParticipantsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__ParticipantType(soap, &a->Primary);
	if (a->Participant)
	{	int i;
		for (i = 0; i < (int)a->__sizeParticipant; i++)
		{
			soap_embedded(soap, a->Participant + i, SOAP_TYPE_wst__ParticipantType);
			soap_serialize_wst__ParticipantType(soap, a->Participant + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__ParticipantsType(struct soap *soap, const char *tag, int id, const struct wst__ParticipantsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__ParticipantsType), type))
		return soap->error;
	if (soap_out_PointerTowst__ParticipantType(soap, "wst:Primary", -1, &a->Primary, ""))
		return soap->error;
	if (a->Participant)
	{	int i;
		for (i = 0; i < (int)a->__sizeParticipant; i++)
			if (soap_out_wst__ParticipantType(soap, "wst:Participant", -1, a->Participant + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__ParticipantsType * SOAP_FMAC4 soap_in_wst__ParticipantsType(struct soap *soap, const char *tag, struct wst__ParticipantsType *a, const char *type)
{
	size_t soap_flag_Primary = 1;
	struct soap_blist *soap_blist_Participant = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__ParticipantsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__ParticipantsType, sizeof(struct wst__ParticipantsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__ParticipantsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Primary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__ParticipantType(soap, "wst:Primary", &a->Primary, "wst:ParticipantType"))
				{	soap_flag_Primary--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wst:Participant", 1, NULL))
			{	if (a->Participant == NULL)
				{	if (soap_blist_Participant == NULL)
						soap_blist_Participant = soap_alloc_block(soap);
					a->Participant = soap_block<struct wst__ParticipantType>::push(soap, soap_blist_Participant);
					if (a->Participant == NULL)
						return NULL;
					soap_default_wst__ParticipantType(soap, a->Participant);
				}
				soap_revert(soap);
				if (soap_in_wst__ParticipantType(soap, "wst:Participant", a->Participant, "wst:ParticipantType"))
				{	a->__sizeParticipant++;
					a->Participant = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Participant)
			soap_block<struct wst__ParticipantType>::pop(soap, soap_blist_Participant);
		if (a->__sizeParticipant)
		{	a->Participant = soap_new_wst__ParticipantType(soap, a->__sizeParticipant);
			if (!a->Participant)
				return NULL;
			soap_block<struct wst__ParticipantType>::save(soap, soap_blist_Participant, a->Participant);
		}
		else
		{	a->Participant = NULL;
			if (soap_blist_Participant)
				soap_block<struct wst__ParticipantType>::end(soap, soap_blist_Participant);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__ParticipantsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__ParticipantsType, SOAP_TYPE_wst__ParticipantsType, sizeof(struct wst__ParticipantsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__ParticipantsType * SOAP_FMAC2 soap_instantiate_wst__ParticipantsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__ParticipantsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__ParticipantsType *p;
	size_t k = sizeof(struct wst__ParticipantsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__ParticipantsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__ParticipantsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__ParticipantsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__ParticipantsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__ParticipantsType(struct soap *soap, const struct wst__ParticipantsType *a, const char *tag, const char *type)
{
	if (soap_out_wst__ParticipantsType(soap, tag ? tag : "wst:ParticipantsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ParticipantsType * SOAP_FMAC4 soap_get_wst__ParticipantsType(struct soap *soap, struct wst__ParticipantsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__ParticipantsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__DelegateToType(struct soap *soap, struct wst__DelegateToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__DelegateToType(struct soap *soap, const struct wst__DelegateToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__DelegateToType(struct soap *soap, const char *tag, int id, const struct wst__DelegateToType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__DelegateToType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__DelegateToType * SOAP_FMAC4 soap_in_wst__DelegateToType(struct soap *soap, const char *tag, struct wst__DelegateToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__DelegateToType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__DelegateToType, sizeof(struct wst__DelegateToType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__DelegateToType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__DelegateToType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__DelegateToType, SOAP_TYPE_wst__DelegateToType, sizeof(struct wst__DelegateToType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__DelegateToType * SOAP_FMAC2 soap_instantiate_wst__DelegateToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__DelegateToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__DelegateToType *p;
	size_t k = sizeof(struct wst__DelegateToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__DelegateToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__DelegateToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__DelegateToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__DelegateToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__DelegateToType(struct soap *soap, const struct wst__DelegateToType *a, const char *tag, const char *type)
{
	if (soap_out_wst__DelegateToType(soap, tag ? tag : "wst:DelegateToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__DelegateToType * SOAP_FMAC4 soap_get_wst__DelegateToType(struct soap *soap, struct wst__DelegateToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__DelegateToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__UseKeyType(struct soap *soap, struct wst__UseKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__UseKeyType(struct soap *soap, const struct wst__UseKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__UseKeyType(struct soap *soap, const char *tag, int id, const struct wst__UseKeyType *a, const char *type)
{
	if (a->Sig)
		soap_set_attr(soap, "Sig", soap_string2s(soap, a->Sig), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__UseKeyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__UseKeyType * SOAP_FMAC4 soap_in_wst__UseKeyType(struct soap *soap, const char *tag, struct wst__UseKeyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__UseKeyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__UseKeyType, sizeof(struct wst__UseKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__UseKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1, 0), &a->Sig))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__UseKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__UseKeyType, SOAP_TYPE_wst__UseKeyType, sizeof(struct wst__UseKeyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__UseKeyType * SOAP_FMAC2 soap_instantiate_wst__UseKeyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__UseKeyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__UseKeyType *p;
	size_t k = sizeof(struct wst__UseKeyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__UseKeyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__UseKeyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__UseKeyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__UseKeyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__UseKeyType(struct soap *soap, const struct wst__UseKeyType *a, const char *tag, const char *type)
{
	if (soap_out_wst__UseKeyType(soap, tag ? tag : "wst:UseKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__UseKeyType * SOAP_FMAC4 soap_get_wst__UseKeyType(struct soap *soap, struct wst__UseKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__UseKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__ProofEncryptionType(struct soap *soap, struct wst__ProofEncryptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__ProofEncryptionType(struct soap *soap, const struct wst__ProofEncryptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__ProofEncryptionType(struct soap *soap, const char *tag, int id, const struct wst__ProofEncryptionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__ProofEncryptionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__ProofEncryptionType * SOAP_FMAC4 soap_in_wst__ProofEncryptionType(struct soap *soap, const char *tag, struct wst__ProofEncryptionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__ProofEncryptionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__ProofEncryptionType, sizeof(struct wst__ProofEncryptionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__ProofEncryptionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__ProofEncryptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__ProofEncryptionType, SOAP_TYPE_wst__ProofEncryptionType, sizeof(struct wst__ProofEncryptionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__ProofEncryptionType * SOAP_FMAC2 soap_instantiate_wst__ProofEncryptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__ProofEncryptionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__ProofEncryptionType *p;
	size_t k = sizeof(struct wst__ProofEncryptionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__ProofEncryptionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__ProofEncryptionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__ProofEncryptionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__ProofEncryptionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__ProofEncryptionType(struct soap *soap, const struct wst__ProofEncryptionType *a, const char *tag, const char *type)
{
	if (soap_out_wst__ProofEncryptionType(soap, tag ? tag : "wst:ProofEncryptionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ProofEncryptionType * SOAP_FMAC4 soap_get_wst__ProofEncryptionType(struct soap *soap, struct wst__ProofEncryptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__ProofEncryptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__EncryptionType(struct soap *soap, struct wst__EncryptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__EncryptionType(struct soap *soap, const struct wst__EncryptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__EncryptionType(struct soap *soap, const char *tag, int id, const struct wst__EncryptionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__EncryptionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__EncryptionType * SOAP_FMAC4 soap_in_wst__EncryptionType(struct soap *soap, const char *tag, struct wst__EncryptionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__EncryptionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__EncryptionType, sizeof(struct wst__EncryptionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__EncryptionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__EncryptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__EncryptionType, SOAP_TYPE_wst__EncryptionType, sizeof(struct wst__EncryptionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__EncryptionType * SOAP_FMAC2 soap_instantiate_wst__EncryptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__EncryptionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__EncryptionType *p;
	size_t k = sizeof(struct wst__EncryptionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__EncryptionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__EncryptionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__EncryptionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__EncryptionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__EncryptionType(struct soap *soap, const struct wst__EncryptionType *a, const char *tag, const char *type)
{
	if (soap_out_wst__EncryptionType(soap, tag ? tag : "wst:EncryptionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__EncryptionType * SOAP_FMAC4 soap_get_wst__EncryptionType(struct soap *soap, struct wst__EncryptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__EncryptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__OnBehalfOfType(struct soap *soap, struct wst__OnBehalfOfType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__OnBehalfOfType(struct soap *soap, const struct wst__OnBehalfOfType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__OnBehalfOfType(struct soap *soap, const char *tag, int id, const struct wst__OnBehalfOfType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__OnBehalfOfType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__OnBehalfOfType * SOAP_FMAC4 soap_in_wst__OnBehalfOfType(struct soap *soap, const char *tag, struct wst__OnBehalfOfType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__OnBehalfOfType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__OnBehalfOfType, sizeof(struct wst__OnBehalfOfType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__OnBehalfOfType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__OnBehalfOfType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__OnBehalfOfType, SOAP_TYPE_wst__OnBehalfOfType, sizeof(struct wst__OnBehalfOfType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__OnBehalfOfType * SOAP_FMAC2 soap_instantiate_wst__OnBehalfOfType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__OnBehalfOfType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__OnBehalfOfType *p;
	size_t k = sizeof(struct wst__OnBehalfOfType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__OnBehalfOfType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__OnBehalfOfType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__OnBehalfOfType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__OnBehalfOfType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__OnBehalfOfType(struct soap *soap, const struct wst__OnBehalfOfType *a, const char *tag, const char *type)
{
	if (soap_out_wst__OnBehalfOfType(soap, tag ? tag : "wst:OnBehalfOfType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__OnBehalfOfType * SOAP_FMAC4 soap_get_wst__OnBehalfOfType(struct soap *soap, struct wst__OnBehalfOfType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__OnBehalfOfType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__AuthenticatorType(struct soap *soap, struct wst__AuthenticatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CombinedHash);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__AuthenticatorType(struct soap *soap, const struct wst__AuthenticatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CombinedHash);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__AuthenticatorType(struct soap *soap, const char *tag, int id, const struct wst__AuthenticatorType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__AuthenticatorType), type))
		return soap->error;
	if (soap_out_string(soap, "wst:CombinedHash", -1, (char*const*)&a->CombinedHash, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__AuthenticatorType * SOAP_FMAC4 soap_in_wst__AuthenticatorType(struct soap *soap, const char *tag, struct wst__AuthenticatorType *a, const char *type)
{
	size_t soap_flag_CombinedHash = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__AuthenticatorType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__AuthenticatorType, sizeof(struct wst__AuthenticatorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__AuthenticatorType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CombinedHash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:CombinedHash", (char**)&a->CombinedHash, "xsd:string"))
				{	soap_flag_CombinedHash--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__AuthenticatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__AuthenticatorType, SOAP_TYPE_wst__AuthenticatorType, sizeof(struct wst__AuthenticatorType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__AuthenticatorType * SOAP_FMAC2 soap_instantiate_wst__AuthenticatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__AuthenticatorType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__AuthenticatorType *p;
	size_t k = sizeof(struct wst__AuthenticatorType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__AuthenticatorType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__AuthenticatorType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__AuthenticatorType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__AuthenticatorType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__AuthenticatorType(struct soap *soap, const struct wst__AuthenticatorType *a, const char *tag, const char *type)
{
	if (soap_out_wst__AuthenticatorType(soap, tag ? tag : "wst:AuthenticatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__AuthenticatorType * SOAP_FMAC4 soap_get_wst__AuthenticatorType(struct soap *soap, struct wst__AuthenticatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__AuthenticatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__KeyExchangeTokenType(struct soap *soap, struct wst__KeyExchangeTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__KeyExchangeTokenType(struct soap *soap, const struct wst__KeyExchangeTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__KeyExchangeTokenType(struct soap *soap, const char *tag, int id, const struct wst__KeyExchangeTokenType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__KeyExchangeTokenType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__KeyExchangeTokenType * SOAP_FMAC4 soap_in_wst__KeyExchangeTokenType(struct soap *soap, const char *tag, struct wst__KeyExchangeTokenType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__KeyExchangeTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__KeyExchangeTokenType, sizeof(struct wst__KeyExchangeTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__KeyExchangeTokenType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__KeyExchangeTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__KeyExchangeTokenType, SOAP_TYPE_wst__KeyExchangeTokenType, sizeof(struct wst__KeyExchangeTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__KeyExchangeTokenType * SOAP_FMAC2 soap_instantiate_wst__KeyExchangeTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__KeyExchangeTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__KeyExchangeTokenType *p;
	size_t k = sizeof(struct wst__KeyExchangeTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__KeyExchangeTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__KeyExchangeTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__KeyExchangeTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__KeyExchangeTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__KeyExchangeTokenType(struct soap *soap, const struct wst__KeyExchangeTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wst__KeyExchangeTokenType(soap, tag ? tag : "wst:KeyExchangeTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__KeyExchangeTokenType * SOAP_FMAC4 soap_get_wst__KeyExchangeTokenType(struct soap *soap, struct wst__KeyExchangeTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__KeyExchangeTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestKETType(struct soap *soap, struct wst__RequestKETType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestKETType(struct soap *soap, const struct wst__RequestKETType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestKETType(struct soap *soap, const char *tag, int id, const struct wst__RequestKETType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestKETType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestKETType * SOAP_FMAC4 soap_in_wst__RequestKETType(struct soap *soap, const char *tag, struct wst__RequestKETType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestKETType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestKETType, sizeof(struct wst__RequestKETType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestKETType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestKETType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestKETType, SOAP_TYPE_wst__RequestKETType, sizeof(struct wst__RequestKETType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestKETType * SOAP_FMAC2 soap_instantiate_wst__RequestKETType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestKETType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestKETType *p;
	size_t k = sizeof(struct wst__RequestKETType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestKETType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestKETType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestKETType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestKETType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestKETType(struct soap *soap, const struct wst__RequestKETType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestKETType(soap, tag ? tag : "wst:RequestKETType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestKETType * SOAP_FMAC4 soap_get_wst__RequestKETType(struct soap *soap, struct wst__RequestKETType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestKETType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__BinaryExchangeType(struct soap *soap, struct wst__BinaryExchangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__BinaryExchangeType(struct soap *soap, const struct wst__BinaryExchangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__BinaryExchangeType(struct soap *soap, const char *tag, int id, const struct wst__BinaryExchangeType *a, const char *type)
{
	soap_set_attr(soap, "ValueType", a->ValueType ? soap_string2s(soap, a->ValueType) : "", 1);
	soap_set_attr(soap, "EncodingType", a->EncodingType ? soap_string2s(soap, a->EncodingType) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wst__BinaryExchangeType * SOAP_FMAC4 soap_in_wst__BinaryExchangeType(struct soap *soap, const char *tag, struct wst__BinaryExchangeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wst__BinaryExchangeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__BinaryExchangeType, sizeof(struct wst__BinaryExchangeType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wst__BinaryExchangeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 1), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 1), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wst:BinaryExchangeType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wst__BinaryExchangeType * SOAP_FMAC2 soap_instantiate_wst__BinaryExchangeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__BinaryExchangeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__BinaryExchangeType *p;
	size_t k = sizeof(struct wst__BinaryExchangeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__BinaryExchangeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__BinaryExchangeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__BinaryExchangeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__BinaryExchangeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__BinaryExchangeType(struct soap *soap, const struct wst__BinaryExchangeType *a, const char *tag, const char *type)
{
	if (soap_out_wst__BinaryExchangeType(soap, tag ? tag : "wst:BinaryExchangeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__BinaryExchangeType * SOAP_FMAC4 soap_get_wst__BinaryExchangeType(struct soap *soap, struct wst__BinaryExchangeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__BinaryExchangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__SignChallengeType(struct soap *soap, struct wst__SignChallengeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Challenge);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__SignChallengeType(struct soap *soap, const struct wst__SignChallengeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Challenge);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__SignChallengeType(struct soap *soap, const char *tag, int id, const struct wst__SignChallengeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__SignChallengeType), type))
		return soap->error;
	if (!a->Challenge)
	{	if (soap_element_empty(soap, "wst:Challenge"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wst:Challenge", -1, (char*const*)&a->Challenge, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__SignChallengeType * SOAP_FMAC4 soap_in_wst__SignChallengeType(struct soap *soap, const char *tag, struct wst__SignChallengeType *a, const char *type)
{
	size_t soap_flag_Challenge = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__SignChallengeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__SignChallengeType, sizeof(struct wst__SignChallengeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__SignChallengeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Challenge && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:Challenge", (char**)&a->Challenge, "xsd:string"))
				{	soap_flag_Challenge--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Challenge))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wst__SignChallengeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__SignChallengeType, SOAP_TYPE_wst__SignChallengeType, sizeof(struct wst__SignChallengeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__SignChallengeType * SOAP_FMAC2 soap_instantiate_wst__SignChallengeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__SignChallengeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__SignChallengeType *p;
	size_t k = sizeof(struct wst__SignChallengeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__SignChallengeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__SignChallengeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__SignChallengeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__SignChallengeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__SignChallengeType(struct soap *soap, const struct wst__SignChallengeType *a, const char *tag, const char *type)
{
	if (soap_out_wst__SignChallengeType(soap, tag ? tag : "wst:SignChallengeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__SignChallengeType * SOAP_FMAC4 soap_get_wst__SignChallengeType(struct soap *soap, struct wst__SignChallengeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__SignChallengeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__StatusType(struct soap *soap, struct wst__StatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Code);
	soap_default_string(soap, &a->Reason);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__StatusType(struct soap *soap, const struct wst__StatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Code);
	soap_serialize_string(soap, (char*const*)&a->Reason);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__StatusType(struct soap *soap, const char *tag, int id, const struct wst__StatusType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__StatusType), type))
		return soap->error;
	if (!a->Code)
	{	if (soap_element_empty(soap, "wst:Code"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wst:Code", -1, (char*const*)&a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:Reason", -1, (char*const*)&a->Reason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__StatusType * SOAP_FMAC4 soap_in_wst__StatusType(struct soap *soap, const char *tag, struct wst__StatusType *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_Reason = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__StatusType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__StatusType, sizeof(struct wst__StatusType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__StatusType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:Code", (char**)&a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			}
			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:Reason", (char**)&a->Reason, "xsd:string"))
				{	soap_flag_Reason--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Code))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wst__StatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__StatusType, SOAP_TYPE_wst__StatusType, sizeof(struct wst__StatusType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__StatusType * SOAP_FMAC2 soap_instantiate_wst__StatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__StatusType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__StatusType *p;
	size_t k = sizeof(struct wst__StatusType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__StatusType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__StatusType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__StatusType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__StatusType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__StatusType(struct soap *soap, const struct wst__StatusType *a, const char *tag, const char *type)
{
	if (soap_out_wst__StatusType(soap, tag ? tag : "wst:StatusType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__StatusType * SOAP_FMAC4 soap_get_wst__StatusType(struct soap *soap, struct wst__StatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__StatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__ValidateTargetType(struct soap *soap, struct wst__ValidateTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__ValidateTargetType(struct soap *soap, const struct wst__ValidateTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__ValidateTargetType(struct soap *soap, const char *tag, int id, const struct wst__ValidateTargetType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__ValidateTargetType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__ValidateTargetType * SOAP_FMAC4 soap_in_wst__ValidateTargetType(struct soap *soap, const char *tag, struct wst__ValidateTargetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__ValidateTargetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__ValidateTargetType, sizeof(struct wst__ValidateTargetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__ValidateTargetType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__ValidateTargetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__ValidateTargetType, SOAP_TYPE_wst__ValidateTargetType, sizeof(struct wst__ValidateTargetType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__ValidateTargetType * SOAP_FMAC2 soap_instantiate_wst__ValidateTargetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__ValidateTargetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__ValidateTargetType *p;
	size_t k = sizeof(struct wst__ValidateTargetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__ValidateTargetType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__ValidateTargetType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__ValidateTargetType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__ValidateTargetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__ValidateTargetType(struct soap *soap, const struct wst__ValidateTargetType *a, const char *tag, const char *type)
{
	if (soap_out_wst__ValidateTargetType(soap, tag ? tag : "wst:ValidateTargetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ValidateTargetType * SOAP_FMAC4 soap_get_wst__ValidateTargetType(struct soap *soap, struct wst__ValidateTargetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__ValidateTargetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestedTokenCancelledType(struct soap *soap, struct wst__RequestedTokenCancelledType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestedTokenCancelledType(struct soap *soap, const struct wst__RequestedTokenCancelledType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestedTokenCancelledType(struct soap *soap, const char *tag, int id, const struct wst__RequestedTokenCancelledType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestedTokenCancelledType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestedTokenCancelledType * SOAP_FMAC4 soap_in_wst__RequestedTokenCancelledType(struct soap *soap, const char *tag, struct wst__RequestedTokenCancelledType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestedTokenCancelledType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestedTokenCancelledType, sizeof(struct wst__RequestedTokenCancelledType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestedTokenCancelledType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedTokenCancelledType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestedTokenCancelledType, SOAP_TYPE_wst__RequestedTokenCancelledType, sizeof(struct wst__RequestedTokenCancelledType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestedTokenCancelledType * SOAP_FMAC2 soap_instantiate_wst__RequestedTokenCancelledType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestedTokenCancelledType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestedTokenCancelledType *p;
	size_t k = sizeof(struct wst__RequestedTokenCancelledType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestedTokenCancelledType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestedTokenCancelledType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestedTokenCancelledType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestedTokenCancelledType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestedTokenCancelledType(struct soap *soap, const struct wst__RequestedTokenCancelledType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestedTokenCancelledType(soap, tag ? tag : "wst:RequestedTokenCancelledType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedTokenCancelledType * SOAP_FMAC4 soap_get_wst__RequestedTokenCancelledType(struct soap *soap, struct wst__RequestedTokenCancelledType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestedTokenCancelledType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__CancelTargetType(struct soap *soap, struct wst__CancelTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__CancelTargetType(struct soap *soap, const struct wst__CancelTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__CancelTargetType(struct soap *soap, const char *tag, int id, const struct wst__CancelTargetType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__CancelTargetType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__CancelTargetType * SOAP_FMAC4 soap_in_wst__CancelTargetType(struct soap *soap, const char *tag, struct wst__CancelTargetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__CancelTargetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__CancelTargetType, sizeof(struct wst__CancelTargetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__CancelTargetType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__CancelTargetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__CancelTargetType, SOAP_TYPE_wst__CancelTargetType, sizeof(struct wst__CancelTargetType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__CancelTargetType * SOAP_FMAC2 soap_instantiate_wst__CancelTargetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__CancelTargetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__CancelTargetType *p;
	size_t k = sizeof(struct wst__CancelTargetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__CancelTargetType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__CancelTargetType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__CancelTargetType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__CancelTargetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__CancelTargetType(struct soap *soap, const struct wst__CancelTargetType *a, const char *tag, const char *type)
{
	if (soap_out_wst__CancelTargetType(soap, tag ? tag : "wst:CancelTargetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__CancelTargetType * SOAP_FMAC4 soap_get_wst__CancelTargetType(struct soap *soap, struct wst__CancelTargetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__CancelTargetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RenewingType(struct soap *soap, struct wst__RenewingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Allow);
	soap_default_string(soap, &a->OK);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RenewingType(struct soap *soap, const struct wst__RenewingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RenewingType(struct soap *soap, const char *tag, int id, const struct wst__RenewingType *a, const char *type)
{
	if (a->Allow)
		soap_set_attr(soap, "Allow", soap_string2s(soap, a->Allow), 1);
	if (a->OK)
		soap_set_attr(soap, "OK", soap_string2s(soap, a->OK), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RenewingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RenewingType * SOAP_FMAC4 soap_in_wst__RenewingType(struct soap *soap, const char *tag, struct wst__RenewingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RenewingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RenewingType, sizeof(struct wst__RenewingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RenewingType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Allow", 1, 0), &a->Allow))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "OK", 1, 0), &a->OK))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RenewingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RenewingType, SOAP_TYPE_wst__RenewingType, sizeof(struct wst__RenewingType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RenewingType * SOAP_FMAC2 soap_instantiate_wst__RenewingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RenewingType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RenewingType *p;
	size_t k = sizeof(struct wst__RenewingType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RenewingType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RenewingType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RenewingType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RenewingType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RenewingType(struct soap *soap, const struct wst__RenewingType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RenewingType(soap, tag ? tag : "wst:RenewingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RenewingType * SOAP_FMAC4 soap_get_wst__RenewingType(struct soap *soap, struct wst__RenewingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RenewingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__AllowPostdatingType(struct soap *soap, struct wst__AllowPostdatingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__AllowPostdatingType(struct soap *soap, const struct wst__AllowPostdatingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__AllowPostdatingType(struct soap *soap, const char *tag, int id, const struct wst__AllowPostdatingType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__AllowPostdatingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__AllowPostdatingType * SOAP_FMAC4 soap_in_wst__AllowPostdatingType(struct soap *soap, const char *tag, struct wst__AllowPostdatingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__AllowPostdatingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__AllowPostdatingType, sizeof(struct wst__AllowPostdatingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__AllowPostdatingType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__AllowPostdatingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__AllowPostdatingType, SOAP_TYPE_wst__AllowPostdatingType, sizeof(struct wst__AllowPostdatingType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__AllowPostdatingType * SOAP_FMAC2 soap_instantiate_wst__AllowPostdatingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__AllowPostdatingType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__AllowPostdatingType *p;
	size_t k = sizeof(struct wst__AllowPostdatingType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__AllowPostdatingType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__AllowPostdatingType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__AllowPostdatingType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__AllowPostdatingType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__AllowPostdatingType(struct soap *soap, const struct wst__AllowPostdatingType *a, const char *tag, const char *type)
{
	if (soap_out_wst__AllowPostdatingType(soap, tag ? tag : "wst:AllowPostdatingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__AllowPostdatingType * SOAP_FMAC4 soap_get_wst__AllowPostdatingType(struct soap *soap, struct wst__AllowPostdatingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__AllowPostdatingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RenewTargetType(struct soap *soap, struct wst__RenewTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RenewTargetType(struct soap *soap, const struct wst__RenewTargetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RenewTargetType(struct soap *soap, const char *tag, int id, const struct wst__RenewTargetType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RenewTargetType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RenewTargetType * SOAP_FMAC4 soap_in_wst__RenewTargetType(struct soap *soap, const char *tag, struct wst__RenewTargetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RenewTargetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RenewTargetType, sizeof(struct wst__RenewTargetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RenewTargetType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RenewTargetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RenewTargetType, SOAP_TYPE_wst__RenewTargetType, sizeof(struct wst__RenewTargetType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RenewTargetType * SOAP_FMAC2 soap_instantiate_wst__RenewTargetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RenewTargetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RenewTargetType *p;
	size_t k = sizeof(struct wst__RenewTargetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RenewTargetType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RenewTargetType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RenewTargetType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RenewTargetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RenewTargetType(struct soap *soap, const struct wst__RenewTargetType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RenewTargetType(soap, tag ? tag : "wst:RenewTargetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RenewTargetType * SOAP_FMAC4 soap_get_wst__RenewTargetType(struct soap *soap, struct wst__RenewTargetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RenewTargetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestedProofTokenType(struct soap *soap, struct wst__RequestedProofTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestedProofTokenType(struct soap *soap, const struct wst__RequestedProofTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestedProofTokenType(struct soap *soap, const char *tag, int id, const struct wst__RequestedProofTokenType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestedProofTokenType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestedProofTokenType * SOAP_FMAC4 soap_in_wst__RequestedProofTokenType(struct soap *soap, const char *tag, struct wst__RequestedProofTokenType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedKey = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestedProofTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestedProofTokenType, sizeof(struct wst__RequestedProofTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestedProofTokenType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedProofTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestedProofTokenType, SOAP_TYPE_wst__RequestedProofTokenType, sizeof(struct wst__RequestedProofTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestedProofTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestedProofTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestedProofTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestedProofTokenType *p;
	size_t k = sizeof(struct wst__RequestedProofTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestedProofTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestedProofTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestedProofTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestedProofTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestedProofTokenType(struct soap *soap, const struct wst__RequestedProofTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestedProofTokenType(soap, tag ? tag : "wst:RequestedProofTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedProofTokenType * SOAP_FMAC4 soap_get_wst__RequestedProofTokenType(struct soap *soap, struct wst__RequestedProofTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestedProofTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestedReferenceType(struct soap *soap, struct wst__RequestedReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestedReferenceType(struct soap *soap, const struct wst__RequestedReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference);
	soap_serialize__wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestedReferenceType(struct soap *soap, const char *tag, int id, const struct wst__RequestedReferenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestedReferenceType), type))
		return soap->error;
	if (soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestedReferenceType * SOAP_FMAC4 soap_in_wst__RequestedReferenceType(struct soap *soap, const char *tag, struct wst__RequestedReferenceType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestedReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestedReferenceType, sizeof(struct wst__RequestedReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestedReferenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsse__SecurityTokenReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wst__RequestedReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestedReferenceType, SOAP_TYPE_wst__RequestedReferenceType, sizeof(struct wst__RequestedReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestedReferenceType * SOAP_FMAC2 soap_instantiate_wst__RequestedReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestedReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestedReferenceType *p;
	size_t k = sizeof(struct wst__RequestedReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestedReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestedReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestedReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestedReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestedReferenceType(struct soap *soap, const struct wst__RequestedReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestedReferenceType(soap, tag ? tag : "wst:RequestedReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedReferenceType * SOAP_FMAC4 soap_get_wst__RequestedReferenceType(struct soap *soap, struct wst__RequestedReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestedReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, struct wst__RequestSecurityTokenResponseCollectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRequestSecurityTokenResponse = 0;
	a->RequestSecurityTokenResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const struct wst__RequestSecurityTokenResponseCollectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RequestSecurityTokenResponse)
	{	int i;
		for (i = 0; i < (int)a->__sizeRequestSecurityTokenResponse; i++)
		{
			soap_embedded(soap, a->RequestSecurityTokenResponse + i, SOAP_TYPE_wst__RequestSecurityTokenResponseType);
			soap_serialize_wst__RequestSecurityTokenResponseType(soap, a->RequestSecurityTokenResponse + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const char *tag, int id, const struct wst__RequestSecurityTokenResponseCollectionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType), type))
		return soap->error;
	soap_element_result(soap, "-sizeRequestSecurityTokenResponse");
	if (a->RequestSecurityTokenResponse)
	{	int i;
		for (i = 0; i < (int)a->__sizeRequestSecurityTokenResponse; i++)
			if (soap_out_wst__RequestSecurityTokenResponseType(soap, "wst:RequestSecurityTokenResponse", -1, a->RequestSecurityTokenResponse + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseCollectionType * SOAP_FMAC4 soap_in_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenResponseCollectionType *a, const char *type)
{
	struct soap_blist *soap_blist_RequestSecurityTokenResponse = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestSecurityTokenResponseCollectionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, sizeof(struct wst__RequestSecurityTokenResponseCollectionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestSecurityTokenResponseCollectionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wst:RequestSecurityTokenResponse", 1, NULL))
			{	if (a->RequestSecurityTokenResponse == NULL)
				{	if (soap_blist_RequestSecurityTokenResponse == NULL)
						soap_blist_RequestSecurityTokenResponse = soap_alloc_block(soap);
					a->RequestSecurityTokenResponse = soap_block<struct wst__RequestSecurityTokenResponseType>::push(soap, soap_blist_RequestSecurityTokenResponse);
					if (a->RequestSecurityTokenResponse == NULL)
						return NULL;
					soap_default_wst__RequestSecurityTokenResponseType(soap, a->RequestSecurityTokenResponse);
				}
				soap_revert(soap);
				if (soap_in_wst__RequestSecurityTokenResponseType(soap, "wst:RequestSecurityTokenResponse", a->RequestSecurityTokenResponse, "wst:RequestSecurityTokenResponseType"))
				{	a->__sizeRequestSecurityTokenResponse++;
					a->RequestSecurityTokenResponse = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRequestSecurityTokenResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RequestSecurityTokenResponse)
			soap_block<struct wst__RequestSecurityTokenResponseType>::pop(soap, soap_blist_RequestSecurityTokenResponse);
		if (a->__sizeRequestSecurityTokenResponse)
		{	a->RequestSecurityTokenResponse = soap_new_wst__RequestSecurityTokenResponseType(soap, a->__sizeRequestSecurityTokenResponse);
			if (!a->RequestSecurityTokenResponse)
				return NULL;
			soap_block<struct wst__RequestSecurityTokenResponseType>::save(soap, soap_blist_RequestSecurityTokenResponse, a->RequestSecurityTokenResponse);
		}
		else
		{	a->RequestSecurityTokenResponse = NULL;
			if (soap_blist_RequestSecurityTokenResponse)
				soap_block<struct wst__RequestSecurityTokenResponseType>::end(soap, soap_blist_RequestSecurityTokenResponse);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeRequestSecurityTokenResponse < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenResponseCollectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, sizeof(struct wst__RequestSecurityTokenResponseCollectionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestSecurityTokenResponseCollectionType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestSecurityTokenResponseCollectionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestSecurityTokenResponseCollectionType *p;
	size_t k = sizeof(struct wst__RequestSecurityTokenResponseCollectionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestSecurityTokenResponseCollectionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestSecurityTokenResponseCollectionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestSecurityTokenResponseCollectionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const struct wst__RequestSecurityTokenResponseCollectionType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestSecurityTokenResponseCollectionType(soap, tag ? tag : "wst:RequestSecurityTokenResponseCollectionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseCollectionType * SOAP_FMAC4 soap_get_wst__RequestSecurityTokenResponseCollectionType(struct soap *soap, struct wst__RequestSecurityTokenResponseCollectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestSecurityTokenResponseCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestSecurityTokenCollectionType(struct soap *soap, struct wst__RequestSecurityTokenCollectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRequestSecurityToken = 0;
	a->RequestSecurityToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestSecurityTokenCollectionType(struct soap *soap, const struct wst__RequestSecurityTokenCollectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RequestSecurityToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeRequestSecurityToken; i++)
		{
			soap_embedded(soap, a->RequestSecurityToken + i, SOAP_TYPE_wst__RequestSecurityTokenType);
			soap_serialize_wst__RequestSecurityTokenType(soap, a->RequestSecurityToken + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestSecurityTokenCollectionType(struct soap *soap, const char *tag, int id, const struct wst__RequestSecurityTokenCollectionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestSecurityTokenCollectionType), type))
		return soap->error;
	if (a->RequestSecurityToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeRequestSecurityToken; i++)
			if (soap_out_wst__RequestSecurityTokenType(soap, "wst:RequestSecurityToken", -1, a->RequestSecurityToken + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenCollectionType * SOAP_FMAC4 soap_in_wst__RequestSecurityTokenCollectionType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenCollectionType *a, const char *type)
{
	struct soap_blist *soap_blist_RequestSecurityToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestSecurityTokenCollectionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, sizeof(struct wst__RequestSecurityTokenCollectionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestSecurityTokenCollectionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wst:RequestSecurityToken", 1, NULL))
			{	if (a->RequestSecurityToken == NULL)
				{	if (soap_blist_RequestSecurityToken == NULL)
						soap_blist_RequestSecurityToken = soap_alloc_block(soap);
					a->RequestSecurityToken = soap_block<struct wst__RequestSecurityTokenType>::push(soap, soap_blist_RequestSecurityToken);
					if (a->RequestSecurityToken == NULL)
						return NULL;
					soap_default_wst__RequestSecurityTokenType(soap, a->RequestSecurityToken);
				}
				soap_revert(soap);
				if (soap_in_wst__RequestSecurityTokenType(soap, "wst:RequestSecurityToken", a->RequestSecurityToken, "wst:RequestSecurityTokenType"))
				{	a->__sizeRequestSecurityToken++;
					a->RequestSecurityToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RequestSecurityToken)
			soap_block<struct wst__RequestSecurityTokenType>::pop(soap, soap_blist_RequestSecurityToken);
		if (a->__sizeRequestSecurityToken)
		{	a->RequestSecurityToken = soap_new_wst__RequestSecurityTokenType(soap, a->__sizeRequestSecurityToken);
			if (!a->RequestSecurityToken)
				return NULL;
			soap_block<struct wst__RequestSecurityTokenType>::save(soap, soap_blist_RequestSecurityToken, a->RequestSecurityToken);
		}
		else
		{	a->RequestSecurityToken = NULL;
			if (soap_blist_RequestSecurityToken)
				soap_block<struct wst__RequestSecurityTokenType>::end(soap, soap_blist_RequestSecurityToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeRequestSecurityToken < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenCollectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, sizeof(struct wst__RequestSecurityTokenCollectionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestSecurityTokenCollectionType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenCollectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestSecurityTokenCollectionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestSecurityTokenCollectionType *p;
	size_t k = sizeof(struct wst__RequestSecurityTokenCollectionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestSecurityTokenCollectionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestSecurityTokenCollectionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestSecurityTokenCollectionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestSecurityTokenCollectionType(struct soap *soap, const struct wst__RequestSecurityTokenCollectionType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestSecurityTokenCollectionType(soap, tag ? tag : "wst:RequestSecurityTokenCollectionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenCollectionType * SOAP_FMAC4 soap_get_wst__RequestSecurityTokenCollectionType(struct soap *soap, struct wst__RequestSecurityTokenCollectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestSecurityTokenCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__LifetimeType(struct soap *soap, struct wst__LifetimeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__LifetimeType(struct soap *soap, const struct wst__LifetimeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->wsu__Created);
	soap_serialize_string(soap, (char*const*)&a->wsu__Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__LifetimeType(struct soap *soap, const char *tag, int id, const struct wst__LifetimeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__LifetimeType), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->wsu__Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, (char*const*)&a->wsu__Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__LifetimeType * SOAP_FMAC4 soap_in_wst__LifetimeType(struct soap *soap, const char *tag, struct wst__LifetimeType *a, const char *type)
{
	size_t soap_flag_wsu__Created = 1;
	size_t soap_flag_wsu__Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__LifetimeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__LifetimeType, sizeof(struct wst__LifetimeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__LifetimeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			}
			if (soap_flag_wsu__Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Expires", (char**)&a->wsu__Expires, "xsd:string"))
				{	soap_flag_wsu__Expires--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__LifetimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__LifetimeType, SOAP_TYPE_wst__LifetimeType, sizeof(struct wst__LifetimeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__LifetimeType * SOAP_FMAC2 soap_instantiate_wst__LifetimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__LifetimeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__LifetimeType *p;
	size_t k = sizeof(struct wst__LifetimeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__LifetimeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__LifetimeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__LifetimeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__LifetimeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__LifetimeType(struct soap *soap, const struct wst__LifetimeType *a, const char *tag, const char *type)
{
	if (soap_out_wst__LifetimeType(soap, tag ? tag : "wst:LifetimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__LifetimeType * SOAP_FMAC4 soap_get_wst__LifetimeType(struct soap *soap, struct wst__LifetimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__LifetimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__EntropyType(struct soap *soap, struct wst__EntropyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BinarySecret = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__EntropyType(struct soap *soap, const struct wst__EntropyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__BinarySecretType(soap, &a->BinarySecret);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__EntropyType(struct soap *soap, const char *tag, int id, const struct wst__EntropyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__EntropyType), type))
		return soap->error;
	if (soap_out_PointerTowst__BinarySecretType(soap, "wst:BinarySecret", -1, &a->BinarySecret, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__EntropyType * SOAP_FMAC4 soap_in_wst__EntropyType(struct soap *soap, const char *tag, struct wst__EntropyType *a, const char *type)
{
	size_t soap_flag_BinarySecret = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__EntropyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__EntropyType, sizeof(struct wst__EntropyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__EntropyType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BinarySecret && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__BinarySecretType(soap, "wst:BinarySecret", &a->BinarySecret, "wst:BinarySecretType"))
				{	soap_flag_BinarySecret--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__EntropyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__EntropyType, SOAP_TYPE_wst__EntropyType, sizeof(struct wst__EntropyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__EntropyType * SOAP_FMAC2 soap_instantiate_wst__EntropyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__EntropyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__EntropyType *p;
	size_t k = sizeof(struct wst__EntropyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__EntropyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__EntropyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__EntropyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__EntropyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__EntropyType(struct soap *soap, const struct wst__EntropyType *a, const char *tag, const char *type)
{
	if (soap_out_wst__EntropyType(soap, tag ? tag : "wst:EntropyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__EntropyType * SOAP_FMAC4 soap_get_wst__EntropyType(struct soap *soap, struct wst__EntropyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__EntropyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__ClaimsType(struct soap *soap, struct wst__ClaimsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__ClaimsType(struct soap *soap, const struct wst__ClaimsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__ClaimsType(struct soap *soap, const char *tag, int id, const struct wst__ClaimsType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", soap_string2s(soap, a->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__ClaimsType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__ClaimsType * SOAP_FMAC4 soap_in_wst__ClaimsType(struct soap *soap, const char *tag, struct wst__ClaimsType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__ClaimsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__ClaimsType, sizeof(struct wst__ClaimsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__ClaimsType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1, 0), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__ClaimsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__ClaimsType, SOAP_TYPE_wst__ClaimsType, sizeof(struct wst__ClaimsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__ClaimsType * SOAP_FMAC2 soap_instantiate_wst__ClaimsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__ClaimsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__ClaimsType *p;
	size_t k = sizeof(struct wst__ClaimsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__ClaimsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__ClaimsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__ClaimsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__ClaimsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__ClaimsType(struct soap *soap, const struct wst__ClaimsType *a, const char *tag, const char *type)
{
	if (soap_out_wst__ClaimsType(soap, tag ? tag : "wst:ClaimsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ClaimsType * SOAP_FMAC4 soap_get_wst__ClaimsType(struct soap *soap, struct wst__ClaimsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__ClaimsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__BinarySecretType(struct soap *soap, struct wst__BinarySecretType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__BinarySecretType(struct soap *soap, const struct wst__BinarySecretType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__BinarySecretType(struct soap *soap, const char *tag, int id, const struct wst__BinarySecretType *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wst__BinarySecretType * SOAP_FMAC4 soap_in_wst__BinarySecretType(struct soap *soap, const char *tag, struct wst__BinarySecretType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wst__BinarySecretType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__BinarySecretType, sizeof(struct wst__BinarySecretType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wst__BinarySecretType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wst:BinarySecretType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wst__BinarySecretType * SOAP_FMAC2 soap_instantiate_wst__BinarySecretType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__BinarySecretType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__BinarySecretType *p;
	size_t k = sizeof(struct wst__BinarySecretType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__BinarySecretType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__BinarySecretType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__BinarySecretType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__BinarySecretType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__BinarySecretType(struct soap *soap, const struct wst__BinarySecretType *a, const char *tag, const char *type)
{
	if (soap_out_wst__BinarySecretType(soap, tag ? tag : "wst:BinarySecretType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__BinarySecretType * SOAP_FMAC4 soap_get_wst__BinarySecretType(struct soap *soap, struct wst__BinarySecretType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__BinarySecretType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestedSecurityTokenType(struct soap *soap, struct wst__RequestedSecurityTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Assertion = NULL;
	a->saml2__Assertion = NULL;
	a->wsse__SecurityTokenReference = NULL;
	a->wsc__SecurityContextToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestedSecurityTokenType(struct soap *soap, const struct wst__RequestedSecurityTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestedSecurityTokenType(struct soap *soap, const char *tag, int id, const struct wst__RequestedSecurityTokenType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestedSecurityTokenType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestedSecurityTokenType * SOAP_FMAC4 soap_in_wst__RequestedSecurityTokenType(struct soap *soap, const char *tag, struct wst__RequestedSecurityTokenType *a, const char *type)
{
	size_t soap_flag_saml1__Assertion = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestedSecurityTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestedSecurityTokenType, sizeof(struct wst__RequestedSecurityTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestedSecurityTokenType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedSecurityTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestedSecurityTokenType, SOAP_TYPE_wst__RequestedSecurityTokenType, sizeof(struct wst__RequestedSecurityTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestedSecurityTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestedSecurityTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestedSecurityTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestedSecurityTokenType *p;
	size_t k = sizeof(struct wst__RequestedSecurityTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestedSecurityTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestedSecurityTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestedSecurityTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestedSecurityTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestedSecurityTokenType(struct soap *soap, const struct wst__RequestedSecurityTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestedSecurityTokenType(soap, tag ? tag : "wst:RequestedSecurityTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedSecurityTokenType * SOAP_FMAC4 soap_get_wst__RequestedSecurityTokenType(struct soap *soap, struct wst__RequestedSecurityTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestedSecurityTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestSecurityTokenResponseType(struct soap *soap, struct wst__RequestSecurityTokenResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Context);
	a->RequestedSecurityToken = NULL;
	a->RequestedAttachedReference = NULL;
	a->RequestedUnattachedReference = NULL;
	a->RequestedProofToken = NULL;
	soap_default_string(soap, &a->KeyType);
	soap_default_string(soap, &a->RequestType);
	soap_default_string(soap, &a->TokenType);
	a->Entropy = NULL;
	a->Lifetime = NULL;
	a->KeySize = NULL;
	a->BinaryExchange = NULL;
	a->Authenticator = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestSecurityTokenResponseType(struct soap *soap, const struct wst__RequestSecurityTokenResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowst__RequestedSecurityTokenType(soap, &a->RequestedSecurityToken);
	soap_serialize_PointerTowst__RequestedReferenceType(soap, &a->RequestedAttachedReference);
	soap_serialize_PointerTowst__RequestedReferenceType(soap, &a->RequestedUnattachedReference);
	soap_serialize_PointerTowst__RequestedProofTokenType(soap, &a->RequestedProofToken);
	soap_serialize_string(soap, (char*const*)&a->KeyType);
	soap_serialize_string(soap, (char*const*)&a->RequestType);
	soap_serialize_string(soap, (char*const*)&a->TokenType);
	soap_serialize_PointerTowst__EntropyType(soap, &a->Entropy);
	soap_serialize_PointerTowst__LifetimeType(soap, &a->Lifetime);
	soap_serialize_PointerTounsignedInt(soap, &a->KeySize);
	soap_serialize_PointerTowst__BinaryExchangeType(soap, &a->BinaryExchange);
	soap_serialize_PointerTowst__AuthenticatorType(soap, &a->Authenticator);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestSecurityTokenResponseType(struct soap *soap, const char *tag, int id, const struct wst__RequestSecurityTokenResponseType *a, const char *type)
{
	if (a->Context)
		soap_set_attr(soap, "Context", soap_string2s(soap, a->Context), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestSecurityTokenResponseType), type))
		return soap->error;
	if (soap_out_PointerTowst__RequestedSecurityTokenType(soap, "wst:RequestedSecurityToken", -1, &a->RequestedSecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTowst__RequestedReferenceType(soap, "wst:RequestedAttachedReference", -1, &a->RequestedAttachedReference, ""))
		return soap->error;
	if (soap_out_PointerTowst__RequestedReferenceType(soap, "wst:RequestedUnattachedReference", -1, &a->RequestedUnattachedReference, ""))
		return soap->error;
	if (soap_out_PointerTowst__RequestedProofTokenType(soap, "wst:RequestedProofToken", -1, &a->RequestedProofToken, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:KeyType", -1, (char*const*)&a->KeyType, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:RequestType", -1, (char*const*)&a->RequestType, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:TokenType", -1, (char*const*)&a->TokenType, ""))
		return soap->error;
	if (soap_out_PointerTowst__EntropyType(soap, "wst:Entropy", -1, &a->Entropy, ""))
		return soap->error;
	if (soap_out_PointerTowst__LifetimeType(soap, "wst:Lifetime", -1, &a->Lifetime, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wst:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_PointerTowst__BinaryExchangeType(soap, "wst:BinaryExchange", -1, &a->BinaryExchange, ""))
		return soap->error;
	if (soap_out_PointerTowst__AuthenticatorType(soap, "wst:Authenticator", -1, &a->Authenticator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseType * SOAP_FMAC4 soap_in_wst__RequestSecurityTokenResponseType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenResponseType *a, const char *type)
{
	size_t soap_flag_RequestedSecurityToken = 1;
	size_t soap_flag_RequestedAttachedReference = 1;
	size_t soap_flag_RequestedUnattachedReference = 1;
	size_t soap_flag_RequestedProofToken = 1;
	size_t soap_flag_KeyType = 1;
	size_t soap_flag_RequestType = 1;
	size_t soap_flag_TokenType = 1;
	size_t soap_flag_Entropy = 1;
	size_t soap_flag_Lifetime = 1;
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_BinaryExchange = 1;
	size_t soap_flag_Authenticator = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestSecurityTokenResponseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestSecurityTokenResponseType, sizeof(struct wst__RequestSecurityTokenResponseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestSecurityTokenResponseType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Context", 1, 0), &a->Context))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestedSecurityToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestedSecurityTokenType(soap, "wst:RequestedSecurityToken", &a->RequestedSecurityToken, "wst:RequestedSecurityTokenType"))
				{	soap_flag_RequestedSecurityToken--;
					continue;
				}
			}
			if (soap_flag_RequestedAttachedReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestedReferenceType(soap, "wst:RequestedAttachedReference", &a->RequestedAttachedReference, "wst:RequestedReferenceType"))
				{	soap_flag_RequestedAttachedReference--;
					continue;
				}
			}
			if (soap_flag_RequestedUnattachedReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestedReferenceType(soap, "wst:RequestedUnattachedReference", &a->RequestedUnattachedReference, "wst:RequestedReferenceType"))
				{	soap_flag_RequestedUnattachedReference--;
					continue;
				}
			}
			if (soap_flag_RequestedProofToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__RequestedProofTokenType(soap, "wst:RequestedProofToken", &a->RequestedProofToken, "wst:RequestedProofTokenType"))
				{	soap_flag_RequestedProofToken--;
					continue;
				}
			}
			if (soap_flag_KeyType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:KeyType", (char**)&a->KeyType, "xsd:string"))
				{	soap_flag_KeyType--;
					continue;
				}
			}
			if (soap_flag_RequestType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:RequestType", (char**)&a->RequestType, "xsd:string"))
				{	soap_flag_RequestType--;
					continue;
				}
			}
			if (soap_flag_TokenType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:TokenType", (char**)&a->TokenType, "xsd:string"))
				{	soap_flag_TokenType--;
					continue;
				}
			}
			if (soap_flag_Entropy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__EntropyType(soap, "wst:Entropy", &a->Entropy, "wst:EntropyType"))
				{	soap_flag_Entropy--;
					continue;
				}
			}
			if (soap_flag_Lifetime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__LifetimeType(soap, "wst:Lifetime", &a->Lifetime, "wst:LifetimeType"))
				{	soap_flag_Lifetime--;
					continue;
				}
			}
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wst:KeySize", &a->KeySize, "xsd:unsignedInt"))
				{	soap_flag_KeySize--;
					continue;
				}
			}
			if (soap_flag_BinaryExchange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__BinaryExchangeType(soap, "wst:BinaryExchange", &a->BinaryExchange, "wst:BinaryExchangeType"))
				{	soap_flag_BinaryExchange--;
					continue;
				}
			}
			if (soap_flag_Authenticator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__AuthenticatorType(soap, "wst:Authenticator", &a->Authenticator, "wst:AuthenticatorType"))
				{	soap_flag_Authenticator--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestSecurityTokenResponseType, SOAP_TYPE_wst__RequestSecurityTokenResponseType, sizeof(struct wst__RequestSecurityTokenResponseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestSecurityTokenResponseType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestSecurityTokenResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestSecurityTokenResponseType *p;
	size_t k = sizeof(struct wst__RequestSecurityTokenResponseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestSecurityTokenResponseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestSecurityTokenResponseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestSecurityTokenResponseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestSecurityTokenResponseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestSecurityTokenResponseType(struct soap *soap, const struct wst__RequestSecurityTokenResponseType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestSecurityTokenResponseType(soap, tag ? tag : "wst:RequestSecurityTokenResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseType * SOAP_FMAC4 soap_get_wst__RequestSecurityTokenResponseType(struct soap *soap, struct wst__RequestSecurityTokenResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestSecurityTokenResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wst__RequestSecurityTokenType(struct soap *soap, struct wst__RequestSecurityTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Context);
	a->wsp__AppliesTo = NULL;
	soap_default_string(soap, &a->KeyType);
	soap_default_string(soap, &a->RequestType);
	soap_default_string(soap, &a->TokenType);
	a->Entropy = NULL;
	soap_default_string(soap, &a->ComputedKeyAlgorithm);
	a->KeySize = NULL;
	a->BinaryExchange = NULL;
	a->Authenticator = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wst__RequestSecurityTokenType(struct soap *soap, const struct wst__RequestSecurityTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsp__AppliesTo_(soap, &a->wsp__AppliesTo);
	soap_serialize_string(soap, (char*const*)&a->KeyType);
	soap_serialize_string(soap, (char*const*)&a->RequestType);
	soap_serialize_string(soap, (char*const*)&a->TokenType);
	soap_serialize_PointerTowst__EntropyType(soap, &a->Entropy);
	soap_serialize_string(soap, (char*const*)&a->ComputedKeyAlgorithm);
	soap_serialize_PointerTounsignedInt(soap, &a->KeySize);
	soap_serialize_PointerTowst__BinaryExchangeType(soap, &a->BinaryExchange);
	soap_serialize_PointerTowst__AuthenticatorType(soap, &a->Authenticator);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__RequestSecurityTokenType(struct soap *soap, const char *tag, int id, const struct wst__RequestSecurityTokenType *a, const char *type)
{
	if (a->Context)
		soap_set_attr(soap, "Context", soap_string2s(soap, a->Context), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wst__RequestSecurityTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsp__AppliesTo_(soap, "wsp:AppliesTo", -1, &a->wsp__AppliesTo, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:KeyType", -1, (char*const*)&a->KeyType, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:RequestType", -1, (char*const*)&a->RequestType, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:TokenType", -1, (char*const*)&a->TokenType, ""))
		return soap->error;
	if (soap_out_PointerTowst__EntropyType(soap, "wst:Entropy", -1, &a->Entropy, ""))
		return soap->error;
	if (soap_out_string(soap, "wst:ComputedKeyAlgorithm", -1, (char*const*)&a->ComputedKeyAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wst:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_PointerTowst__BinaryExchangeType(soap, "wst:BinaryExchange", -1, &a->BinaryExchange, ""))
		return soap->error;
	if (soap_out_PointerTowst__AuthenticatorType(soap, "wst:Authenticator", -1, &a->Authenticator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenType * SOAP_FMAC4 soap_in_wst__RequestSecurityTokenType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenType *a, const char *type)
{
	size_t soap_flag_wsp__AppliesTo = 1;
	size_t soap_flag_KeyType = 1;
	size_t soap_flag_RequestType = 1;
	size_t soap_flag_TokenType = 1;
	size_t soap_flag_Entropy = 1;
	size_t soap_flag_ComputedKeyAlgorithm = 1;
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_BinaryExchange = 1;
	size_t soap_flag_Authenticator = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wst__RequestSecurityTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__RequestSecurityTokenType, sizeof(struct wst__RequestSecurityTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wst__RequestSecurityTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Context", 1, 0), &a->Context))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsp__AppliesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsp__AppliesTo_(soap, "wsp:AppliesTo", &a->wsp__AppliesTo, ""))
				{	soap_flag_wsp__AppliesTo--;
					continue;
				}
			}
			if (soap_flag_KeyType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:KeyType", (char**)&a->KeyType, "xsd:string"))
				{	soap_flag_KeyType--;
					continue;
				}
			}
			if (soap_flag_RequestType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:RequestType", (char**)&a->RequestType, "xsd:string"))
				{	soap_flag_RequestType--;
					continue;
				}
			}
			if (soap_flag_TokenType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:TokenType", (char**)&a->TokenType, "xsd:string"))
				{	soap_flag_TokenType--;
					continue;
				}
			}
			if (soap_flag_Entropy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__EntropyType(soap, "wst:Entropy", &a->Entropy, "wst:EntropyType"))
				{	soap_flag_Entropy--;
					continue;
				}
			}
			if (soap_flag_ComputedKeyAlgorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:ComputedKeyAlgorithm", (char**)&a->ComputedKeyAlgorithm, "xsd:string"))
				{	soap_flag_ComputedKeyAlgorithm--;
					continue;
				}
			}
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wst:KeySize", &a->KeySize, "xsd:unsignedInt"))
				{	soap_flag_KeySize--;
					continue;
				}
			}
			if (soap_flag_BinaryExchange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__BinaryExchangeType(soap, "wst:BinaryExchange", &a->BinaryExchange, "wst:BinaryExchangeType"))
				{	soap_flag_BinaryExchange--;
					continue;
				}
			}
			if (soap_flag_Authenticator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__AuthenticatorType(soap, "wst:Authenticator", &a->Authenticator, "wst:AuthenticatorType"))
				{	soap_flag_Authenticator--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wst__RequestSecurityTokenType, SOAP_TYPE_wst__RequestSecurityTokenType, sizeof(struct wst__RequestSecurityTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wst__RequestSecurityTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wst__RequestSecurityTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wst__RequestSecurityTokenType *p;
	size_t k = sizeof(struct wst__RequestSecurityTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wst__RequestSecurityTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wst__RequestSecurityTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wst__RequestSecurityTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wst__RequestSecurityTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wst__RequestSecurityTokenType(struct soap *soap, const struct wst__RequestSecurityTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wst__RequestSecurityTokenType(soap, tag ? tag : "wst:RequestSecurityTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenType * SOAP_FMAC4 soap_get_wst__RequestSecurityTokenType(struct soap *soap, struct wst__RequestSecurityTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__RequestSecurityTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsp__AppliesTo_(struct soap *soap, struct _wsp__AppliesTo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsa5__EndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsp__AppliesTo_(struct soap *soap, const struct _wsp__AppliesTo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsa5__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsp__AppliesTo_(struct soap *soap, const char *tag, int id, const struct _wsp__AppliesTo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsp__AppliesTo_), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsp__AppliesTo_ * SOAP_FMAC4 soap_in__wsp__AppliesTo_(struct soap *soap, const char *tag, struct _wsp__AppliesTo_ *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsp__AppliesTo_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsp__AppliesTo_, sizeof(struct _wsp__AppliesTo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsp__AppliesTo_(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsp__AppliesTo_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsp__AppliesTo_, SOAP_TYPE__wsp__AppliesTo_, sizeof(struct _wsp__AppliesTo_), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsp__AppliesTo_ * SOAP_FMAC2 soap_instantiate__wsp__AppliesTo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsp__AppliesTo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsp__AppliesTo_ *p;
	size_t k = sizeof(struct _wsp__AppliesTo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsp__AppliesTo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsp__AppliesTo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsp__AppliesTo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsp__AppliesTo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsp__AppliesTo_(struct soap *soap, const struct _wsp__AppliesTo_ *a, const char *tag, const char *type)
{
	if (soap_out__wsp__AppliesTo_(soap, tag ? tag : "wsp:AppliesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsp__AppliesTo_ * SOAP_FMAC4 soap_get__wsp__AppliesTo_(struct soap *soap, struct _wsp__AppliesTo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsp__AppliesTo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
	a->__sizeIssuedTokens = 0;
	a->wst__IssuedTokens = NULL;
	soap_default_string(soap, &a->wst__RequestType);
	a->wsrm__Sequence = NULL;
	a->__sizeAckRequested = 0;
	a->wsrm__AckRequested = NULL;
	a->__sizeSequenceAcknowledgement = 0;
	a->wsrm__SequenceAcknowledgement = NULL;
	a->wsrm__SequenceFault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
	if (a->wst__IssuedTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeIssuedTokens; i++)
		{
			soap_embedded(soap, a->wst__IssuedTokens + i, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType);
			soap_serialize_wst__RequestSecurityTokenResponseCollectionType(soap, a->wst__IssuedTokens + i);
		}
	}
	soap_serialize_string(soap, (char*const*)&a->wst__RequestType);
	soap_serialize_PointerTowsrm__SequenceType(soap, &a->wsrm__Sequence);
	if (a->wsrm__AckRequested)
	{	int i;
		for (i = 0; i < (int)a->__sizeAckRequested; i++)
		{
			soap_embedded(soap, a->wsrm__AckRequested + i, SOAP_TYPE_wsrm__AckRequestedType);
			soap_serialize_wsrm__AckRequestedType(soap, a->wsrm__AckRequested + i);
		}
	}
	if (a->wsrm__SequenceAcknowledgement)
	{	int i;
		for (i = 0; i < (int)a->__sizeSequenceAcknowledgement; i++)
		{
			soap_embedded(soap, a->wsrm__SequenceAcknowledgement + i, SOAP_TYPE__wsrm__SequenceAcknowledgement);
			soap_serialize__wsrm__SequenceAcknowledgement(soap, a->wsrm__SequenceAcknowledgement + i);
		}
	}
	soap_serialize_PointerTowsrm__SequenceFaultType(soap, &a->wsrm__SequenceFault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->wst__IssuedTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeIssuedTokens; i++)
			if (soap_out_wst__RequestSecurityTokenResponseCollectionType(soap, "wst:IssuedTokens", -1, a->wst__IssuedTokens + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "wst:RequestType", -1, (char*const*)&a->wst__RequestType, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__SequenceType(soap, "wsrm:Sequence", -1, &a->wsrm__Sequence, ""))
		return soap->error;
	if (a->wsrm__AckRequested)
	{	int i;
		for (i = 0; i < (int)a->__sizeAckRequested; i++)
			if (soap_out_wsrm__AckRequestedType(soap, "wsrm:AckRequested", -1, a->wsrm__AckRequested + i, ""))
				return soap->error;
	}
	if (a->wsrm__SequenceAcknowledgement)
	{	int i;
		for (i = 0; i < (int)a->__sizeSequenceAcknowledgement; i++)
			if (soap_out__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", -1, a->wsrm__SequenceAcknowledgement + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTowsrm__SequenceFaultType(soap, "wsrm:SequenceFault", -1, &a->wsrm__SequenceFault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist_wst__IssuedTokens = NULL;
	size_t soap_flag_wst__RequestType = 1;
	size_t soap_flag_wsrm__Sequence = 1;
	struct soap_blist *soap_blist_wsrm__AckRequested = NULL;
	struct soap_blist *soap_blist_wsrm__SequenceAcknowledgement = NULL;
	size_t soap_flag_wsrm__SequenceFault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wst:IssuedTokens", 1, NULL))
			{	if (a->wst__IssuedTokens == NULL)
				{	if (soap_blist_wst__IssuedTokens == NULL)
						soap_blist_wst__IssuedTokens = soap_alloc_block(soap);
					a->wst__IssuedTokens = soap_block<struct wst__RequestSecurityTokenResponseCollectionType>::push(soap, soap_blist_wst__IssuedTokens);
					if (a->wst__IssuedTokens == NULL)
						return NULL;
					soap_default_wst__RequestSecurityTokenResponseCollectionType(soap, a->wst__IssuedTokens);
				}
				soap_revert(soap);
				if (soap_in_wst__RequestSecurityTokenResponseCollectionType(soap, "wst:IssuedTokens", a->wst__IssuedTokens, "wst:RequestSecurityTokenResponseCollectionType"))
				{	a->__sizeIssuedTokens++;
					a->wst__IssuedTokens = NULL;
					continue;
				}
			}
			if (soap_flag_wst__RequestType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wst:RequestType", (char**)&a->wst__RequestType, "xsd:string"))
				{	soap_flag_wst__RequestType--;
					continue;
				}
			}
			if (soap_flag_wsrm__Sequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__SequenceType(soap, "wsrm:Sequence", &a->wsrm__Sequence, "wsrm:SequenceType"))
				{	soap_flag_wsrm__Sequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:AckRequested", 1, NULL))
			{	if (a->wsrm__AckRequested == NULL)
				{	if (soap_blist_wsrm__AckRequested == NULL)
						soap_blist_wsrm__AckRequested = soap_alloc_block(soap);
					a->wsrm__AckRequested = soap_block<struct wsrm__AckRequestedType>::push(soap, soap_blist_wsrm__AckRequested);
					if (a->wsrm__AckRequested == NULL)
						return NULL;
					soap_default_wsrm__AckRequestedType(soap, a->wsrm__AckRequested);
				}
				soap_revert(soap);
				if (soap_in_wsrm__AckRequestedType(soap, "wsrm:AckRequested", a->wsrm__AckRequested, "wsrm:AckRequestedType"))
				{	a->__sizeAckRequested++;
					a->wsrm__AckRequested = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:SequenceAcknowledgement", 1, NULL))
			{	if (a->wsrm__SequenceAcknowledgement == NULL)
				{	if (soap_blist_wsrm__SequenceAcknowledgement == NULL)
						soap_blist_wsrm__SequenceAcknowledgement = soap_alloc_block(soap);
					a->wsrm__SequenceAcknowledgement = soap_block<struct _wsrm__SequenceAcknowledgement>::push(soap, soap_blist_wsrm__SequenceAcknowledgement);
					if (a->wsrm__SequenceAcknowledgement == NULL)
						return NULL;
					soap_default__wsrm__SequenceAcknowledgement(soap, a->wsrm__SequenceAcknowledgement);
				}
				soap_revert(soap);
				if (soap_in__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", a->wsrm__SequenceAcknowledgement, ""))
				{	a->__sizeSequenceAcknowledgement++;
					a->wsrm__SequenceAcknowledgement = NULL;
					continue;
				}
			}
			if (soap_flag_wsrm__SequenceFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrm__SequenceFaultType(soap, "wsrm:SequenceFault", &a->wsrm__SequenceFault, "wsrm:SequenceFaultType"))
				{	soap_flag_wsrm__SequenceFault--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wst__IssuedTokens)
			soap_block<struct wst__RequestSecurityTokenResponseCollectionType>::pop(soap, soap_blist_wst__IssuedTokens);
		if (a->__sizeIssuedTokens)
		{	a->wst__IssuedTokens = soap_new_wst__RequestSecurityTokenResponseCollectionType(soap, a->__sizeIssuedTokens);
			if (!a->wst__IssuedTokens)
				return NULL;
			soap_block<struct wst__RequestSecurityTokenResponseCollectionType>::save(soap, soap_blist_wst__IssuedTokens, a->wst__IssuedTokens);
		}
		else
		{	a->wst__IssuedTokens = NULL;
			if (soap_blist_wst__IssuedTokens)
				soap_block<struct wst__RequestSecurityTokenResponseCollectionType>::end(soap, soap_blist_wst__IssuedTokens);
		}
		if (a->wsrm__AckRequested)
			soap_block<struct wsrm__AckRequestedType>::pop(soap, soap_blist_wsrm__AckRequested);
		if (a->__sizeAckRequested)
		{	a->wsrm__AckRequested = soap_new_wsrm__AckRequestedType(soap, a->__sizeAckRequested);
			if (!a->wsrm__AckRequested)
				return NULL;
			soap_block<struct wsrm__AckRequestedType>::save(soap, soap_blist_wsrm__AckRequested, a->wsrm__AckRequested);
		}
		else
		{	a->wsrm__AckRequested = NULL;
			if (soap_blist_wsrm__AckRequested)
				soap_block<struct wsrm__AckRequestedType>::end(soap, soap_blist_wsrm__AckRequested);
		}
		if (a->wsrm__SequenceAcknowledgement)
			soap_block<struct _wsrm__SequenceAcknowledgement>::pop(soap, soap_blist_wsrm__SequenceAcknowledgement);
		if (a->__sizeSequenceAcknowledgement)
		{	a->wsrm__SequenceAcknowledgement = soap_new__wsrm__SequenceAcknowledgement(soap, a->__sizeSequenceAcknowledgement);
			if (!a->wsrm__SequenceAcknowledgement)
				return NULL;
			soap_block<struct _wsrm__SequenceAcknowledgement>::save(soap, soap_blist_wsrm__SequenceAcknowledgement, a->wsrm__SequenceAcknowledgement);
		}
		else
		{	a->wsrm__SequenceAcknowledgement = NULL;
			if (soap_blist_wsrm__SequenceAcknowledgement)
				soap_block<struct _wsrm__SequenceAcknowledgement>::end(soap, soap_blist_wsrm__SequenceAcknowledgement);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	a->saml1__Assertion = NULL;
	a->saml2__Assertion = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", soap_string2s(soap, a->SOAP_ENV__actor), 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", soap_string2s(soap, a->SOAP_ENV__role), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml1__Assertion = 1;
	size_t soap_flag_saml2__Assertion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Security*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 1, 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 1, 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Security *p;
	size_t k = sizeof(struct _wsse__Security);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Security);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Security, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Security location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAttribute(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAttribute(soap, tag ? tag : "saml2:EncryptedAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Attribute(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Attribute(soap, tag ? tag : "saml2:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AttributeStatement(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AttributeStatement(soap, tag ? tag : "saml2:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Evidence(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Evidence(soap, tag ? tag : "saml2:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Action(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Action(soap, tag ? tag : "saml2:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthzDecisionStatement(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthzDecisionStatement(soap, tag ? tag : "saml2:AuthzDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContext(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContext(soap, tag ? tag : "saml2:AuthnContext", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectLocality(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectLocality(soap, tag ? tag : "saml2:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnStatement(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnStatement(soap, tag ? tag : "saml2:AuthnStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Statement(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Statement(soap, tag ? tag : "saml2:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAssertion(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAssertion(soap, tag ? tag : "saml2:EncryptedAssertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Advice(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Advice(soap, tag ? tag : "saml2:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__ProxyRestriction(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__ProxyRestriction(soap, tag ? tag : "saml2:ProxyRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__OneTimeUse(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__OneTimeUse(soap, tag ? tag : "saml2:OneTimeUse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AudienceRestriction(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AudienceRestriction(soap, tag ? tag : "saml2:AudienceRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Condition(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Condition(soap, tag ? tag : "saml2:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Conditions(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Conditions(soap, tag ? tag : "saml2:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmationData(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmationData(soap, tag ? tag : "saml2:SubjectConfirmationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmation(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmation(soap, tag ? tag : "saml2:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Subject(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Subject(soap, tag ? tag : "saml2:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Assertion(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Assertion(soap, tag ? tag : "saml2:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Issuer(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Issuer(soap, tag ? tag : "saml2:Issuer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedID(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedID(soap, tag ? tag : "saml2:EncryptedID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__NameID(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__NameID(soap, tag ? tag : "saml2:NameID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__BaseID(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__BaseID(soap, tag ? tag : "saml2:BaseID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Attribute = NULL;
	a->saml2__EncryptedAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__AttributeType(soap, &a->saml2__Attribute);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAttribute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__AttributeType(soap, "saml2:Attribute", -1, &a->saml2__Attribute, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", -1, &a->saml2__EncryptedAttribute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_in___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml2__Attribute = 1;
	size_t soap_flag_saml2__EncryptedAttribute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AttributeStatementType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AttributeStatementType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Attribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeType(soap, "saml2:Attribute", &a->saml2__Attribute, "saml2:AttributeType"))
				{	soap_flag_saml2__Attribute--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAttribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", &a->saml2__EncryptedAttribute, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAttribute--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AttributeStatementType *p;
	size_t k = sizeof(struct __saml2__union_AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_get___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_in___saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_EvidenceType *p;
	size_t k = sizeof(struct __saml2__union_EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_get___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_in___saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AdviceType *p;
	size_t k = sizeof(struct __saml2__union_AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_get___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Condition = NULL;
	a->saml2__AudienceRestriction = NULL;
	a->saml2__OneTimeUse = NULL;
	a->saml2__ProxyRestriction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__ConditionAbstractType(soap, &a->saml2__Condition);
	soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, &a->saml2__AudienceRestriction);
	soap_serialize_PointerTosaml2__OneTimeUseType(soap, &a->saml2__OneTimeUse);
	soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, &a->saml2__ProxyRestriction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml2__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", -1, &a->saml2__Condition, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", -1, &a->saml2__AudienceRestriction, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", -1, &a->saml2__OneTimeUse, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", -1, &a->saml2__ProxyRestriction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_in___saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml2__Condition = 1;
	size_t soap_flag_saml2__AudienceRestriction = 1;
	size_t soap_flag_saml2__OneTimeUse = 1;
	size_t soap_flag_saml2__ProxyRestriction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", &a->saml2__Condition, "saml2:ConditionAbstractType"))
				{	soap_flag_saml2__Condition--;
					continue;
				}
			}
			if (soap_flag_saml2__AudienceRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", &a->saml2__AudienceRestriction, "saml2:AudienceRestrictionType"))
				{	soap_flag_saml2__AudienceRestriction--;
					continue;
				}
			}
			if (soap_flag_saml2__OneTimeUse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", &a->saml2__OneTimeUse, "saml2:OneTimeUseType"))
				{	soap_flag_saml2__OneTimeUse--;
					continue;
				}
			}
			if (soap_flag_saml2__ProxyRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", &a->saml2__ProxyRestriction, "saml2:ProxyRestrictionType"))
				{	soap_flag_saml2__ProxyRestriction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_ConditionsType *p;
	size_t k = sizeof(struct __saml2__union_ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_get___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Statement = NULL;
	a->saml2__AuthnStatement = NULL;
	a->saml2__AuthzDecisionStatement = NULL;
	a->saml2__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__StatementAbstractType(soap, &a->saml2__Statement);
	soap_serialize_PointerTosaml2__AuthnStatementType(soap, &a->saml2__AuthnStatement);
	soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, &a->saml2__AuthzDecisionStatement);
	soap_serialize_PointerTosaml2__AttributeStatementType(soap, &a->saml2__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", -1, &a->saml2__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", -1, &a->saml2__AuthnStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", -1, &a->saml2__AuthzDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", -1, &a->saml2__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_in___saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Statement = 1;
	size_t soap_flag_saml2__AuthnStatement = 1;
	size_t soap_flag_saml2__AuthzDecisionStatement = 1;
	size_t soap_flag_saml2__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", &a->saml2__Statement, "saml2:StatementAbstractType"))
				{	soap_flag_saml2__Statement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", &a->saml2__AuthnStatement, "saml2:AuthnStatementType"))
				{	soap_flag_saml2__AuthnStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthzDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", &a->saml2__AuthzDecisionStatement, "saml2:AuthzDecisionStatementType"))
				{	soap_flag_saml2__AuthzDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", &a->saml2__AttributeStatement, "saml2:AttributeStatementType"))
				{	soap_flag_saml2__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AssertionType *p;
	size_t k = sizeof(struct __saml2__union_AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_get___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAttributeValue = 0;
	a->saml2__AttributeValue = NULL;
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->NameFormat);
	soap_default_string(soap, &a->FriendlyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	if (a->NameFormat)
		soap_set_attr(soap, "NameFormat", soap_string2s(soap, a->NameFormat), 1);
	if (a->FriendlyName)
		soap_set_attr(soap, "FriendlyName", soap_string2s(soap, a->FriendlyName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeType), type))
		return soap->error;
	if (a->saml2__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml2:AttributeValue", (char*const*)(a->saml2__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_in_saml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameFormat", 1, 0), &a->NameFormat))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "FriendlyName", 1, 0), &a->FriendlyName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AttributeValue", 1, NULL))
			{	if (a->saml2__AttributeValue == NULL)
				{	if (soap_blist_saml2__AttributeValue == NULL)
						soap_blist_saml2__AttributeValue = soap_alloc_block(soap);
					a->saml2__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml2__AttributeValue, sizeof(char *));
					if (a->saml2__AttributeValue == NULL)
						return NULL;
					*a->saml2__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml2:AttributeValue", (char**)a->saml2__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml2__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AttributeValue)
			soap_pop_block(soap, soap_blist_saml2__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml2__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml2__AttributeValue, NULL, 1);
		}
		else
		{	a->saml2__AttributeValue = NULL;
			if (soap_blist_saml2__AttributeValue)
				soap_end_block(soap, soap_blist_saml2__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeType, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AttributeType *p;
	size_t k = sizeof(struct saml2__AttributeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AttributeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AttributeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AttributeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AttributeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_get_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AttributeStatementType = 0;
	a->__union_AttributeStatementType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
		{
			soap_serialize___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeStatementType), type))
		return soap->error;
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
			if (soap_out___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", -1, a->__union_AttributeStatementType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_in_saml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AttributeStatementType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AttributeStatementType == NULL)
				{	if (soap_blist___union_AttributeStatementType == NULL)
						soap_blist___union_AttributeStatementType = soap_alloc_block(soap);
					a->__union_AttributeStatementType = soap_block<struct __saml2__union_AttributeStatementType>::push(soap, soap_blist___union_AttributeStatementType);
					if (a->__union_AttributeStatementType == NULL)
						return NULL;
					soap_default___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType);
				}
				if (soap_in___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", a->__union_AttributeStatementType, "-saml2:union-AttributeStatementType"))
				{	a->__size_AttributeStatementType++;
					a->__union_AttributeStatementType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AttributeStatementType)
			soap_block<struct __saml2__union_AttributeStatementType>::pop(soap, soap_blist___union_AttributeStatementType);
		if (a->__size_AttributeStatementType)
		{	a->__union_AttributeStatementType = soap_new___saml2__union_AttributeStatementType(soap, a->__size_AttributeStatementType);
			if (!a->__union_AttributeStatementType)
				return NULL;
			soap_block<struct __saml2__union_AttributeStatementType>::save(soap, soap_blist___union_AttributeStatementType, a->__union_AttributeStatementType);
		}
		else
		{	a->__union_AttributeStatementType = NULL;
			if (soap_blist___union_AttributeStatementType)
				soap_block<struct __saml2__union_AttributeStatementType>::end(soap, soap_blist___union_AttributeStatementType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeStatementType, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AttributeStatementType *p;
	size_t k = sizeof(struct saml2__AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_get_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml2__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml2__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml2__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_in_saml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = soap_block<struct __saml2__union_EvidenceType>::push(soap, soap_blist___union_EvidenceType);
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml2__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml2__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml2:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_block<struct __saml2__union_EvidenceType>::pop(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = soap_new___saml2__union_EvidenceType(soap, a->__size_EvidenceType);
			if (!a->__union_EvidenceType)
				return NULL;
			soap_block<struct __saml2__union_EvidenceType>::save(soap, soap_blist___union_EvidenceType, a->__union_EvidenceType);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_block<struct __saml2__union_EvidenceType>::end(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EvidenceType, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__EvidenceType *p;
	size_t k = sizeof(struct saml2__EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_get_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ActionType(struct soap *soap, struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ActionType(struct soap *soap, const char *tag, int id, const struct saml2__ActionType *a, const char *type)
{
	soap_set_attr(soap, "Namespace", a->Namespace ? soap_string2s(soap, a->Namespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_in_saml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 1), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ActionType *p;
	size_t k = sizeof(struct saml2__ActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_get_saml2__ActionType(struct soap *soap, struct saml2__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->saml2__Action = NULL;
	a->saml2__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml2__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml2__Action + i, SOAP_TYPE_saml2__ActionType);
			soap_serialize_saml2__ActionType(soap, a->saml2__Action + i);
		}
	}
	soap_serialize_PointerTosaml2__EvidenceType(soap, &a->saml2__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml2__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType), type))
		return soap->error;
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml2__ActionType(soap, "saml2:Action", -1, a->saml2__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", -1, &a->saml2__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_in_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Action = NULL;
	size_t soap_flag_saml2__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthzDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthzDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml2__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Action", 1, NULL))
			{	if (a->saml2__Action == NULL)
				{	if (soap_blist_saml2__Action == NULL)
						soap_blist_saml2__Action = soap_alloc_block(soap);
					a->saml2__Action = soap_block<struct saml2__ActionType>::push(soap, soap_blist_saml2__Action);
					if (a->saml2__Action == NULL)
						return NULL;
					soap_default_saml2__ActionType(soap, a->saml2__Action);
				}
				soap_revert(soap);
				if (soap_in_saml2__ActionType(soap, "saml2:Action", a->saml2__Action, "saml2:ActionType"))
				{	a->__sizeAction++;
					a->saml2__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml2__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", &a->saml2__Evidence, "saml2:EvidenceType"))
				{	soap_flag_saml2__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Action)
			soap_block<struct saml2__ActionType>::pop(soap, soap_blist_saml2__Action);
		if (a->__sizeAction)
		{	a->saml2__Action = soap_new_saml2__ActionType(soap, a->__sizeAction);
			if (!a->saml2__Action)
				return NULL;
			soap_block<struct saml2__ActionType>::save(soap, soap_blist_saml2__Action, a->saml2__Action);
		}
		else
		{	a->saml2__Action = NULL;
			if (soap_blist_saml2__Action)
				soap_block<struct saml2__ActionType>::end(soap, soap_blist_saml2__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthzDecisionStatementType, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthzDecisionStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthzDecisionStatementType *p;
	size_t k = sizeof(struct saml2__AuthzDecisionStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthzDecisionStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthzDecisionStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthzDecisionStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthzDecisionStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_get_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AuthnContextClassRef);
	a->saml2__AuthnContextDecl = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef);
	a->__sizeAuthenticatingAuthority = 0;
	a->saml2__AuthenticatingAuthority = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextClassRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef);
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__AuthenticatingAuthority + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnContextType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnContextType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnContextType), type))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextClassRef", -1, (char*const*)&a->saml2__AuthnContextClassRef, ""))
		return soap->error;
	if (soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl, NULL))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef, ""))
		return soap->error;
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
			if (soap_out_string(soap, "saml2:AuthenticatingAuthority", -1, (char*const*)(a->saml2__AuthenticatingAuthority + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_in_saml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType *a, const char *type)
{
	size_t soap_flag_saml2__AuthnContextClassRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef = 1;
	struct soap_blist *soap_blist_saml2__AuthenticatingAuthority = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnContextType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnContextType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextClassRef", (char**)&a->saml2__AuthnContextClassRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextClassRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDecl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl))
				{	soap_flag_saml2__AuthnContextDecl--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDeclRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AuthenticatingAuthority", 1, NULL))
			{	if (a->saml2__AuthenticatingAuthority == NULL)
				{	if (soap_blist_saml2__AuthenticatingAuthority == NULL)
						soap_blist_saml2__AuthenticatingAuthority = soap_alloc_block(soap);
					a->saml2__AuthenticatingAuthority = (char **)soap_push_block_max(soap, soap_blist_saml2__AuthenticatingAuthority, sizeof(char *));
					if (a->saml2__AuthenticatingAuthority == NULL)
						return NULL;
					*a->saml2__AuthenticatingAuthority = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:AuthenticatingAuthority", (char**)a->saml2__AuthenticatingAuthority, "xsd:string"))
				{	a->__sizeAuthenticatingAuthority++;
					a->saml2__AuthenticatingAuthority = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AuthenticatingAuthority)
			soap_pop_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		if (a->__sizeAuthenticatingAuthority)
		{	a->saml2__AuthenticatingAuthority = (char **)soap_save_block(soap, soap_blist_saml2__AuthenticatingAuthority, NULL, 1);
		}
		else
		{	a->saml2__AuthenticatingAuthority = NULL;
			if (soap_blist_saml2__AuthenticatingAuthority)
				soap_end_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnContextType, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthnContextType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthnContextType *p;
	size_t k = sizeof(struct saml2__AuthnContextType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthnContextType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthnContextType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthnContextType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthnContextType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_get_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	soap_default_string(soap, &a->DNSName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectLocalityType *a, const char *type)
{
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	if (a->DNSName)
		soap_set_attr(soap, "DNSName", soap_string2s(soap, a->DNSName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_in_saml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSName", 1, 0), &a->DNSName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectLocalityType, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectLocalityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectLocalityType *p;
	size_t k = sizeof(struct saml2__SubjectLocalityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectLocalityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectLocalityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectLocalityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectLocalityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_get_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__SubjectLocality = NULL;
	a->saml2__AuthnContext = NULL;
	soap_default_dateTime(soap, &a->AuthnInstant);
	soap_default_string(soap, &a->SessionIndex);
	a->SessionNotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__SubjectLocalityType(soap, &a->saml2__SubjectLocality);
	soap_serialize_PointerTosaml2__AuthnContextType(soap, &a->saml2__AuthnContext);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthnInstant", soap_dateTime2s(soap, a->AuthnInstant), 1);
	if (a->SessionIndex)
		soap_set_attr(soap, "SessionIndex", soap_string2s(soap, a->SessionIndex), 1);
	if (a->SessionNotOnOrAfter)
	{	soap_set_attr(soap, "SessionNotOnOrAfter", soap_dateTime2s(soap, *a->SessionNotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnStatementType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", -1, &a->saml2__SubjectLocality, ""))
		return soap->error;
	if (!a->saml2__AuthnContext)
	{	if (soap_element_empty(soap, "saml2:AuthnContext"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", -1, &a->saml2__AuthnContext, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_in_saml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType *a, const char *type)
{
	size_t soap_flag_saml2__SubjectLocality = 1;
	size_t soap_flag_saml2__AuthnContext = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnStatementType(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "AuthnInstant", 5, 1), &a->AuthnInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SessionIndex", 1, 0), &a->SessionIndex))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "SessionNotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->SessionNotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->SessionNotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", &a->saml2__SubjectLocality, "saml2:SubjectLocalityType"))
				{	soap_flag_saml2__SubjectLocality--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContext && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", &a->saml2__AuthnContext, "saml2:AuthnContextType"))
				{	soap_flag_saml2__AuthnContext--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__AuthnContext))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnStatementType, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthnStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthnStatementType *p;
	size_t k = sizeof(struct saml2__AuthnStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthnStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthnStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthnStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthnStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_get_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_in_saml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__StatementAbstractType, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__StatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__StatementAbstractType *p;
	size_t k = sizeof(struct saml2__StatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__StatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__StatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__StatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__StatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_get_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml2__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AdviceType(struct soap *soap, const char *tag, int id, const struct saml2__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml2__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_in_saml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = soap_block<struct __saml2__union_AdviceType>::push(soap, soap_blist___union_AdviceType);
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml2__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml2__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml2:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_block<struct __saml2__union_AdviceType>::pop(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = soap_new___saml2__union_AdviceType(soap, a->__size_AdviceType);
			if (!a->__union_AdviceType)
				return NULL;
			soap_block<struct __saml2__union_AdviceType>::save(soap, soap_blist___union_AdviceType, a->__union_AdviceType);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_block<struct __saml2__union_AdviceType>::end(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AdviceType, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AdviceType *p;
	size_t k = sizeof(struct saml2__AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_get_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
	soap_default_string(soap, &a->Count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__ProxyRestrictionType *a, const char *type)
{
	if (a->Count)
		soap_set_attr(soap, "Count", soap_string2s(soap, a->Count), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ProxyRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_in_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ProxyRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ProxyRestrictionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Count", 1, 0), &a->Count))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ProxyRestrictionType, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ProxyRestrictionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ProxyRestrictionType *p;
	size_t k = sizeof(struct saml2__ProxyRestrictionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ProxyRestrictionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ProxyRestrictionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ProxyRestrictionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ProxyRestrictionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_get_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__OneTimeUseType(struct soap *soap, const char *tag, int id, const struct saml2__OneTimeUseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__OneTimeUseType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_in_saml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__OneTimeUseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__OneTimeUseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__OneTimeUseType, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__OneTimeUseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__OneTimeUseType *p;
	size_t k = sizeof(struct saml2__OneTimeUseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__OneTimeUseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__OneTimeUseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__OneTimeUseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__OneTimeUseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_get_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__AudienceRestrictionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AudienceRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_in_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AudienceRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AudienceRestrictionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AudienceRestrictionType, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AudienceRestrictionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AudienceRestrictionType *p;
	size_t k = sizeof(struct saml2__AudienceRestrictionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AudienceRestrictionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AudienceRestrictionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AudienceRestrictionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AudienceRestrictionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_get_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_in_saml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionAbstractType, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ConditionAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ConditionAbstractType *p;
	size_t k = sizeof(struct saml2__ConditionAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ConditionAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ConditionAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ConditionAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ConditionAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_get_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml2__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml2__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_in_saml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = soap_block<struct __saml2__union_ConditionsType>::push(soap, soap_blist___union_ConditionsType);
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml2__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml2__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml2:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_block<struct __saml2__union_ConditionsType>::pop(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = soap_new___saml2__union_ConditionsType(soap, a->__size_ConditionsType);
			if (!a->__union_ConditionsType)
				return NULL;
			soap_block<struct __saml2__union_ConditionsType>::save(soap, soap_blist___union_ConditionsType, a->__union_ConditionsType);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_block<struct __saml2__union_ConditionsType>::end(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionsType, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ConditionsType *p;
	size_t k = sizeof(struct saml2__ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_get_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeds__KeyInfo = 0;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
		{
			soap_serialize_PointerTo_ds__KeyInfo(soap, a->ds__KeyInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType), type))
		return soap->error;
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
			if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, a->ds__KeyInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_in_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	struct soap_blist *soap_blist_ds__KeyInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__KeyInfoConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__KeyInfoConfirmationDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:KeyInfo", 1, NULL))
			{	if (a->ds__KeyInfo == NULL)
				{	if (soap_blist_ds__KeyInfo == NULL)
						soap_blist_ds__KeyInfo = soap_alloc_block(soap);
					a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_push_block_max(soap, soap_blist_ds__KeyInfo, sizeof(struct ds__KeyInfoType *));
					if (a->ds__KeyInfo == NULL)
						return NULL;
					*a->ds__KeyInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", a->ds__KeyInfo, ""))
				{	a->__sizeds__KeyInfo++;
					a->ds__KeyInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ds__KeyInfo)
			soap_pop_block(soap, soap_blist_ds__KeyInfo);
		if (a->__sizeds__KeyInfo)
		{	a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_save_block(soap, soap_blist_ds__KeyInfo, NULL, 1);
		}
		else
		{	a->ds__KeyInfo = NULL;
			if (soap_blist_ds__KeyInfo)
				soap_end_block(soap, soap_blist_ds__KeyInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeds__KeyInfo < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__KeyInfoConfirmationDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__KeyInfoConfirmationDataType *p;
	size_t k = sizeof(struct saml2__KeyInfoConfirmationDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__KeyInfoConfirmationDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__KeyInfoConfirmationDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__KeyInfoConfirmationDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__KeyInfoConfirmationDataType(soap, tag ? tag : "saml2:KeyInfoConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_get_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
	soap_default_string(soap, &a->Recipient);
	soap_default_string(soap, &a->InResponseTo);
	soap_default_string(soap, &a->Address);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	if (a->InResponseTo)
		soap_set_attr(soap, "InResponseTo", soap_string2s(soap, a->InResponseTo), 1);
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationDataType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 1, 0), &a->InResponseTo))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationDataType, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectConfirmationDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectConfirmationDataType *p;
	size_t k = sizeof(struct saml2__SubjectConfirmationDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectConfirmationDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectConfirmationDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectConfirmationDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectConfirmationDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->saml2__SubjectConfirmationData = NULL;
	soap_default_string(soap, &a->Method);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, &a->saml2__SubjectConfirmationData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationType *a, const char *type)
{
	soap_set_attr(soap, "Method", a->Method ? soap_string2s(soap, a->Method) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", -1, &a->saml2__SubjectConfirmationData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	size_t soap_flag_saml2__SubjectConfirmationData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Method", 1, 1), &a->Method))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap_flag_saml2__SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", &a->saml2__SubjectConfirmationData, "saml2:SubjectConfirmationDataType"))
				{	soap_flag_saml2__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationType, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectConfirmationType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectConfirmationType *p;
	size_t k = sizeof(struct saml2__SubjectConfirmationType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectConfirmationType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectConfirmationType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectConfirmationType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectConfirmationType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->__sizeSubjectConfirmation = 0;
	a->saml2__SubjectConfirmation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_in_saml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation == NULL)
						soap_blist_saml2__SubjectConfirmation = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation = soap_block<struct saml2__SubjectConfirmationType>::push(soap, soap_blist_saml2__SubjectConfirmation);
					if (a->saml2__SubjectConfirmation == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation++;
					a->saml2__SubjectConfirmation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__SubjectConfirmation)
			soap_block<struct saml2__SubjectConfirmationType>::pop(soap, soap_blist_saml2__SubjectConfirmation);
		if (a->__sizeSubjectConfirmation)
		{	a->saml2__SubjectConfirmation = soap_new_saml2__SubjectConfirmationType(soap, a->__sizeSubjectConfirmation);
			if (!a->saml2__SubjectConfirmation)
				return NULL;
			soap_block<struct saml2__SubjectConfirmationType>::save(soap, soap_blist_saml2__SubjectConfirmation, a->saml2__SubjectConfirmation);
		}
		else
		{	a->saml2__SubjectConfirmation = NULL;
			if (soap_blist_saml2__SubjectConfirmation)
				soap_block<struct saml2__SubjectConfirmationType>::end(soap, soap_blist_saml2__SubjectConfirmation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectType, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectType *p;
	size_t k = sizeof(struct saml2__SubjectType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_get_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Issuer = NULL;
	a->ds__Signature = NULL;
	a->saml2__Subject = NULL;
	a->saml2__Conditions = NULL;
	a->saml2__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->ID);
	soap_default_dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__Issuer);
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml2__SubjectType(soap, &a->saml2__Subject);
	soap_serialize_PointerTosaml2__ConditionsType(soap, &a->saml2__Conditions);
	soap_serialize_PointerTosaml2__AdviceType(soap, &a->saml2__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml2__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AssertionType(struct soap *soap, const char *tag, int id, const struct saml2__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "Version", a->Version ? soap_string2s(soap, a->Version) : "", 1);
	soap_set_attr(soap, "ID", a->ID ? soap_string2s(soap, a->ID) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AssertionType), type))
		return soap->error;
	if (!a->saml2__Issuer)
	{	if (soap_element_empty(soap, "saml2:Issuer"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:Issuer", -1, &a->saml2__Issuer, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectType(soap, "saml2:Subject", -1, &a->saml2__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", -1, &a->saml2__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AdviceType(soap, "saml2:Advice", -1, &a->saml2__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml2__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_in_saml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Issuer = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml2__Subject = 1;
	size_t soap_flag_saml2__Conditions = 1;
	size_t soap_flag_saml2__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Version", 1, 1), &a->Version))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ID", 1, 1), &a->ID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Issuer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:Issuer", &a->saml2__Issuer, "saml2:NameIDType"))
				{	soap_flag_saml2__Issuer--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml2__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectType(soap, "saml2:Subject", &a->saml2__Subject, "saml2:SubjectType"))
				{	soap_flag_saml2__Subject--;
					continue;
				}
			}
			if (soap_flag_saml2__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", &a->saml2__Conditions, "saml2:ConditionsType"))
				{	soap_flag_saml2__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml2__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AdviceType(soap, "saml2:Advice", &a->saml2__Advice, "saml2:AdviceType"))
				{	soap_flag_saml2__Advice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = soap_block<struct __saml2__union_AssertionType>::push(soap, soap_blist___union_AssertionType);
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml2__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml2__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml2:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_block<struct __saml2__union_AssertionType>::pop(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = soap_new___saml2__union_AssertionType(soap, a->__size_AssertionType);
			if (!a->__union_AssertionType)
				return NULL;
			soap_block<struct __saml2__union_AssertionType>::save(soap, soap_blist___union_AssertionType, a->__union_AssertionType);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_block<struct __saml2__union_AssertionType>::end(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__Issuer))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AssertionType, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AssertionType *p;
	size_t k = sizeof(struct saml2__AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_get_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	a->__sizexenc__EncryptedKey = 0;
	a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
		{
			soap_serialize_PointerToxenc__EncryptedKeyType(soap, a->xenc__EncryptedKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EncryptedElementType(struct soap *soap, const char *tag, int id, const struct saml2__EncryptedElementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EncryptedElementType), type))
		return soap->error;
	if (soap_out_xenc__EncryptedDataType(soap, "xenc:EncryptedData", -1, &a->xenc__EncryptedData, ""))
		return soap->error;
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
			if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, a->xenc__EncryptedKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_in_saml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedData = 1;
	struct soap_blist *soap_blist_xenc__EncryptedKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EncryptedElementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EncryptedElementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xenc__EncryptedDataType(soap, "xenc:EncryptedData", &a->xenc__EncryptedData, "xenc:EncryptedDataType"))
				{	soap_flag_xenc__EncryptedData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptedKey", 1, NULL))
			{	if (a->xenc__EncryptedKey == NULL)
				{	if (soap_blist_xenc__EncryptedKey == NULL)
						soap_blist_xenc__EncryptedKey = soap_alloc_block(soap);
					a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_push_block_max(soap, soap_blist_xenc__EncryptedKey, sizeof(struct xenc__EncryptedKeyType *));
					if (a->xenc__EncryptedKey == NULL)
						return NULL;
					*a->xenc__EncryptedKey = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	a->__sizexenc__EncryptedKey++;
					a->xenc__EncryptedKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->xenc__EncryptedKey)
			soap_pop_block(soap, soap_blist_xenc__EncryptedKey);
		if (a->__sizexenc__EncryptedKey)
		{	a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_save_block(soap, soap_blist_xenc__EncryptedKey, NULL, 1);
		}
		else
		{	a->xenc__EncryptedKey = NULL;
			if (soap_blist_xenc__EncryptedKey)
				soap_end_block(soap, soap_blist_xenc__EncryptedKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EncryptedElementType, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__EncryptedElementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__EncryptedElementType *p;
	size_t k = sizeof(struct saml2__EncryptedElementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__EncryptedElementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__EncryptedElementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__EncryptedElementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__EncryptedElementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_get_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Format);
	soap_default_string(soap, &a->SPProvidedID);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__NameIDType(struct soap *soap, const char *tag, int id, const struct saml2__NameIDType *a, const char *type)
{
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	if (a->SPProvidedID)
		soap_set_attr(soap, "SPProvidedID", soap_string2s(soap, a->SPProvidedID), 1);
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_in_saml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__NameIDType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPProvidedID", 1, 0), &a->SPProvidedID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:NameIDType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__NameIDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__NameIDType *p;
	size_t k = sizeof(struct saml2__NameIDType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__NameIDType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__NameIDType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__NameIDType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__NameIDType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_get_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__BaseIDAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_in_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__BaseIDAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__BaseIDAbstractType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__BaseIDAbstractType, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__BaseIDAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__BaseIDAbstractType *p;
	size_t k = sizeof(struct saml2__BaseIDAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__BaseIDAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__BaseIDAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__BaseIDAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__BaseIDAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_get_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Attribute(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Attribute(soap, tag ? tag : "saml1:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeDesignator(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeDesignator(soap, tag ? tag : "saml1:AttributeDesignator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeStatement(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeStatement(soap, tag ? tag : "saml1:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Evidence(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Evidence(soap, tag ? tag : "saml1:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Action(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Action(soap, tag ? tag : "saml1:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorizationDecisionStatement(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorizationDecisionStatement(soap, tag ? tag : "saml1:AuthorizationDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorityBinding(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorityBinding(soap, tag ? tag : "saml1:AuthorityBinding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectLocality(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectLocality(soap, tag ? tag : "saml1:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthenticationStatement(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthenticationStatement(soap, tag ? tag : "saml1:AuthenticationStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectConfirmation(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectConfirmation(soap, tag ? tag : "saml1:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__NameIdentifier(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__NameIdentifier(soap, tag ? tag : "saml1:NameIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Subject(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Subject(soap, tag ? tag : "saml1:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectStatement(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectStatement(soap, tag ? tag : "saml1:SubjectStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Statement(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Statement(soap, tag ? tag : "saml1:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Advice(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Advice(soap, tag ? tag : "saml1:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__DoNotCacheCondition(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__DoNotCacheCondition(soap, tag ? tag : "saml1:DoNotCacheCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AudienceRestrictionCondition(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AudienceRestrictionCondition(soap, tag ? tag : "saml1:AudienceRestrictionCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Condition(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Condition(soap, tag ? tag : "saml1:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Conditions(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Conditions(soap, tag ? tag : "saml1:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Assertion(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Assertion(soap, tag ? tag : "saml1:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_in___saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_EvidenceType *p;
	size_t k = sizeof(struct __saml1__union_EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_get___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_in___saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_AdviceType *p;
	size_t k = sizeof(struct __saml1__union_AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_get___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__AudienceRestrictionCondition = NULL;
	a->saml1__DoNotCacheCondition = NULL;
	a->saml1__Condition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, &a->saml1__AudienceRestrictionCondition);
	soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, &a->saml1__DoNotCacheCondition);
	soap_serialize_PointerTosaml1__ConditionAbstractType(soap, &a->saml1__Condition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml1__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", -1, &a->saml1__AudienceRestrictionCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", -1, &a->saml1__DoNotCacheCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", -1, &a->saml1__Condition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_in___saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml1__AudienceRestrictionCondition = 1;
	size_t soap_flag_saml1__DoNotCacheCondition = 1;
	size_t soap_flag_saml1__Condition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AudienceRestrictionCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", &a->saml1__AudienceRestrictionCondition, "saml1:AudienceRestrictionConditionType"))
				{	soap_flag_saml1__AudienceRestrictionCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__DoNotCacheCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", &a->saml1__DoNotCacheCondition, "saml1:DoNotCacheConditionType"))
				{	soap_flag_saml1__DoNotCacheCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", &a->saml1__Condition, "saml1:ConditionAbstractType"))
				{	soap_flag_saml1__Condition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_ConditionsType *p;
	size_t k = sizeof(struct __saml1__union_ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_get___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Statement = NULL;
	a->saml1__SubjectStatement = NULL;
	a->saml1__AuthenticationStatement = NULL;
	a->saml1__AuthorizationDecisionStatement = NULL;
	a->saml1__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__StatementAbstractType(soap, &a->saml1__Statement);
	soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, &a->saml1__SubjectStatement);
	soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, &a->saml1__AuthenticationStatement);
	soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, &a->saml1__AuthorizationDecisionStatement);
	soap_serialize_PointerTosaml1__AttributeStatementType(soap, &a->saml1__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", -1, &a->saml1__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", -1, &a->saml1__SubjectStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", -1, &a->saml1__AuthenticationStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", -1, &a->saml1__AuthorizationDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", -1, &a->saml1__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_in___saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Statement = 1;
	size_t soap_flag_saml1__SubjectStatement = 1;
	size_t soap_flag_saml1__AuthenticationStatement = 1;
	size_t soap_flag_saml1__AuthorizationDecisionStatement = 1;
	size_t soap_flag_saml1__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", &a->saml1__Statement, "saml1:StatementAbstractType"))
				{	soap_flag_saml1__Statement--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", &a->saml1__SubjectStatement, "saml1:SubjectStatementAbstractType"))
				{	soap_flag_saml1__SubjectStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthenticationStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", &a->saml1__AuthenticationStatement, "saml1:AuthenticationStatementType"))
				{	soap_flag_saml1__AuthenticationStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthorizationDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", &a->saml1__AuthorizationDecisionStatement, "saml1:AuthorizationDecisionStatementType"))
				{	soap_flag_saml1__AuthorizationDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", &a->saml1__AttributeStatement, "saml1:AttributeStatementType"))
				{	soap_flag_saml1__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_AssertionType *p;
	size_t k = sizeof(struct __saml1__union_AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_get___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
	a->__sizeAttributeValue = 0;
	a->saml1__AttributeValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeType), type))
		return soap->error;
	if (a->saml1__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml1:AttributeValue", (char*const*)(a->saml1__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_in_saml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AttributeValue", 1, NULL))
			{	if (a->saml1__AttributeValue == NULL)
				{	if (soap_blist_saml1__AttributeValue == NULL)
						soap_blist_saml1__AttributeValue = soap_alloc_block(soap);
					a->saml1__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml1__AttributeValue, sizeof(char *));
					if (a->saml1__AttributeValue == NULL)
						return NULL;
					*a->saml1__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml1:AttributeValue", (char**)a->saml1__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml1__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AttributeValue)
			soap_pop_block(soap, soap_blist_saml1__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml1__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml1__AttributeValue, NULL, 1);
		}
		else
		{	a->saml1__AttributeValue = NULL;
			if (soap_blist_saml1__AttributeValue)
				soap_end_block(soap, soap_blist_saml1__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAttributeValue < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeType, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeType *p;
	size_t k = sizeof(struct saml1__AttributeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_get_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeDesignatorType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeDesignatorType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_in_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, struct saml1__AttributeDesignatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeDesignatorType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeDesignatorType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeDesignatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeDesignatorType, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeDesignatorType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeDesignatorType *p;
	size_t k = sizeof(struct saml1__AttributeDesignatorType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeDesignatorType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeDesignatorType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeDesignatorType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeDesignatorType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeDesignatorType(soap, tag ? tag : "saml1:AttributeDesignatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_get_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeDesignatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAttribute = 0;
	a->saml1__Attribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
		{
			soap_embedded(soap, a->saml1__Attribute + i, SOAP_TYPE_saml1__AttributeType);
			soap_serialize_saml1__AttributeType(soap, a->saml1__Attribute + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
			if (soap_out_saml1__AttributeType(soap, "saml1:Attribute", -1, a->saml1__Attribute + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_in_saml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Attribute = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Attribute", 1, NULL))
			{	if (a->saml1__Attribute == NULL)
				{	if (soap_blist_saml1__Attribute == NULL)
						soap_blist_saml1__Attribute = soap_alloc_block(soap);
					a->saml1__Attribute = soap_block<struct saml1__AttributeType>::push(soap, soap_blist_saml1__Attribute);
					if (a->saml1__Attribute == NULL)
						return NULL;
					soap_default_saml1__AttributeType(soap, a->saml1__Attribute);
				}
				soap_revert(soap);
				if (soap_in_saml1__AttributeType(soap, "saml1:Attribute", a->saml1__Attribute, "saml1:AttributeType"))
				{	a->__sizeAttribute++;
					a->saml1__Attribute = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Attribute)
			soap_block<struct saml1__AttributeType>::pop(soap, soap_blist_saml1__Attribute);
		if (a->__sizeAttribute)
		{	a->saml1__Attribute = soap_new_saml1__AttributeType(soap, a->__sizeAttribute);
			if (!a->saml1__Attribute)
				return NULL;
			soap_block<struct saml1__AttributeType>::save(soap, soap_blist_saml1__Attribute, a->saml1__Attribute);
		}
		else
		{	a->saml1__Attribute = NULL;
			if (soap_blist_saml1__Attribute)
				soap_block<struct saml1__AttributeType>::end(soap, soap_blist_saml1__Attribute);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAttribute < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeStatementType, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeStatementType *p;
	size_t k = sizeof(struct saml1__AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_get_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml1__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml1__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml1__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_in_saml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = soap_block<struct __saml1__union_EvidenceType>::push(soap, soap_blist___union_EvidenceType);
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml1__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml1__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml1:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_block<struct __saml1__union_EvidenceType>::pop(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = soap_new___saml1__union_EvidenceType(soap, a->__size_EvidenceType);
			if (!a->__union_EvidenceType)
				return NULL;
			soap_block<struct __saml1__union_EvidenceType>::save(soap, soap_blist___union_EvidenceType, a->__union_EvidenceType);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_block<struct __saml1__union_EvidenceType>::end(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__EvidenceType, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__EvidenceType *p;
	size_t k = sizeof(struct saml1__EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_get_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ActionType(struct soap *soap, struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ActionType(struct soap *soap, const char *tag, int id, const struct saml1__ActionType *a, const char *type)
{
	if (a->Namespace)
		soap_set_attr(soap, "Namespace", soap_string2s(soap, a->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_in_saml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 0), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ActionType *p;
	size_t k = sizeof(struct saml1__ActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_get_saml1__ActionType(struct soap *soap, struct saml1__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAction = 0;
	a->saml1__Action = NULL;
	a->saml1__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml1__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml1__Action + i, SOAP_TYPE_saml1__ActionType);
			soap_serialize_saml1__ActionType(soap, a->saml1__Action + i);
		}
	}
	soap_serialize_PointerTosaml1__EvidenceType(soap, &a->saml1__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml1__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml1__ActionType(soap, "saml1:Action", -1, a->saml1__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", -1, &a->saml1__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_in_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Action = NULL;
	size_t soap_flag_saml1__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorizationDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorizationDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml1__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Action", 1, NULL))
			{	if (a->saml1__Action == NULL)
				{	if (soap_blist_saml1__Action == NULL)
						soap_blist_saml1__Action = soap_alloc_block(soap);
					a->saml1__Action = soap_block<struct saml1__ActionType>::push(soap, soap_blist_saml1__Action);
					if (a->saml1__Action == NULL)
						return NULL;
					soap_default_saml1__ActionType(soap, a->saml1__Action);
				}
				soap_revert(soap);
				if (soap_in_saml1__ActionType(soap, "saml1:Action", a->saml1__Action, "saml1:ActionType"))
				{	a->__sizeAction++;
					a->saml1__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", &a->saml1__Evidence, "saml1:EvidenceType"))
				{	soap_flag_saml1__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Action)
			soap_block<struct saml1__ActionType>::pop(soap, soap_blist_saml1__Action);
		if (a->__sizeAction)
		{	a->saml1__Action = soap_new_saml1__ActionType(soap, a->__sizeAction);
			if (!a->saml1__Action)
				return NULL;
			soap_block<struct saml1__ActionType>::save(soap, soap_blist_saml1__Action, a->saml1__Action);
		}
		else
		{	a->saml1__Action = NULL;
			if (soap_blist_saml1__Action)
				soap_block<struct saml1__ActionType>::end(soap, soap_blist_saml1__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthorizationDecisionStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthorizationDecisionStatementType *p;
	size_t k = sizeof(struct saml1__AuthorizationDecisionStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthorizationDecisionStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthorizationDecisionStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthorizationDecisionStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_get_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->AuthorityKind);
	soap_default_string(soap, &a->Location);
	soap_default_string(soap, &a->Binding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorityBindingType *a, const char *type)
{
	soap_set_attr(soap, "AuthorityKind", a->AuthorityKind ? soap__QName2s(soap, a->AuthorityKind) : "", 1);
	soap_set_attr(soap, "Location", a->Location ? soap_string2s(soap, a->Location) : "", 1);
	soap_set_attr(soap, "Binding", a->Binding ? soap_string2s(soap, a->Binding) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorityBindingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_in_saml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorityBindingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorityBindingType(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "AuthorityKind", 2, 1), &a->AuthorityKind))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Location", 1, 1), &a->Location))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Binding", 1, 1), &a->Binding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorityBindingType, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthorityBindingType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthorityBindingType *p;
	size_t k = sizeof(struct saml1__AuthorityBindingType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthorityBindingType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthorityBindingType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthorityBindingType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthorityBindingType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_get_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
	soap_default_string(soap, &a->DNSAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectLocalityType *a, const char *type)
{
	if (a->IPAddress)
		soap_set_attr(soap, "IPAddress", soap_string2s(soap, a->IPAddress), 1);
	if (a->DNSAddress)
		soap_set_attr(soap, "DNSAddress", soap_string2s(soap, a->DNSAddress), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_in_saml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "IPAddress", 1, 0), &a->IPAddress))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSAddress", 1, 0), &a->DNSAddress))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectLocalityType, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectLocalityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectLocalityType *p;
	size_t k = sizeof(struct saml1__SubjectLocalityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectLocalityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectLocalityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectLocalityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectLocalityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_get_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->saml1__SubjectLocality = NULL;
	a->__sizeAuthorityBinding = 0;
	a->saml1__AuthorityBinding = NULL;
	soap_default_string(soap, &a->AuthenticationMethod);
	soap_default_dateTime(soap, &a->AuthenticationInstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	soap_serialize_PointerTosaml1__SubjectLocalityType(soap, &a->saml1__SubjectLocality);
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
		{
			soap_embedded(soap, a->saml1__AuthorityBinding + i, SOAP_TYPE_saml1__AuthorityBindingType);
			soap_serialize_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthenticationStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthenticationMethod", a->AuthenticationMethod ? soap_string2s(soap, a->AuthenticationMethod) : "", 1);
	soap_set_attr(soap, "AuthenticationInstant", soap_dateTime2s(soap, a->AuthenticationInstant), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthenticationStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", -1, &a->saml1__SubjectLocality, ""))
		return soap->error;
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
			if (soap_out_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", -1, a->saml1__AuthorityBinding + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_in_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	size_t soap_flag_saml1__SubjectLocality = 1;
	struct soap_blist *soap_blist_saml1__AuthorityBinding = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthenticationStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthenticationStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AuthenticationMethod", 1, 1), &a->AuthenticationMethod))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "AuthenticationInstant", 5, 1), &a->AuthenticationInstant))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", &a->saml1__SubjectLocality, "saml1:SubjectLocalityType"))
				{	soap_flag_saml1__SubjectLocality--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AuthorityBinding", 1, NULL))
			{	if (a->saml1__AuthorityBinding == NULL)
				{	if (soap_blist_saml1__AuthorityBinding == NULL)
						soap_blist_saml1__AuthorityBinding = soap_alloc_block(soap);
					a->saml1__AuthorityBinding = soap_block<struct saml1__AuthorityBindingType>::push(soap, soap_blist_saml1__AuthorityBinding);
					if (a->saml1__AuthorityBinding == NULL)
						return NULL;
					soap_default_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding);
				}
				soap_revert(soap);
				if (soap_in_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", a->saml1__AuthorityBinding, "saml1:AuthorityBindingType"))
				{	a->__sizeAuthorityBinding++;
					a->saml1__AuthorityBinding = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AuthorityBinding)
			soap_block<struct saml1__AuthorityBindingType>::pop(soap, soap_blist_saml1__AuthorityBinding);
		if (a->__sizeAuthorityBinding)
		{	a->saml1__AuthorityBinding = soap_new_saml1__AuthorityBindingType(soap, a->__sizeAuthorityBinding);
			if (!a->saml1__AuthorityBinding)
				return NULL;
			soap_block<struct saml1__AuthorityBindingType>::save(soap, soap_blist_saml1__AuthorityBinding, a->saml1__AuthorityBinding);
		}
		else
		{	a->saml1__AuthorityBinding = NULL;
			if (soap_blist_saml1__AuthorityBinding)
				soap_block<struct saml1__AuthorityBindingType>::end(soap, soap_blist_saml1__AuthorityBinding);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthenticationStatementType, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthenticationStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthenticationStatementType *p;
	size_t k = sizeof(struct saml1__AuthenticationStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthenticationStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthenticationStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthenticationStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthenticationStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_get_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfirmationMethod = 0;
	a->saml1__ConfirmationMethod = NULL;
	a->saml1__SubjectConfirmationData = NULL;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__ConfirmationMethod + i));
		}
	}
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectConfirmationType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectConfirmationType), type))
		return soap->error;
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
			if (soap_out_string(soap, "saml1:ConfirmationMethod", -1, (char*const*)(a->saml1__ConfirmationMethod + i), ""))
				return soap->error;
	}
	if (soap_outliteral(soap, "saml1:SubjectConfirmationData", (char*const*)&a->saml1__SubjectConfirmationData, NULL))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__ConfirmationMethod = NULL;
	size_t soap_flag_saml1__SubjectConfirmationData = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectConfirmationType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:ConfirmationMethod", 1, NULL))
			{	if (a->saml1__ConfirmationMethod == NULL)
				{	if (soap_blist_saml1__ConfirmationMethod == NULL)
						soap_blist_saml1__ConfirmationMethod = soap_alloc_block(soap);
					a->saml1__ConfirmationMethod = (char **)soap_push_block_max(soap, soap_blist_saml1__ConfirmationMethod, sizeof(char *));
					if (a->saml1__ConfirmationMethod == NULL)
						return NULL;
					*a->saml1__ConfirmationMethod = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:ConfirmationMethod", (char**)a->saml1__ConfirmationMethod, "xsd:string"))
				{	a->__sizeConfirmationMethod++;
					a->saml1__ConfirmationMethod = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmationData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml1:SubjectConfirmationData", (char**)&a->saml1__SubjectConfirmationData))
				{	soap_flag_saml1__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__ConfirmationMethod)
			soap_pop_block(soap, soap_blist_saml1__ConfirmationMethod);
		if (a->__sizeConfirmationMethod)
		{	a->saml1__ConfirmationMethod = (char **)soap_save_block(soap, soap_blist_saml1__ConfirmationMethod, NULL, 1);
		}
		else
		{	a->saml1__ConfirmationMethod = NULL;
			if (soap_blist_saml1__ConfirmationMethod)
				soap_end_block(soap, soap_blist_saml1__ConfirmationMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfirmationMethod < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectConfirmationType, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectConfirmationType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectConfirmationType *p;
	size_t k = sizeof(struct saml1__SubjectConfirmationType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectConfirmationType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectConfirmationType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectConfirmationType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectConfirmationType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->Format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__NameIdentifierType(struct soap *soap, const char *tag, int id, const struct saml1__NameIdentifierType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_in_saml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__NameIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__NameIdentifierType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:NameIdentifierType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__NameIdentifierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__NameIdentifierType *p;
	size_t k = sizeof(struct saml1__NameIdentifierType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__NameIdentifierType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__NameIdentifierType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__NameIdentifierType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__NameIdentifierType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_get_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__NameIdentifier = NULL;
	a->saml1__SubjectConfirmation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__NameIdentifierType(soap, &a->saml1__NameIdentifier);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", -1, &a->saml1__NameIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_in_saml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType *a, const char *type)
{
	size_t soap_flag_saml1__NameIdentifier = 1;
	size_t soap_flag_saml1__SubjectConfirmation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__NameIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", &a->saml1__NameIdentifier, "saml1:NameIdentifierType"))
				{	soap_flag_saml1__NameIdentifier--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectType, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectType *p;
	size_t k = sizeof(struct saml1__SubjectType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_get_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_in_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectStatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectStatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectStatementAbstractType, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectStatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectStatementAbstractType *p;
	size_t k = sizeof(struct saml1__SubjectStatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectStatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectStatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectStatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectStatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_get_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_in_saml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__StatementAbstractType, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__StatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__StatementAbstractType *p;
	size_t k = sizeof(struct saml1__StatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__StatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__StatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__StatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__StatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_get_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml1__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AdviceType(struct soap *soap, const char *tag, int id, const struct saml1__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml1__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_in_saml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = soap_block<struct __saml1__union_AdviceType>::push(soap, soap_blist___union_AdviceType);
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml1__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml1__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml1:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_block<struct __saml1__union_AdviceType>::pop(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = soap_new___saml1__union_AdviceType(soap, a->__size_AdviceType);
			if (!a->__union_AdviceType)
				return NULL;
			soap_block<struct __saml1__union_AdviceType>::save(soap, soap_blist___union_AdviceType, a->__union_AdviceType);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_block<struct __saml1__union_AdviceType>::end(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AdviceType, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AdviceType *p;
	size_t k = sizeof(struct saml1__AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_get_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, const struct saml1__DoNotCacheConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DoNotCacheConditionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_in_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__DoNotCacheConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__DoNotCacheConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DoNotCacheConditionType, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__DoNotCacheConditionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__DoNotCacheConditionType *p;
	size_t k = sizeof(struct saml1__DoNotCacheConditionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__DoNotCacheConditionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__DoNotCacheConditionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__DoNotCacheConditionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__DoNotCacheConditionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_get_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml1__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, const struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType), type))
		return soap->error;
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml1:Audience", -1, (char*const*)(a->saml1__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_in_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AudienceRestrictionConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AudienceRestrictionConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Audience", 1, NULL))
			{	if (a->saml1__Audience == NULL)
				{	if (soap_blist_saml1__Audience == NULL)
						soap_blist_saml1__Audience = soap_alloc_block(soap);
					a->saml1__Audience = (char **)soap_push_block_max(soap, soap_blist_saml1__Audience, sizeof(char *));
					if (a->saml1__Audience == NULL)
						return NULL;
					*a->saml1__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:Audience", (char**)a->saml1__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml1__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Audience)
			soap_pop_block(soap, soap_blist_saml1__Audience);
		if (a->__sizeAudience)
		{	a->saml1__Audience = (char **)soap_save_block(soap, soap_blist_saml1__Audience, NULL, 1);
		}
		else
		{	a->saml1__Audience = NULL;
			if (soap_blist_saml1__Audience)
				soap_end_block(soap, soap_blist_saml1__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AudienceRestrictionConditionType, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AudienceRestrictionConditionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AudienceRestrictionConditionType *p;
	size_t k = sizeof(struct saml1__AudienceRestrictionConditionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AudienceRestrictionConditionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AudienceRestrictionConditionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AudienceRestrictionConditionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AudienceRestrictionConditionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_get_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_in_saml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionAbstractType, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ConditionAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ConditionAbstractType *p;
	size_t k = sizeof(struct saml1__ConditionAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ConditionAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ConditionAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ConditionAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ConditionAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_get_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml1__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml1__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_in_saml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = soap_block<struct __saml1__union_ConditionsType>::push(soap, soap_blist___union_ConditionsType);
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml1__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml1__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml1:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_block<struct __saml1__union_ConditionsType>::pop(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = soap_new___saml1__union_ConditionsType(soap, a->__size_ConditionsType);
			if (!a->__union_ConditionsType)
				return NULL;
			soap_block<struct __saml1__union_ConditionsType>::save(soap, soap_blist___union_ConditionsType, a->__union_ConditionsType);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_block<struct __saml1__union_ConditionsType>::end(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionsType, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ConditionsType *p;
	size_t k = sizeof(struct saml1__ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_get_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Conditions = NULL;
	a->saml1__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->MajorVersion);
	soap_default_string(soap, &a->MinorVersion);
	soap_default_string(soap, &a->AssertionID);
	soap_default_string(soap, &a->Issuer);
	soap_default_dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__ConditionsType(soap, &a->saml1__Conditions);
	soap_serialize_PointerTosaml1__AdviceType(soap, &a->saml1__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml1__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AssertionType(struct soap *soap, const char *tag, int id, const struct saml1__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "MajorVersion", a->MajorVersion ? soap_string2s(soap, a->MajorVersion) : "", 1);
	soap_set_attr(soap, "MinorVersion", a->MinorVersion ? soap_string2s(soap, a->MinorVersion) : "", 1);
	soap_set_attr(soap, "AssertionID", a->AssertionID ? soap_string2s(soap, a->AssertionID) : "", 1);
	soap_set_attr(soap, "Issuer", a->Issuer ? soap_string2s(soap, a->Issuer) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AssertionType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", -1, &a->saml1__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AdviceType(soap, "saml1:Advice", -1, &a->saml1__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml1__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_in_saml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Conditions = 1;
	size_t soap_flag_saml1__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MajorVersion", 1, 1), &a->MajorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MinorVersion", 1, 1), &a->MinorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AssertionID", 1, 1), &a->AssertionID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Issuer", 1, 1), &a->Issuer))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", &a->saml1__Conditions, "saml1:ConditionsType"))
				{	soap_flag_saml1__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml1__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AdviceType(soap, "saml1:Advice", &a->saml1__Advice, "saml1:AdviceType"))
				{	soap_flag_saml1__Advice--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = soap_block<struct __saml1__union_AssertionType>::push(soap, soap_blist___union_AssertionType);
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml1__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml1__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml1:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_block<struct __saml1__union_AssertionType>::pop(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = soap_new___saml1__union_AssertionType(soap, a->__size_AssertionType);
			if (!a->__union_AssertionType)
				return NULL;
			soap_block<struct __saml1__union_AssertionType>::save(soap, soap_blist___union_AssertionType, a->__union_AssertionType);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_block<struct __saml1__union_AssertionType>::end(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AssertionType, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AssertionType *p;
	size_t k = sizeof(struct saml1__AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_get_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = -1;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerToULONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerToULONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsc__DerivedKeyTokenType_sequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToULONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsc__DerivedKeyTokenType_sequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsc__DerivedKeyTokenType_sequence *p;
	size_t k = sizeof(struct __wsc__DerivedKeyTokenType_sequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsc__DerivedKeyTokenType_sequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsc__DerivedKeyTokenType_sequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsc__DerivedKeyTokenType_sequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__PropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__PropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__PropertiesType *p;
	size_t k = sizeof(struct wsc__PropertiesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__PropertiesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__PropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__PropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__PropertiesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, &a->__DerivedKeyTokenType_sequence);
	soap_serialize_string(soap, (char*const*)&a->Label);
	soap_serialize_string(soap, (char*const*)&a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, &a->__DerivedKeyTokenType_sequence, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Label", -1, (char*const*)&a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, (char*const*)&a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	size_t soap_flag___DerivedKeyTokenType_sequence = 1;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__DerivedKeyTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Label", (char**)&a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Nonce", (char**)&a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", &a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	soap_flag___DerivedKeyTokenType_sequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__DerivedKeyTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__DerivedKeyTokenType *p;
	size_t k = sizeof(struct wsc__DerivedKeyTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__DerivedKeyTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__DerivedKeyTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__DerivedKeyTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__DerivedKeyTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag ? tag : "wsc:DerivedKeyTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_string(soap, (char*const*)&a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, (char*const*)&a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__SecurityContextTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Instance", (char**)&a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__SecurityContextTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__SecurityContextTokenType *p;
	size_t k = sizeof(struct wsc__SecurityContextTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__SecurityContextTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__SecurityContextTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__SecurityContextTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__SecurityContextTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __xenc__union_ReferenceList*)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___xenc__union_ReferenceList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __xenc__union_ReferenceList *p;
	size_t k = sizeof(struct __xenc__union_ReferenceList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___xenc__union_ReferenceList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __xenc__union_ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __xenc__union_ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __xenc__union_ReferenceList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out___xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _xenc__ReferenceList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_alloc_block(soap);
					a->__union_ReferenceList = soap_block<struct __xenc__union_ReferenceList>::push(soap, soap_blist___union_ReferenceList);
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_block<struct __xenc__union_ReferenceList>::pop(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
		{	a->__union_ReferenceList = soap_new___xenc__union_ReferenceList(soap, a->__size_ReferenceList);
			if (!a->__union_ReferenceList)
				return NULL;
			soap_block<struct __xenc__union_ReferenceList>::save(soap, soap_blist___union_ReferenceList, a->__union_ReferenceList);
		}
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_block<struct __xenc__union_ReferenceList>::end(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xenc__ReferenceList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xenc__ReferenceList *p;
	size_t k = sizeof(struct _xenc__ReferenceList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xenc__ReferenceList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xenc__ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xenc__ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xenc__ReferenceList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out__xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", soap_string2s(soap, a->Target), 1);
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 1, 0), &a->Target))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertyType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionPropertyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionPropertyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionPropertyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_alloc_block(soap);
					a->EncryptionProperty = soap_block<struct xenc__EncryptionPropertyType>::push(soap, soap_blist_EncryptionProperty);
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_block<struct xenc__EncryptionPropertyType>::pop(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
		{	a->EncryptionProperty = soap_new_xenc__EncryptionPropertyType(soap, a->__sizeEncryptionProperty);
			if (!a->EncryptionProperty)
				return NULL;
			soap_block<struct xenc__EncryptionPropertyType>::save(soap, soap_blist_EncryptionProperty, a->EncryptionProperty);
		}
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_block<struct xenc__EncryptionPropertyType>::end(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertiesType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertiesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionPropertiesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionPropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionPropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertiesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__ReferenceType *p;
	size_t k = sizeof(struct xenc__ReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__ReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__ReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, (char*const*)&a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__AgreementMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:KA-Nonce", (char**)&a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__AgreementMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__AgreementMethodType *p;
	size_t k = sizeof(struct xenc__AgreementMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__AgreementMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__AgreementMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__AgreementMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__AgreementMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__AgreementMethodType(soap, tag ? tag : "xenc:AgreementMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, (char*const*)&a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, (char*const*)&a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedKeyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CarriedKeyName", (char**)&a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedKeyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedKeyType *p;
	size_t k = sizeof(struct xenc__EncryptedKeyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedKeyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedKeyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedKeyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedKeyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedDataType *p;
	size_t k = sizeof(struct xenc__EncryptedDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedDataType(soap, tag ? tag : "xenc:EncryptedDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__TransformsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__TransformsType *p;
	size_t k = sizeof(struct xenc__TransformsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__TransformsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__TransformsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherReferenceType *p;
	size_t k = sizeof(struct xenc__CipherReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__CipherReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__CipherReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__CipherReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, (char*const*)&a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CipherValue", (char**)&a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherDataType *p;
	size_t k = sizeof(struct xenc__CipherDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__CipherDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__CipherDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__CipherDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, (char*const*)&a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, (char*const*)&a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:OAEPparams", (char**)&a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionMethodType *p;
	size_t k = sizeof(struct xenc__EncryptionMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedType *p;
	size_t k = sizeof(struct xenc__EncryptedType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedType(soap, tag ? tag : "xenc:EncryptedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Modulus);
	soap_serialize_string(soap, (char*const*)&a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (!a->Modulus)
	{	if (soap_element_empty(soap, "ds:Modulus"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Modulus", -1, (char*const*)&a->Modulus, ""))
		return soap->error;
	if (!a->Exponent)
	{	if (soap_element_empty(soap, "ds:Exponent"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Exponent", -1, (char*const*)&a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Modulus", (char**)&a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Exponent", (char**)&a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Modulus || !a->Exponent))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RSAKeyValueType *p;
	size_t k = sizeof(struct ds__RSAKeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__RSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__RSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RSAKeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->G);
	soap_serialize_string(soap, (char*const*)&a->Y);
	soap_serialize_string(soap, (char*const*)&a->J);
	soap_serialize_string(soap, (char*const*)&a->P);
	soap_serialize_string(soap, (char*const*)&a->Q);
	soap_serialize_string(soap, (char*const*)&a->Seed);
	soap_serialize_string(soap, (char*const*)&a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, (char*const*)&a->G, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_empty(soap, "ds:Y"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Y", -1, (char*const*)&a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, (char*const*)&a->J, ""))
		return soap->error;
	if (!a->P)
	{	if (soap_element_empty(soap, "ds:P"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:P", -1, (char*const*)&a->P, ""))
		return soap->error;
	if (!a->Q)
	{	if (soap_element_empty(soap, "ds:Q"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Q", -1, (char*const*)&a->Q, ""))
		return soap->error;
	if (!a->Seed)
	{	if (soap_element_empty(soap, "ds:Seed"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Seed", -1, (char*const*)&a->Seed, ""))
		return soap->error;
	if (!a->PgenCounter)
	{	if (soap_element_empty(soap, "ds:PgenCounter"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:PgenCounter", -1, (char*const*)&a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:G", (char**)&a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Y", (char**)&a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:J", (char**)&a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:P", (char**)&a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Q", (char**)&a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Seed", (char**)&a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:PgenCounter", (char**)&a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Y || !a->P || !a->Q || !a->Seed || !a->PgenCounter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DSAKeyValueType *p;
	size_t k = sizeof(struct ds__DSAKeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__DSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__DSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DSAKeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->X509IssuerName);
	soap_serialize_string(soap, (char*const*)&a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (!a->X509IssuerName)
	{	if (soap_element_empty(soap, "ds:X509IssuerName"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509IssuerName", -1, (char*const*)&a->X509IssuerName, ""))
		return soap->error;
	if (!a->X509SerialNumber)
	{	if (soap_element_empty(soap, "ds:X509SerialNumber"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509SerialNumber", -1, (char*const*)&a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509IssuerSerialType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509IssuerName", (char**)&a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SerialNumber", (char**)&a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->X509IssuerName || !a->X509SerialNumber))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509IssuerSerialType *p;
	size_t k = sizeof(struct ds__X509IssuerSerialType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__X509IssuerSerialType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__X509IssuerSerialType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509IssuerSerialType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__KeyInfo(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out__ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RetrievalMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RetrievalMethodType *p;
	size_t k = sizeof(struct ds__RetrievalMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__RetrievalMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__RetrievalMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RetrievalMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyValueType *p;
	size_t k = sizeof(struct ds__KeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__KeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__KeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DigestMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DigestMethodType *p;
	size_t k = sizeof(struct ds__DigestMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__DigestMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__DigestMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DigestMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Transform(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Transform(soap, tag ? tag : "ds:Transform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformType *p;
	size_t k = sizeof(struct ds__TransformType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__TransformType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__TransformType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", soap_string2s(soap, a->PrefixList), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _c14n__InclusiveNamespaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 1, 0), &a->PrefixList))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _c14n__InclusiveNamespaces *p;
	size_t k = sizeof(struct _c14n__InclusiveNamespaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _c14n__InclusiveNamespaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _c14n__InclusiveNamespaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _c14n__InclusiveNamespaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	if (soap_out__c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_alloc_block(soap);
					a->Transform = soap_block<struct ds__TransformType>::push(soap, soap_blist_Transform);
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_block<struct ds__TransformType>::pop(soap, soap_blist_Transform);
		if (a->__sizeTransform)
		{	a->Transform = soap_new_ds__TransformType(soap, a->__sizeTransform);
			if (!a->Transform)
				return NULL;
			soap_block<struct ds__TransformType>::save(soap, soap_blist_Transform, a->Transform);
		}
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_block<struct ds__TransformType>::end(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformsType *p;
	size_t k = sizeof(struct ds__TransformsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, (char*const*)&a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (!a->DigestMethod)
	{	if (soap_element_empty(soap, "ds:DigestMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (!a->DigestValue)
	{	if (soap_element_empty(soap, "ds:DigestValue"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:DigestValue", -1, (char*const*)&a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:DigestValue", (char**)&a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigestMethod || !a->DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__ReferenceType *p;
	size_t k = sizeof(struct ds__ReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__ReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_ds__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureMethodType *p;
	size_t k = sizeof(struct ds__SignatureMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignatureMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignatureMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__CanonicalizationMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__CanonicalizationMethodType *p;
	size_t k = sizeof(struct ds__CanonicalizationMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__CanonicalizationMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__CanonicalizationMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__CanonicalizationMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Signature(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, (char*const*)&a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:KeyName", (char**)&a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyInfoType *p;
	size_t k = sizeof(struct ds__KeyInfoType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__KeyInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__KeyInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyInfoType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (!a->CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ds:CanonicalizationMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (!a->SignatureMethod)
	{	if (soap_element_empty(soap, "ds:SignatureMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignedInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_alloc_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block_max(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
		{	a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		}
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CanonicalizationMethod || !a->SignatureMethod))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignedInfoType *p;
	size_t k = sizeof(struct ds__SignedInfoType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignedInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignedInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignedInfoType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default__ds__SignatureValue(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize__ds__SignatureValue(soap, (char*const*)&a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out__ds__SignatureValue(soap, "ds:SignatureValue", -1, (char*const*)&a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__ds__SignatureValue(soap, "ds:SignatureValue", (char**)&a->SignatureValue, ""))
				{	soap_flag_SignatureValue--;
					continue;
				}
			}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureType *p;
	size_t k = sizeof(struct ds__SignatureType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignatureType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignatureType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, (char*const*)&a->X509SKI);
	soap_serialize_string(soap, (char*const*)&a->X509SubjectName);
	soap_serialize_string(soap, (char*const*)&a->X509Certificate);
	soap_serialize_string(soap, (char*const*)&a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, (char*const*)&a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, (char*const*)&a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, (char*const*)&a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, (char*const*)&a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509DataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SKI", (char**)&a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SubjectName", (char**)&a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509Certificate", (char**)&a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509CRL", (char**)&a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509DataType *p;
	size_t k = sizeof(struct ds__X509DataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__X509DataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__X509DataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509DataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", soap_string2s(soap, a->wsc__Instance), 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", soap_string2s(soap, a->Usage), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__SecurityTokenReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 1, 0), &a->wsc__Instance))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 1, 0), &a->Usage))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__SecurityTokenReference *p;
	size_t k = sizeof(struct _wsse__SecurityTokenReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__SecurityTokenReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__SecurityTokenReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__SecurityTokenReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__KeyIdentifier *p;
	size_t k = sizeof(struct _wsse__KeyIdentifier);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__KeyIdentifier);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__KeyIdentifier, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__KeyIdentifier location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	if (soap_out__wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Embedded*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Embedded *p;
	size_t k = sizeof(struct _wsse__Embedded);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Embedded);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Embedded, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Embedded location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Reference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Reference *p;
	size_t k = sizeof(struct _wsse__Reference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Reference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Reference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Reference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__BinarySecurityToken *p;
	size_t k = sizeof(struct _wsse__BinarySecurityToken);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__BinarySecurityToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__BinarySecurityToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__BinarySecurityToken location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Password *p;
	size_t k = sizeof(struct _wsse__Password);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Password);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Password, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Password location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	a->Nonce = NULL;
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_PointerTowsse__EncodedString(soap, &a->Nonce);
	soap_serialize_string(soap, (char*const*)&a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_PointerTowsse__EncodedString(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__UsernameToken*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsse:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_Nonce && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsse__EncodedString(soap, "wsse:Nonce", &a->Nonce, "wsse:EncodedString"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__UsernameToken *p;
	size_t k = sizeof(struct _wsse__UsernameToken);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__UsernameToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__UsernameToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__UsernameToken location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->EncodingType);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__EncodedString(struct soap *soap, const char *tag, int id, const struct wsse__EncodedString *a, const char *type)
{
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_in_wsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsse__EncodedString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsse__EncodedString(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsse:EncodedString"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsse__EncodedString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsse__EncodedString *p;
	size_t k = sizeof(struct wsse__EncodedString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsse__EncodedString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsse__EncodedString);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsse__EncodedString, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsse__EncodedString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a, const char *tag, const char *type)
{
	if (soap_out_wsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_get_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Created);
	soap_serialize_string(soap, (char*const*)&a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, (char*const*)&a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsu__Timestamp*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Expires", (char**)&a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsu__Timestamp *p;
	size_t k = sizeof(struct _wsu__Timestamp);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsu__Timestamp);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsu__Timestamp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsu__Timestamp location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	if (soap_out__wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetWarnings(struct soap *soap, struct __name2__GetWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetWarnings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetWarnings(struct soap *soap, const struct __name2__GetWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetWarnings(soap, &a->tempuri__GetWarnings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetWarnings(struct soap *soap, const char *tag, int id, const struct __name2__GetWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetWarnings(soap, "tempuri:GetWarnings", -1, &a->tempuri__GetWarnings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetWarnings * SOAP_FMAC4 soap_in___name2__GetWarnings(struct soap *soap, const char *tag, struct __name2__GetWarnings *a, const char *type)
{
	size_t soap_flag_tempuri__GetWarnings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetWarnings*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetWarnings, sizeof(struct __name2__GetWarnings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetWarnings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetWarnings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetWarnings(soap, "tempuri:GetWarnings", &a->tempuri__GetWarnings, ""))
				{	soap_flag_tempuri__GetWarnings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetWarnings * SOAP_FMAC2 soap_instantiate___name2__GetWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetWarnings *p;
	size_t k = sizeof(struct __name2__GetWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetWarnings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetWarnings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetWarnings(struct soap *soap, const struct __name2__GetWarnings *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetWarnings(soap, tag ? tag : "-name2:GetWarnings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetWarnings * SOAP_FMAC4 soap_get___name2__GetWarnings(struct soap *soap, struct __name2__GetWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__HasWarnings(struct soap *soap, struct __name2__HasWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasWarnings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__HasWarnings(struct soap *soap, const struct __name2__HasWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasWarnings(soap, &a->tempuri__HasWarnings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__HasWarnings(struct soap *soap, const char *tag, int id, const struct __name2__HasWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasWarnings(soap, "tempuri:HasWarnings", -1, &a->tempuri__HasWarnings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasWarnings * SOAP_FMAC4 soap_in___name2__HasWarnings(struct soap *soap, const char *tag, struct __name2__HasWarnings *a, const char *type)
{
	size_t soap_flag_tempuri__HasWarnings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__HasWarnings*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__HasWarnings, sizeof(struct __name2__HasWarnings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__HasWarnings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasWarnings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasWarnings(soap, "tempuri:HasWarnings", &a->tempuri__HasWarnings, ""))
				{	soap_flag_tempuri__HasWarnings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__HasWarnings * SOAP_FMAC2 soap_instantiate___name2__HasWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__HasWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__HasWarnings *p;
	size_t k = sizeof(struct __name2__HasWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__HasWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__HasWarnings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__HasWarnings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__HasWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__HasWarnings(struct soap *soap, const struct __name2__HasWarnings *a, const char *tag, const char *type)
{
	if (soap_out___name2__HasWarnings(soap, tag ? tag : "-name2:HasWarnings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasWarnings * SOAP_FMAC4 soap_get___name2__HasWarnings(struct soap *soap, struct __name2__HasWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__HasWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetErrors(struct soap *soap, struct __name2__GetErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetErrors = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetErrors(struct soap *soap, const struct __name2__GetErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetErrors(soap, &a->tempuri__GetErrors);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetErrors(struct soap *soap, const char *tag, int id, const struct __name2__GetErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetErrors(soap, "tempuri:GetErrors", -1, &a->tempuri__GetErrors, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetErrors * SOAP_FMAC4 soap_in___name2__GetErrors(struct soap *soap, const char *tag, struct __name2__GetErrors *a, const char *type)
{
	size_t soap_flag_tempuri__GetErrors = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetErrors*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetErrors, sizeof(struct __name2__GetErrors), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetErrors(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetErrors && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetErrors(soap, "tempuri:GetErrors", &a->tempuri__GetErrors, ""))
				{	soap_flag_tempuri__GetErrors--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetErrors * SOAP_FMAC2 soap_instantiate___name2__GetErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetErrors *p;
	size_t k = sizeof(struct __name2__GetErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetErrors);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetErrors, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetErrors(struct soap *soap, const struct __name2__GetErrors *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetErrors(soap, tag ? tag : "-name2:GetErrors", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetErrors * SOAP_FMAC4 soap_get___name2__GetErrors(struct soap *soap, struct __name2__GetErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__HasErrors(struct soap *soap, struct __name2__HasErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasErrors = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__HasErrors(struct soap *soap, const struct __name2__HasErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasErrors(soap, &a->tempuri__HasErrors);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__HasErrors(struct soap *soap, const char *tag, int id, const struct __name2__HasErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasErrors(soap, "tempuri:HasErrors", -1, &a->tempuri__HasErrors, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasErrors * SOAP_FMAC4 soap_in___name2__HasErrors(struct soap *soap, const char *tag, struct __name2__HasErrors *a, const char *type)
{
	size_t soap_flag_tempuri__HasErrors = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__HasErrors*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__HasErrors, sizeof(struct __name2__HasErrors), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__HasErrors(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasErrors && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasErrors(soap, "tempuri:HasErrors", &a->tempuri__HasErrors, ""))
				{	soap_flag_tempuri__HasErrors--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__HasErrors * SOAP_FMAC2 soap_instantiate___name2__HasErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__HasErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__HasErrors *p;
	size_t k = sizeof(struct __name2__HasErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__HasErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__HasErrors);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__HasErrors, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__HasErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__HasErrors(struct soap *soap, const struct __name2__HasErrors *a, const char *tag, const char *type)
{
	if (soap_out___name2__HasErrors(soap, tag ? tag : "-name2:HasErrors", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasErrors * SOAP_FMAC4 soap_get___name2__HasErrors(struct soap *soap, struct __name2__HasErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__HasErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetMessage(struct soap *soap, struct __name2__GetMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetMessage(struct soap *soap, const struct __name2__GetMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetMessage(soap, &a->tempuri__GetMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetMessage(struct soap *soap, const char *tag, int id, const struct __name2__GetMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetMessage(soap, "tempuri:GetMessage", -1, &a->tempuri__GetMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetMessage * SOAP_FMAC4 soap_in___name2__GetMessage(struct soap *soap, const char *tag, struct __name2__GetMessage *a, const char *type)
{
	size_t soap_flag_tempuri__GetMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetMessage, sizeof(struct __name2__GetMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetMessage(soap, "tempuri:GetMessage", &a->tempuri__GetMessage, ""))
				{	soap_flag_tempuri__GetMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetMessage * SOAP_FMAC2 soap_instantiate___name2__GetMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetMessage *p;
	size_t k = sizeof(struct __name2__GetMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetMessage(struct soap *soap, const struct __name2__GetMessage *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetMessage(soap, tag ? tag : "-name2:GetMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetMessage * SOAP_FMAC4 soap_get___name2__GetMessage(struct soap *soap, struct __name2__GetMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__HasMessage(struct soap *soap, struct __name2__HasMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__HasMessage(struct soap *soap, const struct __name2__HasMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasMessage(soap, &a->tempuri__HasMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__HasMessage(struct soap *soap, const char *tag, int id, const struct __name2__HasMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasMessage(soap, "tempuri:HasMessage", -1, &a->tempuri__HasMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasMessage * SOAP_FMAC4 soap_in___name2__HasMessage(struct soap *soap, const char *tag, struct __name2__HasMessage *a, const char *type)
{
	size_t soap_flag_tempuri__HasMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__HasMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__HasMessage, sizeof(struct __name2__HasMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__HasMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasMessage(soap, "tempuri:HasMessage", &a->tempuri__HasMessage, ""))
				{	soap_flag_tempuri__HasMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__HasMessage * SOAP_FMAC2 soap_instantiate___name2__HasMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__HasMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__HasMessage *p;
	size_t k = sizeof(struct __name2__HasMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__HasMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__HasMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__HasMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__HasMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__HasMessage(struct soap *soap, const struct __name2__HasMessage *a, const char *tag, const char *type)
{
	if (soap_out___name2__HasMessage(soap, tag ? tag : "-name2:HasMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__HasMessage * SOAP_FMAC4 soap_get___name2__HasMessage(struct soap *soap, struct __name2__HasMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__HasMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__IsSamplePlateTrayIn(struct soap *soap, struct __name2__IsSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__IsSamplePlateTrayIn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__IsSamplePlateTrayIn(struct soap *soap, const struct __name2__IsSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__IsSamplePlateTrayIn(soap, &a->tempuri__IsSamplePlateTrayIn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__IsSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const struct __name2__IsSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__IsSamplePlateTrayIn(soap, "tempuri:IsSamplePlateTrayIn", -1, &a->tempuri__IsSamplePlateTrayIn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__IsSamplePlateTrayIn * SOAP_FMAC4 soap_in___name2__IsSamplePlateTrayIn(struct soap *soap, const char *tag, struct __name2__IsSamplePlateTrayIn *a, const char *type)
{
	size_t soap_flag_tempuri__IsSamplePlateTrayIn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__IsSamplePlateTrayIn*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__IsSamplePlateTrayIn, sizeof(struct __name2__IsSamplePlateTrayIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__IsSamplePlateTrayIn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__IsSamplePlateTrayIn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__IsSamplePlateTrayIn(soap, "tempuri:IsSamplePlateTrayIn", &a->tempuri__IsSamplePlateTrayIn, ""))
				{	soap_flag_tempuri__IsSamplePlateTrayIn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name2__IsSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__IsSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__IsSamplePlateTrayIn *p;
	size_t k = sizeof(struct __name2__IsSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__IsSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__IsSamplePlateTrayIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__IsSamplePlateTrayIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__IsSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__IsSamplePlateTrayIn(struct soap *soap, const struct __name2__IsSamplePlateTrayIn *a, const char *tag, const char *type)
{
	if (soap_out___name2__IsSamplePlateTrayIn(soap, tag ? tag : "-name2:IsSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__IsSamplePlateTrayIn * SOAP_FMAC4 soap_get___name2__IsSamplePlateTrayIn(struct soap *soap, struct __name2__IsSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__IsSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__IsChipDocked(struct soap *soap, struct __name2__IsChipDocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__IsChipDocked = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__IsChipDocked(struct soap *soap, const struct __name2__IsChipDocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__IsChipDocked(soap, &a->tempuri__IsChipDocked);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__IsChipDocked(struct soap *soap, const char *tag, int id, const struct __name2__IsChipDocked *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__IsChipDocked(soap, "tempuri:IsChipDocked", -1, &a->tempuri__IsChipDocked, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__IsChipDocked * SOAP_FMAC4 soap_in___name2__IsChipDocked(struct soap *soap, const char *tag, struct __name2__IsChipDocked *a, const char *type)
{
	size_t soap_flag_tempuri__IsChipDocked = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__IsChipDocked*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__IsChipDocked, sizeof(struct __name2__IsChipDocked), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__IsChipDocked(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__IsChipDocked && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__IsChipDocked(soap, "tempuri:IsChipDocked", &a->tempuri__IsChipDocked, ""))
				{	soap_flag_tempuri__IsChipDocked--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__IsChipDocked * SOAP_FMAC2 soap_instantiate___name2__IsChipDocked(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__IsChipDocked(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__IsChipDocked *p;
	size_t k = sizeof(struct __name2__IsChipDocked);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__IsChipDocked, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__IsChipDocked);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__IsChipDocked, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__IsChipDocked location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__IsChipDocked(struct soap *soap, const struct __name2__IsChipDocked *a, const char *tag, const char *type)
{
	if (soap_out___name2__IsChipDocked(soap, tag ? tag : "-name2:IsChipDocked", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__IsChipDocked * SOAP_FMAC4 soap_get___name2__IsChipDocked(struct soap *soap, struct __name2__IsChipDocked *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__IsChipDocked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetOperationMode(struct soap *soap, struct __name2__GetOperationMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetOperationMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetOperationMode(struct soap *soap, const struct __name2__GetOperationMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetOperationMode(soap, &a->tempuri__GetOperationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetOperationMode(struct soap *soap, const char *tag, int id, const struct __name2__GetOperationMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetOperationMode(soap, "tempuri:GetOperationMode", -1, &a->tempuri__GetOperationMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetOperationMode * SOAP_FMAC4 soap_in___name2__GetOperationMode(struct soap *soap, const char *tag, struct __name2__GetOperationMode *a, const char *type)
{
	size_t soap_flag_tempuri__GetOperationMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetOperationMode*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetOperationMode, sizeof(struct __name2__GetOperationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetOperationMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetOperationMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetOperationMode(soap, "tempuri:GetOperationMode", &a->tempuri__GetOperationMode, ""))
				{	soap_flag_tempuri__GetOperationMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetOperationMode * SOAP_FMAC2 soap_instantiate___name2__GetOperationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetOperationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetOperationMode *p;
	size_t k = sizeof(struct __name2__GetOperationMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetOperationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetOperationMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetOperationMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetOperationMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetOperationMode(struct soap *soap, const struct __name2__GetOperationMode *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetOperationMode(soap, tag ? tag : "-name2:GetOperationMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetOperationMode * SOAP_FMAC4 soap_get___name2__GetOperationMode(struct soap *soap, struct __name2__GetOperationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetOperationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__RunMaintenanceProcedure(struct soap *soap, struct __name2__RunMaintenanceProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__RunMaintenanceProcedure = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__RunMaintenanceProcedure(struct soap *soap, const struct __name2__RunMaintenanceProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__RunMaintenanceProcedure(soap, &a->tempuri__RunMaintenanceProcedure);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__RunMaintenanceProcedure(struct soap *soap, const char *tag, int id, const struct __name2__RunMaintenanceProcedure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__RunMaintenanceProcedure(soap, "tempuri:RunMaintenanceProcedure", -1, &a->tempuri__RunMaintenanceProcedure, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__RunMaintenanceProcedure * SOAP_FMAC4 soap_in___name2__RunMaintenanceProcedure(struct soap *soap, const char *tag, struct __name2__RunMaintenanceProcedure *a, const char *type)
{
	size_t soap_flag_tempuri__RunMaintenanceProcedure = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__RunMaintenanceProcedure*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__RunMaintenanceProcedure, sizeof(struct __name2__RunMaintenanceProcedure), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__RunMaintenanceProcedure(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__RunMaintenanceProcedure && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__RunMaintenanceProcedure(soap, "tempuri:RunMaintenanceProcedure", &a->tempuri__RunMaintenanceProcedure, ""))
				{	soap_flag_tempuri__RunMaintenanceProcedure--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate___name2__RunMaintenanceProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__RunMaintenanceProcedure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__RunMaintenanceProcedure *p;
	size_t k = sizeof(struct __name2__RunMaintenanceProcedure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__RunMaintenanceProcedure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__RunMaintenanceProcedure);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__RunMaintenanceProcedure, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__RunMaintenanceProcedure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__RunMaintenanceProcedure(struct soap *soap, const struct __name2__RunMaintenanceProcedure *a, const char *tag, const char *type)
{
	if (soap_out___name2__RunMaintenanceProcedure(soap, tag ? tag : "-name2:RunMaintenanceProcedure", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__RunMaintenanceProcedure * SOAP_FMAC4 soap_get___name2__RunMaintenanceProcedure(struct soap *soap, struct __name2__RunMaintenanceProcedure *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__RunMaintenanceProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, struct __name2__GetNamesOfMaintenanceProcedures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMaintenanceProcedures = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, const struct __name2__GetNamesOfMaintenanceProcedures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, &a->tempuri__GetNamesOfMaintenanceProcedures);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, int id, const struct __name2__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, "tempuri:GetNamesOfMaintenanceProcedures", -1, &a->tempuri__GetNamesOfMaintenanceProcedures, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_in___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, struct __name2__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMaintenanceProcedures = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNamesOfMaintenanceProcedures*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures, sizeof(struct __name2__GetNamesOfMaintenanceProcedures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNamesOfMaintenanceProcedures(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMaintenanceProcedures && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, "tempuri:GetNamesOfMaintenanceProcedures", &a->tempuri__GetNamesOfMaintenanceProcedures, ""))
				{	soap_flag_tempuri__GetNamesOfMaintenanceProcedures--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNamesOfMaintenanceProcedures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNamesOfMaintenanceProcedures *p;
	size_t k = sizeof(struct __name2__GetNamesOfMaintenanceProcedures);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNamesOfMaintenanceProcedures);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNamesOfMaintenanceProcedures, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNamesOfMaintenanceProcedures location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, const struct __name2__GetNamesOfMaintenanceProcedures *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNamesOfMaintenanceProcedures(soap, tag ? tag : "-name2:GetNamesOfMaintenanceProcedures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_get___name2__GetNamesOfMaintenanceProcedures(struct soap *soap, struct __name2__GetNamesOfMaintenanceProcedures *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNamesOfMaintenanceProcedures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetStandbyAfterFinish(struct soap *soap, struct __name2__GetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetStandbyAfterFinish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetStandbyAfterFinish(struct soap *soap, const struct __name2__GetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetStandbyAfterFinish(soap, &a->tempuri__GetStandbyAfterFinish);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const struct __name2__GetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetStandbyAfterFinish(soap, "tempuri:GetStandbyAfterFinish", -1, &a->tempuri__GetStandbyAfterFinish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetStandbyAfterFinish * SOAP_FMAC4 soap_in___name2__GetStandbyAfterFinish(struct soap *soap, const char *tag, struct __name2__GetStandbyAfterFinish *a, const char *type)
{
	size_t soap_flag_tempuri__GetStandbyAfterFinish = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetStandbyAfterFinish*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetStandbyAfterFinish, sizeof(struct __name2__GetStandbyAfterFinish), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetStandbyAfterFinish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetStandbyAfterFinish && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetStandbyAfterFinish(soap, "tempuri:GetStandbyAfterFinish", &a->tempuri__GetStandbyAfterFinish, ""))
				{	soap_flag_tempuri__GetStandbyAfterFinish--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name2__GetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetStandbyAfterFinish *p;
	size_t k = sizeof(struct __name2__GetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetStandbyAfterFinish);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetStandbyAfterFinish, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetStandbyAfterFinish(struct soap *soap, const struct __name2__GetStandbyAfterFinish *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetStandbyAfterFinish(soap, tag ? tag : "-name2:GetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetStandbyAfterFinish * SOAP_FMAC4 soap_get___name2__GetStandbyAfterFinish(struct soap *soap, struct __name2__GetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__SetStandbyAfterFinish(struct soap *soap, struct __name2__SetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetStandbyAfterFinish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__SetStandbyAfterFinish(struct soap *soap, const struct __name2__SetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetStandbyAfterFinish(soap, &a->tempuri__SetStandbyAfterFinish);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__SetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const struct __name2__SetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetStandbyAfterFinish(soap, "tempuri:SetStandbyAfterFinish", -1, &a->tempuri__SetStandbyAfterFinish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SetStandbyAfterFinish * SOAP_FMAC4 soap_in___name2__SetStandbyAfterFinish(struct soap *soap, const char *tag, struct __name2__SetStandbyAfterFinish *a, const char *type)
{
	size_t soap_flag_tempuri__SetStandbyAfterFinish = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__SetStandbyAfterFinish*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__SetStandbyAfterFinish, sizeof(struct __name2__SetStandbyAfterFinish), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__SetStandbyAfterFinish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetStandbyAfterFinish && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetStandbyAfterFinish(soap, "tempuri:SetStandbyAfterFinish", &a->tempuri__SetStandbyAfterFinish, ""))
				{	soap_flag_tempuri__SetStandbyAfterFinish--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name2__SetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__SetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__SetStandbyAfterFinish *p;
	size_t k = sizeof(struct __name2__SetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__SetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__SetStandbyAfterFinish);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__SetStandbyAfterFinish, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__SetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__SetStandbyAfterFinish(struct soap *soap, const struct __name2__SetStandbyAfterFinish *a, const char *tag, const char *type)
{
	if (soap_out___name2__SetStandbyAfterFinish(soap, tag ? tag : "-name2:SetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SetStandbyAfterFinish * SOAP_FMAC4 soap_get___name2__SetStandbyAfterFinish(struct soap *soap, struct __name2__SetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__SetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__LeaveStandby(struct soap *soap, struct __name2__LeaveStandby *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LeaveStandby = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__LeaveStandby(struct soap *soap, const struct __name2__LeaveStandby *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LeaveStandby(soap, &a->tempuri__LeaveStandby);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__LeaveStandby(struct soap *soap, const char *tag, int id, const struct __name2__LeaveStandby *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LeaveStandby(soap, "tempuri:LeaveStandby", -1, &a->tempuri__LeaveStandby, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__LeaveStandby * SOAP_FMAC4 soap_in___name2__LeaveStandby(struct soap *soap, const char *tag, struct __name2__LeaveStandby *a, const char *type)
{
	size_t soap_flag_tempuri__LeaveStandby = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__LeaveStandby*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__LeaveStandby, sizeof(struct __name2__LeaveStandby), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__LeaveStandby(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LeaveStandby && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LeaveStandby(soap, "tempuri:LeaveStandby", &a->tempuri__LeaveStandby, ""))
				{	soap_flag_tempuri__LeaveStandby--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__LeaveStandby * SOAP_FMAC2 soap_instantiate___name2__LeaveStandby(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__LeaveStandby(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__LeaveStandby *p;
	size_t k = sizeof(struct __name2__LeaveStandby);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__LeaveStandby, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__LeaveStandby);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__LeaveStandby, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__LeaveStandby location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__LeaveStandby(struct soap *soap, const struct __name2__LeaveStandby *a, const char *tag, const char *type)
{
	if (soap_out___name2__LeaveStandby(soap, tag ? tag : "-name2:LeaveStandby", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__LeaveStandby * SOAP_FMAC4 soap_get___name2__LeaveStandby(struct soap *soap, struct __name2__LeaveStandby *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__LeaveStandby(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__AbortScript(struct soap *soap, struct __name2__AbortScript *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AbortScript = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__AbortScript(struct soap *soap, const struct __name2__AbortScript *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AbortScript(soap, &a->tempuri__AbortScript);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__AbortScript(struct soap *soap, const char *tag, int id, const struct __name2__AbortScript *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AbortScript(soap, "tempuri:AbortScript", -1, &a->tempuri__AbortScript, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__AbortScript * SOAP_FMAC4 soap_in___name2__AbortScript(struct soap *soap, const char *tag, struct __name2__AbortScript *a, const char *type)
{
	size_t soap_flag_tempuri__AbortScript = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__AbortScript*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__AbortScript, sizeof(struct __name2__AbortScript), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__AbortScript(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AbortScript && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AbortScript(soap, "tempuri:AbortScript", &a->tempuri__AbortScript, ""))
				{	soap_flag_tempuri__AbortScript--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__AbortScript * SOAP_FMAC2 soap_instantiate___name2__AbortScript(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__AbortScript(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__AbortScript *p;
	size_t k = sizeof(struct __name2__AbortScript);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__AbortScript, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__AbortScript);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__AbortScript, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__AbortScript location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__AbortScript(struct soap *soap, const struct __name2__AbortScript *a, const char *tag, const char *type)
{
	if (soap_out___name2__AbortScript(soap, tag ? tag : "-name2:AbortScript", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__AbortScript * SOAP_FMAC4 soap_get___name2__AbortScript(struct soap *soap, struct __name2__AbortScript *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__AbortScript(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__ResetRunset(struct soap *soap, struct __name2__ResetRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ResetRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__ResetRunset(struct soap *soap, const struct __name2__ResetRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ResetRunset(soap, &a->tempuri__ResetRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__ResetRunset(struct soap *soap, const char *tag, int id, const struct __name2__ResetRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ResetRunset(soap, "tempuri:ResetRunset", -1, &a->tempuri__ResetRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__ResetRunset * SOAP_FMAC4 soap_in___name2__ResetRunset(struct soap *soap, const char *tag, struct __name2__ResetRunset *a, const char *type)
{
	size_t soap_flag_tempuri__ResetRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__ResetRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__ResetRunset, sizeof(struct __name2__ResetRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__ResetRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ResetRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ResetRunset(soap, "tempuri:ResetRunset", &a->tempuri__ResetRunset, ""))
				{	soap_flag_tempuri__ResetRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__ResetRunset * SOAP_FMAC2 soap_instantiate___name2__ResetRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__ResetRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__ResetRunset *p;
	size_t k = sizeof(struct __name2__ResetRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__ResetRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__ResetRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__ResetRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__ResetRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__ResetRunset(struct soap *soap, const struct __name2__ResetRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__ResetRunset(soap, tag ? tag : "-name2:ResetRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__ResetRunset * SOAP_FMAC4 soap_get___name2__ResetRunset(struct soap *soap, struct __name2__ResetRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__ResetRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__ResumeRunset(struct soap *soap, struct __name2__ResumeRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ResumeRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__ResumeRunset(struct soap *soap, const struct __name2__ResumeRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ResumeRunset(soap, &a->tempuri__ResumeRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__ResumeRunset(struct soap *soap, const char *tag, int id, const struct __name2__ResumeRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ResumeRunset(soap, "tempuri:ResumeRunset", -1, &a->tempuri__ResumeRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__ResumeRunset * SOAP_FMAC4 soap_in___name2__ResumeRunset(struct soap *soap, const char *tag, struct __name2__ResumeRunset *a, const char *type)
{
	size_t soap_flag_tempuri__ResumeRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__ResumeRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__ResumeRunset, sizeof(struct __name2__ResumeRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__ResumeRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ResumeRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ResumeRunset(soap, "tempuri:ResumeRunset", &a->tempuri__ResumeRunset, ""))
				{	soap_flag_tempuri__ResumeRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__ResumeRunset * SOAP_FMAC2 soap_instantiate___name2__ResumeRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__ResumeRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__ResumeRunset *p;
	size_t k = sizeof(struct __name2__ResumeRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__ResumeRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__ResumeRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__ResumeRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__ResumeRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__ResumeRunset(struct soap *soap, const struct __name2__ResumeRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__ResumeRunset(soap, tag ? tag : "-name2:ResumeRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__ResumeRunset * SOAP_FMAC4 soap_get___name2__ResumeRunset(struct soap *soap, struct __name2__ResumeRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__ResumeRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__PauseRunsetAfter(struct soap *soap, struct __name2__PauseRunsetAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__PauseRunsetAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__PauseRunsetAfter(struct soap *soap, const struct __name2__PauseRunsetAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__PauseRunsetAfter(soap, &a->tempuri__PauseRunsetAfter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__PauseRunsetAfter(struct soap *soap, const char *tag, int id, const struct __name2__PauseRunsetAfter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__PauseRunsetAfter(soap, "tempuri:PauseRunsetAfter", -1, &a->tempuri__PauseRunsetAfter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__PauseRunsetAfter * SOAP_FMAC4 soap_in___name2__PauseRunsetAfter(struct soap *soap, const char *tag, struct __name2__PauseRunsetAfter *a, const char *type)
{
	size_t soap_flag_tempuri__PauseRunsetAfter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__PauseRunsetAfter*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__PauseRunsetAfter, sizeof(struct __name2__PauseRunsetAfter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__PauseRunsetAfter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__PauseRunsetAfter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__PauseRunsetAfter(soap, "tempuri:PauseRunsetAfter", &a->tempuri__PauseRunsetAfter, ""))
				{	soap_flag_tempuri__PauseRunsetAfter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate___name2__PauseRunsetAfter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__PauseRunsetAfter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__PauseRunsetAfter *p;
	size_t k = sizeof(struct __name2__PauseRunsetAfter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__PauseRunsetAfter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__PauseRunsetAfter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__PauseRunsetAfter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__PauseRunsetAfter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__PauseRunsetAfter(struct soap *soap, const struct __name2__PauseRunsetAfter *a, const char *tag, const char *type)
{
	if (soap_out___name2__PauseRunsetAfter(soap, tag ? tag : "-name2:PauseRunsetAfter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__PauseRunsetAfter * SOAP_FMAC4 soap_get___name2__PauseRunsetAfter(struct soap *soap, struct __name2__PauseRunsetAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__PauseRunsetAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__StartSelectedRunsetFrom(struct soap *soap, struct __name2__StartSelectedRunsetFrom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__StartSelectedRunsetFrom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__StartSelectedRunsetFrom(struct soap *soap, const struct __name2__StartSelectedRunsetFrom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__StartSelectedRunsetFrom(soap, &a->tempuri__StartSelectedRunsetFrom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__StartSelectedRunsetFrom(struct soap *soap, const char *tag, int id, const struct __name2__StartSelectedRunsetFrom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__StartSelectedRunsetFrom(soap, "tempuri:StartSelectedRunsetFrom", -1, &a->tempuri__StartSelectedRunsetFrom, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__StartSelectedRunsetFrom * SOAP_FMAC4 soap_in___name2__StartSelectedRunsetFrom(struct soap *soap, const char *tag, struct __name2__StartSelectedRunsetFrom *a, const char *type)
{
	size_t soap_flag_tempuri__StartSelectedRunsetFrom = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__StartSelectedRunsetFrom*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__StartSelectedRunsetFrom, sizeof(struct __name2__StartSelectedRunsetFrom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__StartSelectedRunsetFrom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__StartSelectedRunsetFrom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__StartSelectedRunsetFrom(soap, "tempuri:StartSelectedRunsetFrom", &a->tempuri__StartSelectedRunsetFrom, ""))
				{	soap_flag_tempuri__StartSelectedRunsetFrom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate___name2__StartSelectedRunsetFrom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__StartSelectedRunsetFrom(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__StartSelectedRunsetFrom *p;
	size_t k = sizeof(struct __name2__StartSelectedRunsetFrom);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__StartSelectedRunsetFrom, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__StartSelectedRunsetFrom);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__StartSelectedRunsetFrom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__StartSelectedRunsetFrom location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__StartSelectedRunsetFrom(struct soap *soap, const struct __name2__StartSelectedRunsetFrom *a, const char *tag, const char *type)
{
	if (soap_out___name2__StartSelectedRunsetFrom(soap, tag ? tag : "-name2:StartSelectedRunsetFrom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__StartSelectedRunsetFrom * SOAP_FMAC4 soap_get___name2__StartSelectedRunsetFrom(struct soap *soap, struct __name2__StartSelectedRunsetFrom *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__StartSelectedRunsetFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__StartSelectedRunset(struct soap *soap, struct __name2__StartSelectedRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__StartSelectedRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__StartSelectedRunset(struct soap *soap, const struct __name2__StartSelectedRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__StartSelectedRunset(soap, &a->tempuri__StartSelectedRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__StartSelectedRunset(struct soap *soap, const char *tag, int id, const struct __name2__StartSelectedRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__StartSelectedRunset(soap, "tempuri:StartSelectedRunset", -1, &a->tempuri__StartSelectedRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__StartSelectedRunset * SOAP_FMAC4 soap_in___name2__StartSelectedRunset(struct soap *soap, const char *tag, struct __name2__StartSelectedRunset *a, const char *type)
{
	size_t soap_flag_tempuri__StartSelectedRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__StartSelectedRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__StartSelectedRunset, sizeof(struct __name2__StartSelectedRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__StartSelectedRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__StartSelectedRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__StartSelectedRunset(soap, "tempuri:StartSelectedRunset", &a->tempuri__StartSelectedRunset, ""))
				{	soap_flag_tempuri__StartSelectedRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__StartSelectedRunset * SOAP_FMAC2 soap_instantiate___name2__StartSelectedRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__StartSelectedRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__StartSelectedRunset *p;
	size_t k = sizeof(struct __name2__StartSelectedRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__StartSelectedRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__StartSelectedRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__StartSelectedRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__StartSelectedRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__StartSelectedRunset(struct soap *soap, const struct __name2__StartSelectedRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__StartSelectedRunset(soap, tag ? tag : "-name2:StartSelectedRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__StartSelectedRunset * SOAP_FMAC4 soap_get___name2__StartSelectedRunset(struct soap *soap, struct __name2__StartSelectedRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__StartSelectedRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__MoveSamplePlateTrayIn(struct soap *soap, struct __name2__MoveSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__MoveSamplePlateTrayIn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__MoveSamplePlateTrayIn(struct soap *soap, const struct __name2__MoveSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, &a->tempuri__MoveSamplePlateTrayIn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const struct __name2__MoveSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, "tempuri:MoveSamplePlateTrayIn", -1, &a->tempuri__MoveSamplePlateTrayIn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_in___name2__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, struct __name2__MoveSamplePlateTrayIn *a, const char *type)
{
	size_t soap_flag_tempuri__MoveSamplePlateTrayIn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__MoveSamplePlateTrayIn*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__MoveSamplePlateTrayIn, sizeof(struct __name2__MoveSamplePlateTrayIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__MoveSamplePlateTrayIn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__MoveSamplePlateTrayIn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, "tempuri:MoveSamplePlateTrayIn", &a->tempuri__MoveSamplePlateTrayIn, ""))
				{	soap_flag_tempuri__MoveSamplePlateTrayIn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name2__MoveSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__MoveSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__MoveSamplePlateTrayIn *p;
	size_t k = sizeof(struct __name2__MoveSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__MoveSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__MoveSamplePlateTrayIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__MoveSamplePlateTrayIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__MoveSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__MoveSamplePlateTrayIn(struct soap *soap, const struct __name2__MoveSamplePlateTrayIn *a, const char *tag, const char *type)
{
	if (soap_out___name2__MoveSamplePlateTrayIn(soap, tag ? tag : "-name2:MoveSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_get___name2__MoveSamplePlateTrayIn(struct soap *soap, struct __name2__MoveSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__MoveSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__MoveSamplePlateTrayOut(struct soap *soap, struct __name2__MoveSamplePlateTrayOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__MoveSamplePlateTrayOut = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__MoveSamplePlateTrayOut(struct soap *soap, const struct __name2__MoveSamplePlateTrayOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, &a->tempuri__MoveSamplePlateTrayOut);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, int id, const struct __name2__MoveSamplePlateTrayOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, "tempuri:MoveSamplePlateTrayOut", -1, &a->tempuri__MoveSamplePlateTrayOut, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_in___name2__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, struct __name2__MoveSamplePlateTrayOut *a, const char *type)
{
	size_t soap_flag_tempuri__MoveSamplePlateTrayOut = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__MoveSamplePlateTrayOut*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__MoveSamplePlateTrayOut, sizeof(struct __name2__MoveSamplePlateTrayOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__MoveSamplePlateTrayOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__MoveSamplePlateTrayOut && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, "tempuri:MoveSamplePlateTrayOut", &a->tempuri__MoveSamplePlateTrayOut, ""))
				{	soap_flag_tempuri__MoveSamplePlateTrayOut--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate___name2__MoveSamplePlateTrayOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__MoveSamplePlateTrayOut(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__MoveSamplePlateTrayOut *p;
	size_t k = sizeof(struct __name2__MoveSamplePlateTrayOut);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__MoveSamplePlateTrayOut, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__MoveSamplePlateTrayOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__MoveSamplePlateTrayOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__MoveSamplePlateTrayOut location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__MoveSamplePlateTrayOut(struct soap *soap, const struct __name2__MoveSamplePlateTrayOut *a, const char *tag, const char *type)
{
	if (soap_out___name2__MoveSamplePlateTrayOut(soap, tag ? tag : "-name2:MoveSamplePlateTrayOut", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_get___name2__MoveSamplePlateTrayOut(struct soap *soap, struct __name2__MoveSamplePlateTrayOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__MoveSamplePlateTrayOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetCurrentSamplePlateId(struct soap *soap, struct __name2__GetCurrentSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetCurrentSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetCurrentSamplePlateId(struct soap *soap, const struct __name2__GetCurrentSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetCurrentSamplePlateId(soap, &a->tempuri__GetCurrentSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetCurrentSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name2__GetCurrentSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetCurrentSamplePlateId(soap, "tempuri:GetCurrentSamplePlateId", -1, &a->tempuri__GetCurrentSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetCurrentSamplePlateId * SOAP_FMAC4 soap_in___name2__GetCurrentSamplePlateId(struct soap *soap, const char *tag, struct __name2__GetCurrentSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__GetCurrentSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetCurrentSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetCurrentSamplePlateId, sizeof(struct __name2__GetCurrentSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetCurrentSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetCurrentSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetCurrentSamplePlateId(soap, "tempuri:GetCurrentSamplePlateId", &a->tempuri__GetCurrentSamplePlateId, ""))
				{	soap_flag_tempuri__GetCurrentSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__GetCurrentSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetCurrentSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetCurrentSamplePlateId *p;
	size_t k = sizeof(struct __name2__GetCurrentSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetCurrentSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetCurrentSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetCurrentSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetCurrentSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetCurrentSamplePlateId(struct soap *soap, const struct __name2__GetCurrentSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetCurrentSamplePlateId(soap, tag ? tag : "-name2:GetCurrentSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetCurrentSamplePlateId * SOAP_FMAC4 soap_get___name2__GetCurrentSamplePlateId(struct soap *soap, struct __name2__GetCurrentSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetCurrentSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetSamplePlateId(struct soap *soap, struct __name2__GetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetSamplePlateId(struct soap *soap, const struct __name2__GetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetSamplePlateId(soap, &a->tempuri__GetSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name2__GetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetSamplePlateId(soap, "tempuri:GetSamplePlateId", -1, &a->tempuri__GetSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetSamplePlateId * SOAP_FMAC4 soap_in___name2__GetSamplePlateId(struct soap *soap, const char *tag, struct __name2__GetSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__GetSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetSamplePlateId, sizeof(struct __name2__GetSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetSamplePlateId(soap, "tempuri:GetSamplePlateId", &a->tempuri__GetSamplePlateId, ""))
				{	soap_flag_tempuri__GetSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__GetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetSamplePlateId *p;
	size_t k = sizeof(struct __name2__GetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetSamplePlateId(struct soap *soap, const struct __name2__GetSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetSamplePlateId(soap, tag ? tag : "-name2:GetSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetSamplePlateId * SOAP_FMAC4 soap_get___name2__GetSamplePlateId(struct soap *soap, struct __name2__GetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__SetSamplePlateId(struct soap *soap, struct __name2__SetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__SetSamplePlateId(struct soap *soap, const struct __name2__SetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetSamplePlateId(soap, &a->tempuri__SetSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__SetSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name2__SetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetSamplePlateId(soap, "tempuri:SetSamplePlateId", -1, &a->tempuri__SetSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SetSamplePlateId * SOAP_FMAC4 soap_in___name2__SetSamplePlateId(struct soap *soap, const char *tag, struct __name2__SetSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__SetSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__SetSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__SetSamplePlateId, sizeof(struct __name2__SetSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__SetSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetSamplePlateId(soap, "tempuri:SetSamplePlateId", &a->tempuri__SetSamplePlateId, ""))
				{	soap_flag_tempuri__SetSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__SetSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__SetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__SetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__SetSamplePlateId *p;
	size_t k = sizeof(struct __name2__SetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__SetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__SetSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__SetSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__SetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__SetSamplePlateId(struct soap *soap, const struct __name2__SetSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name2__SetSamplePlateId(soap, tag ? tag : "-name2:SetSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SetSamplePlateId * SOAP_FMAC4 soap_get___name2__SetSamplePlateId(struct soap *soap, struct __name2__SetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__SetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__CreateRunset(struct soap *soap, struct __name2__CreateRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__CreateRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__CreateRunset(struct soap *soap, const struct __name2__CreateRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__CreateRunset(soap, &a->tempuri__CreateRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__CreateRunset(struct soap *soap, const char *tag, int id, const struct __name2__CreateRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__CreateRunset(soap, "tempuri:CreateRunset", -1, &a->tempuri__CreateRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__CreateRunset * SOAP_FMAC4 soap_in___name2__CreateRunset(struct soap *soap, const char *tag, struct __name2__CreateRunset *a, const char *type)
{
	size_t soap_flag_tempuri__CreateRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__CreateRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__CreateRunset, sizeof(struct __name2__CreateRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__CreateRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__CreateRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__CreateRunset(soap, "tempuri:CreateRunset", &a->tempuri__CreateRunset, ""))
				{	soap_flag_tempuri__CreateRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__CreateRunset * SOAP_FMAC2 soap_instantiate___name2__CreateRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__CreateRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__CreateRunset *p;
	size_t k = sizeof(struct __name2__CreateRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__CreateRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__CreateRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__CreateRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__CreateRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__CreateRunset(struct soap *soap, const struct __name2__CreateRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__CreateRunset(soap, tag ? tag : "-name2:CreateRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__CreateRunset * SOAP_FMAC4 soap_get___name2__CreateRunset(struct soap *soap, struct __name2__CreateRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__CreateRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__SelectRunset(struct soap *soap, struct __name2__SelectRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SelectRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__SelectRunset(struct soap *soap, const struct __name2__SelectRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SelectRunset(soap, &a->tempuri__SelectRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__SelectRunset(struct soap *soap, const char *tag, int id, const struct __name2__SelectRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SelectRunset(soap, "tempuri:SelectRunset", -1, &a->tempuri__SelectRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SelectRunset * SOAP_FMAC4 soap_in___name2__SelectRunset(struct soap *soap, const char *tag, struct __name2__SelectRunset *a, const char *type)
{
	size_t soap_flag_tempuri__SelectRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__SelectRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__SelectRunset, sizeof(struct __name2__SelectRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__SelectRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SelectRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SelectRunset(soap, "tempuri:SelectRunset", &a->tempuri__SelectRunset, ""))
				{	soap_flag_tempuri__SelectRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__SelectRunset * SOAP_FMAC2 soap_instantiate___name2__SelectRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__SelectRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__SelectRunset *p;
	size_t k = sizeof(struct __name2__SelectRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__SelectRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__SelectRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__SelectRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__SelectRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__SelectRunset(struct soap *soap, const struct __name2__SelectRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__SelectRunset(soap, tag ? tag : "-name2:SelectRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SelectRunset * SOAP_FMAC4 soap_get___name2__SelectRunset(struct soap *soap, struct __name2__SelectRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__SelectRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__SelectMethod(struct soap *soap, struct __name2__SelectMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SelectMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__SelectMethod(struct soap *soap, const struct __name2__SelectMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SelectMethod(soap, &a->tempuri__SelectMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__SelectMethod(struct soap *soap, const char *tag, int id, const struct __name2__SelectMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SelectMethod(soap, "tempuri:SelectMethod", -1, &a->tempuri__SelectMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SelectMethod * SOAP_FMAC4 soap_in___name2__SelectMethod(struct soap *soap, const char *tag, struct __name2__SelectMethod *a, const char *type)
{
	size_t soap_flag_tempuri__SelectMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__SelectMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__SelectMethod, sizeof(struct __name2__SelectMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__SelectMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SelectMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SelectMethod(soap, "tempuri:SelectMethod", &a->tempuri__SelectMethod, ""))
				{	soap_flag_tempuri__SelectMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__SelectMethod * SOAP_FMAC2 soap_instantiate___name2__SelectMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__SelectMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__SelectMethod *p;
	size_t k = sizeof(struct __name2__SelectMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__SelectMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__SelectMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__SelectMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__SelectMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__SelectMethod(struct soap *soap, const struct __name2__SelectMethod *a, const char *tag, const char *type)
{
	if (soap_out___name2__SelectMethod(soap, tag ? tag : "-name2:SelectMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__SelectMethod * SOAP_FMAC4 soap_get___name2__SelectMethod(struct soap *soap, struct __name2__SelectMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__SelectMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetMethodNamesOfRunset(struct soap *soap, struct __name2__GetMethodNamesOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetMethodNamesOfRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetMethodNamesOfRunset(struct soap *soap, const struct __name2__GetMethodNamesOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetMethodNamesOfRunset(soap, &a->tempuri__GetMethodNamesOfRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetMethodNamesOfRunset(struct soap *soap, const char *tag, int id, const struct __name2__GetMethodNamesOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetMethodNamesOfRunset(soap, "tempuri:GetMethodNamesOfRunset", -1, &a->tempuri__GetMethodNamesOfRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetMethodNamesOfRunset * SOAP_FMAC4 soap_in___name2__GetMethodNamesOfRunset(struct soap *soap, const char *tag, struct __name2__GetMethodNamesOfRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetMethodNamesOfRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetMethodNamesOfRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetMethodNamesOfRunset, sizeof(struct __name2__GetMethodNamesOfRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetMethodNamesOfRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetMethodNamesOfRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetMethodNamesOfRunset(soap, "tempuri:GetMethodNamesOfRunset", &a->tempuri__GetMethodNamesOfRunset, ""))
				{	soap_flag_tempuri__GetMethodNamesOfRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate___name2__GetMethodNamesOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetMethodNamesOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetMethodNamesOfRunset *p;
	size_t k = sizeof(struct __name2__GetMethodNamesOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetMethodNamesOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetMethodNamesOfRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetMethodNamesOfRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetMethodNamesOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetMethodNamesOfRunset(struct soap *soap, const struct __name2__GetMethodNamesOfRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetMethodNamesOfRunset(soap, tag ? tag : "-name2:GetMethodNamesOfRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetMethodNamesOfRunset * SOAP_FMAC4 soap_get___name2__GetMethodNamesOfRunset(struct soap *soap, struct __name2__GetMethodNamesOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetMethodNamesOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypeOfRunset(struct soap *soap, struct __name2__GetAssayTypeOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypeOfRunset(struct soap *soap, const struct __name2__GetAssayTypeOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfRunset(soap, &a->tempuri__GetAssayTypeOfRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypeOfRunset(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypeOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfRunset(soap, "tempuri:GetAssayTypeOfRunset", -1, &a->tempuri__GetAssayTypeOfRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfRunset * SOAP_FMAC4 soap_in___name2__GetAssayTypeOfRunset(struct soap *soap, const char *tag, struct __name2__GetAssayTypeOfRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypeOfRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypeOfRunset, sizeof(struct __name2__GetAssayTypeOfRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypeOfRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfRunset(soap, "tempuri:GetAssayTypeOfRunset", &a->tempuri__GetAssayTypeOfRunset, ""))
				{	soap_flag_tempuri__GetAssayTypeOfRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypeOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypeOfRunset *p;
	size_t k = sizeof(struct __name2__GetAssayTypeOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypeOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypeOfRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypeOfRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypeOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypeOfRunset(struct soap *soap, const struct __name2__GetAssayTypeOfRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypeOfRunset(soap, tag ? tag : "-name2:GetAssayTypeOfRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfRunset * SOAP_FMAC4 soap_get___name2__GetAssayTypeOfRunset(struct soap *soap, struct __name2__GetAssayTypeOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypeOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, struct __name2__GetAssayTypeOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfCurrentRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, const struct __name2__GetAssayTypeOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, &a->tempuri__GetAssayTypeOfCurrentRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, "tempuri:GetAssayTypeOfCurrentRunset", -1, &a->tempuri__GetAssayTypeOfCurrentRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_in___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, struct __name2__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfCurrentRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypeOfCurrentRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset, sizeof(struct __name2__GetAssayTypeOfCurrentRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypeOfCurrentRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfCurrentRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, "tempuri:GetAssayTypeOfCurrentRunset", &a->tempuri__GetAssayTypeOfCurrentRunset, ""))
				{	soap_flag_tempuri__GetAssayTypeOfCurrentRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypeOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypeOfCurrentRunset *p;
	size_t k = sizeof(struct __name2__GetAssayTypeOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypeOfCurrentRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypeOfCurrentRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypeOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, const struct __name2__GetAssayTypeOfCurrentRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypeOfCurrentRunset(soap, tag ? tag : "-name2:GetAssayTypeOfCurrentRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_get___name2__GetAssayTypeOfCurrentRunset(struct soap *soap, struct __name2__GetAssayTypeOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypeOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNameOfCurrentRunset(struct soap *soap, struct __name2__GetNameOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNameOfCurrentRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNameOfCurrentRunset(struct soap *soap, const struct __name2__GetNameOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNameOfCurrentRunset(soap, &a->tempuri__GetNameOfCurrentRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNameOfCurrentRunset(struct soap *soap, const char *tag, int id, const struct __name2__GetNameOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentRunset(soap, "tempuri:GetNameOfCurrentRunset", -1, &a->tempuri__GetNameOfCurrentRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNameOfCurrentRunset * SOAP_FMAC4 soap_in___name2__GetNameOfCurrentRunset(struct soap *soap, const char *tag, struct __name2__GetNameOfCurrentRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetNameOfCurrentRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNameOfCurrentRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNameOfCurrentRunset, sizeof(struct __name2__GetNameOfCurrentRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNameOfCurrentRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNameOfCurrentRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNameOfCurrentRunset(soap, "tempuri:GetNameOfCurrentRunset", &a->tempuri__GetNameOfCurrentRunset, ""))
				{	soap_flag_tempuri__GetNameOfCurrentRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name2__GetNameOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNameOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNameOfCurrentRunset *p;
	size_t k = sizeof(struct __name2__GetNameOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNameOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNameOfCurrentRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNameOfCurrentRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNameOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNameOfCurrentRunset(struct soap *soap, const struct __name2__GetNameOfCurrentRunset *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNameOfCurrentRunset(soap, tag ? tag : "-name2:GetNameOfCurrentRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNameOfCurrentRunset * SOAP_FMAC4 soap_get___name2__GetNameOfCurrentRunset(struct soap *soap, struct __name2__GetNameOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNameOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypesOfAllRunsets(struct soap *soap, struct __name2__GetAssayTypesOfAllRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypesOfAllRunsets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypesOfAllRunsets(struct soap *soap, const struct __name2__GetAssayTypesOfAllRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, &a->tempuri__GetAssayTypesOfAllRunsets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypesOfAllRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, "tempuri:GetAssayTypesOfAllRunsets", -1, &a->tempuri__GetAssayTypesOfAllRunsets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_in___name2__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, struct __name2__GetAssayTypesOfAllRunsets *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypesOfAllRunsets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypesOfAllRunsets*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypesOfAllRunsets, sizeof(struct __name2__GetAssayTypesOfAllRunsets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypesOfAllRunsets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypesOfAllRunsets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, "tempuri:GetAssayTypesOfAllRunsets", &a->tempuri__GetAssayTypesOfAllRunsets, ""))
				{	soap_flag_tempuri__GetAssayTypesOfAllRunsets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypesOfAllRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypesOfAllRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypesOfAllRunsets *p;
	size_t k = sizeof(struct __name2__GetAssayTypesOfAllRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypesOfAllRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypesOfAllRunsets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypesOfAllRunsets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypesOfAllRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypesOfAllRunsets(struct soap *soap, const struct __name2__GetAssayTypesOfAllRunsets *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypesOfAllRunsets(soap, tag ? tag : "-name2:GetAssayTypesOfAllRunsets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_get___name2__GetAssayTypesOfAllRunsets(struct soap *soap, struct __name2__GetAssayTypesOfAllRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypesOfAllRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, struct __name2__GetNamesOfRunsetsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfRunsetsOfAssayType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, const struct __name2__GetNamesOfRunsetsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, &a->tempuri__GetNamesOfRunsetsOfAssayType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, int id, const struct __name2__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, "tempuri:GetNamesOfRunsetsOfAssayType", -1, &a->tempuri__GetNamesOfRunsetsOfAssayType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_in___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, struct __name2__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfRunsetsOfAssayType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNamesOfRunsetsOfAssayType*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType, sizeof(struct __name2__GetNamesOfRunsetsOfAssayType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNamesOfRunsetsOfAssayType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfRunsetsOfAssayType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, "tempuri:GetNamesOfRunsetsOfAssayType", &a->tempuri__GetNamesOfRunsetsOfAssayType, ""))
				{	soap_flag_tempuri__GetNamesOfRunsetsOfAssayType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNamesOfRunsetsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNamesOfRunsetsOfAssayType *p;
	size_t k = sizeof(struct __name2__GetNamesOfRunsetsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNamesOfRunsetsOfAssayType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNamesOfRunsetsOfAssayType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNamesOfRunsetsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, const struct __name2__GetNamesOfRunsetsOfAssayType *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNamesOfRunsetsOfAssayType(soap, tag ? tag : "-name2:GetNamesOfRunsetsOfAssayType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_get___name2__GetNamesOfRunsetsOfAssayType(struct soap *soap, struct __name2__GetNamesOfRunsetsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNamesOfRunsetsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNamesOfRunsets(struct soap *soap, struct __name2__GetNamesOfRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfRunsets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNamesOfRunsets(struct soap *soap, const struct __name2__GetNamesOfRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfRunsets(soap, &a->tempuri__GetNamesOfRunsets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNamesOfRunsets(struct soap *soap, const char *tag, int id, const struct __name2__GetNamesOfRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsets(soap, "tempuri:GetNamesOfRunsets", -1, &a->tempuri__GetNamesOfRunsets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfRunsets * SOAP_FMAC4 soap_in___name2__GetNamesOfRunsets(struct soap *soap, const char *tag, struct __name2__GetNamesOfRunsets *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfRunsets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNamesOfRunsets*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNamesOfRunsets, sizeof(struct __name2__GetNamesOfRunsets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNamesOfRunsets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfRunsets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfRunsets(soap, "tempuri:GetNamesOfRunsets", &a->tempuri__GetNamesOfRunsets, ""))
				{	soap_flag_tempuri__GetNamesOfRunsets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNamesOfRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNamesOfRunsets *p;
	size_t k = sizeof(struct __name2__GetNamesOfRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNamesOfRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNamesOfRunsets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNamesOfRunsets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNamesOfRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNamesOfRunsets(struct soap *soap, const struct __name2__GetNamesOfRunsets *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNamesOfRunsets(soap, tag ? tag : "-name2:GetNamesOfRunsets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfRunsets * SOAP_FMAC4 soap_get___name2__GetNamesOfRunsets(struct soap *soap, struct __name2__GetNamesOfRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNamesOfRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypeOfMethod(struct soap *soap, struct __name2__GetAssayTypeOfMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypeOfMethod(struct soap *soap, const struct __name2__GetAssayTypeOfMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfMethod(soap, &a->tempuri__GetAssayTypeOfMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypeOfMethod(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypeOfMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfMethod(soap, "tempuri:GetAssayTypeOfMethod", -1, &a->tempuri__GetAssayTypeOfMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfMethod * SOAP_FMAC4 soap_in___name2__GetAssayTypeOfMethod(struct soap *soap, const char *tag, struct __name2__GetAssayTypeOfMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypeOfMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypeOfMethod, sizeof(struct __name2__GetAssayTypeOfMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypeOfMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfMethod(soap, "tempuri:GetAssayTypeOfMethod", &a->tempuri__GetAssayTypeOfMethod, ""))
				{	soap_flag_tempuri__GetAssayTypeOfMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypeOfMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypeOfMethod *p;
	size_t k = sizeof(struct __name2__GetAssayTypeOfMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypeOfMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypeOfMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypeOfMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypeOfMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypeOfMethod(struct soap *soap, const struct __name2__GetAssayTypeOfMethod *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypeOfMethod(soap, tag ? tag : "-name2:GetAssayTypeOfMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfMethod * SOAP_FMAC4 soap_get___name2__GetAssayTypeOfMethod(struct soap *soap, struct __name2__GetAssayTypeOfMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypeOfMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, struct __name2__GetAssayTypeOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfCurrentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, const struct __name2__GetAssayTypeOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, &a->tempuri__GetAssayTypeOfCurrentMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, "tempuri:GetAssayTypeOfCurrentMethod", -1, &a->tempuri__GetAssayTypeOfCurrentMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_in___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, struct __name2__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfCurrentMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypeOfCurrentMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod, sizeof(struct __name2__GetAssayTypeOfCurrentMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypeOfCurrentMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfCurrentMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, "tempuri:GetAssayTypeOfCurrentMethod", &a->tempuri__GetAssayTypeOfCurrentMethod, ""))
				{	soap_flag_tempuri__GetAssayTypeOfCurrentMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypeOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypeOfCurrentMethod *p;
	size_t k = sizeof(struct __name2__GetAssayTypeOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypeOfCurrentMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypeOfCurrentMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypeOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, const struct __name2__GetAssayTypeOfCurrentMethod *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypeOfCurrentMethod(soap, tag ? tag : "-name2:GetAssayTypeOfCurrentMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_get___name2__GetAssayTypeOfCurrentMethod(struct soap *soap, struct __name2__GetAssayTypeOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypeOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNameOfCurrentMethod(struct soap *soap, struct __name2__GetNameOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNameOfCurrentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNameOfCurrentMethod(struct soap *soap, const struct __name2__GetNameOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNameOfCurrentMethod(soap, &a->tempuri__GetNameOfCurrentMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNameOfCurrentMethod(struct soap *soap, const char *tag, int id, const struct __name2__GetNameOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentMethod(soap, "tempuri:GetNameOfCurrentMethod", -1, &a->tempuri__GetNameOfCurrentMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNameOfCurrentMethod * SOAP_FMAC4 soap_in___name2__GetNameOfCurrentMethod(struct soap *soap, const char *tag, struct __name2__GetNameOfCurrentMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetNameOfCurrentMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNameOfCurrentMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNameOfCurrentMethod, sizeof(struct __name2__GetNameOfCurrentMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNameOfCurrentMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNameOfCurrentMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNameOfCurrentMethod(soap, "tempuri:GetNameOfCurrentMethod", &a->tempuri__GetNameOfCurrentMethod, ""))
				{	soap_flag_tempuri__GetNameOfCurrentMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name2__GetNameOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNameOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNameOfCurrentMethod *p;
	size_t k = sizeof(struct __name2__GetNameOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNameOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNameOfCurrentMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNameOfCurrentMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNameOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNameOfCurrentMethod(struct soap *soap, const struct __name2__GetNameOfCurrentMethod *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNameOfCurrentMethod(soap, tag ? tag : "-name2:GetNameOfCurrentMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNameOfCurrentMethod * SOAP_FMAC4 soap_get___name2__GetNameOfCurrentMethod(struct soap *soap, struct __name2__GetNameOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNameOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetAssayTypesOfAllMethods(struct soap *soap, struct __name2__GetAssayTypesOfAllMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypesOfAllMethods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetAssayTypesOfAllMethods(struct soap *soap, const struct __name2__GetAssayTypesOfAllMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, &a->tempuri__GetAssayTypesOfAllMethods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, int id, const struct __name2__GetAssayTypesOfAllMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, "tempuri:GetAssayTypesOfAllMethods", -1, &a->tempuri__GetAssayTypesOfAllMethods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_in___name2__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, struct __name2__GetAssayTypesOfAllMethods *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypesOfAllMethods = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetAssayTypesOfAllMethods*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetAssayTypesOfAllMethods, sizeof(struct __name2__GetAssayTypesOfAllMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetAssayTypesOfAllMethods(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypesOfAllMethods && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, "tempuri:GetAssayTypesOfAllMethods", &a->tempuri__GetAssayTypesOfAllMethods, ""))
				{	soap_flag_tempuri__GetAssayTypesOfAllMethods--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypesOfAllMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetAssayTypesOfAllMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetAssayTypesOfAllMethods *p;
	size_t k = sizeof(struct __name2__GetAssayTypesOfAllMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetAssayTypesOfAllMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetAssayTypesOfAllMethods);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetAssayTypesOfAllMethods, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetAssayTypesOfAllMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetAssayTypesOfAllMethods(struct soap *soap, const struct __name2__GetAssayTypesOfAllMethods *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetAssayTypesOfAllMethods(soap, tag ? tag : "-name2:GetAssayTypesOfAllMethods", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_get___name2__GetAssayTypesOfAllMethods(struct soap *soap, struct __name2__GetAssayTypesOfAllMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetAssayTypesOfAllMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, struct __name2__GetNamesOfMethodsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMethodsOfAssayType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, const struct __name2__GetNamesOfMethodsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, &a->tempuri__GetNamesOfMethodsOfAssayType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, int id, const struct __name2__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, "tempuri:GetNamesOfMethodsOfAssayType", -1, &a->tempuri__GetNamesOfMethodsOfAssayType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_in___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, struct __name2__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMethodsOfAssayType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNamesOfMethodsOfAssayType*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType, sizeof(struct __name2__GetNamesOfMethodsOfAssayType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNamesOfMethodsOfAssayType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMethodsOfAssayType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, "tempuri:GetNamesOfMethodsOfAssayType", &a->tempuri__GetNamesOfMethodsOfAssayType, ""))
				{	soap_flag_tempuri__GetNamesOfMethodsOfAssayType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNamesOfMethodsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNamesOfMethodsOfAssayType *p;
	size_t k = sizeof(struct __name2__GetNamesOfMethodsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNamesOfMethodsOfAssayType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNamesOfMethodsOfAssayType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNamesOfMethodsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, const struct __name2__GetNamesOfMethodsOfAssayType *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNamesOfMethodsOfAssayType(soap, tag ? tag : "-name2:GetNamesOfMethodsOfAssayType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_get___name2__GetNamesOfMethodsOfAssayType(struct soap *soap, struct __name2__GetNamesOfMethodsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNamesOfMethodsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name2__GetNamesOfMethods(struct soap *soap, struct __name2__GetNamesOfMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMethods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name2__GetNamesOfMethods(struct soap *soap, const struct __name2__GetNamesOfMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMethods(soap, &a->tempuri__GetNamesOfMethods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name2__GetNamesOfMethods(struct soap *soap, const char *tag, int id, const struct __name2__GetNamesOfMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMethods(soap, "tempuri:GetNamesOfMethods", -1, &a->tempuri__GetNamesOfMethods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMethods * SOAP_FMAC4 soap_in___name2__GetNamesOfMethods(struct soap *soap, const char *tag, struct __name2__GetNamesOfMethods *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMethods = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name2__GetNamesOfMethods*)soap_id_enter(soap, "", a, SOAP_TYPE___name2__GetNamesOfMethods, sizeof(struct __name2__GetNamesOfMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name2__GetNamesOfMethods(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMethods && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMethods(soap, "tempuri:GetNamesOfMethods", &a->tempuri__GetNamesOfMethods, ""))
				{	soap_flag_tempuri__GetNamesOfMethods--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name2__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name2__GetNamesOfMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name2__GetNamesOfMethods *p;
	size_t k = sizeof(struct __name2__GetNamesOfMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name2__GetNamesOfMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name2__GetNamesOfMethods);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name2__GetNamesOfMethods, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name2__GetNamesOfMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name2__GetNamesOfMethods(struct soap *soap, const struct __name2__GetNamesOfMethods *a, const char *tag, const char *type)
{
	if (soap_out___name2__GetNamesOfMethods(soap, tag ? tag : "-name2:GetNamesOfMethods", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name2__GetNamesOfMethods * SOAP_FMAC4 soap_get___name2__GetNamesOfMethods(struct soap *soap, struct __name2__GetNamesOfMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in___name2__GetNamesOfMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetWarnings(struct soap *soap, struct __name__GetWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetWarnings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetWarnings(struct soap *soap, const struct __name__GetWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetWarnings(soap, &a->tempuri__GetWarnings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetWarnings(struct soap *soap, const char *tag, int id, const struct __name__GetWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetWarnings(soap, "tempuri:GetWarnings", -1, &a->tempuri__GetWarnings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetWarnings * SOAP_FMAC4 soap_in___name__GetWarnings(struct soap *soap, const char *tag, struct __name__GetWarnings *a, const char *type)
{
	size_t soap_flag_tempuri__GetWarnings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetWarnings*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetWarnings, sizeof(struct __name__GetWarnings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetWarnings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetWarnings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetWarnings(soap, "tempuri:GetWarnings", &a->tempuri__GetWarnings, ""))
				{	soap_flag_tempuri__GetWarnings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetWarnings * SOAP_FMAC2 soap_instantiate___name__GetWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetWarnings *p;
	size_t k = sizeof(struct __name__GetWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetWarnings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetWarnings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetWarnings(struct soap *soap, const struct __name__GetWarnings *a, const char *tag, const char *type)
{
	if (soap_out___name__GetWarnings(soap, tag ? tag : "-name:GetWarnings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetWarnings * SOAP_FMAC4 soap_get___name__GetWarnings(struct soap *soap, struct __name__GetWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__HasWarnings(struct soap *soap, struct __name__HasWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasWarnings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__HasWarnings(struct soap *soap, const struct __name__HasWarnings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasWarnings(soap, &a->tempuri__HasWarnings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__HasWarnings(struct soap *soap, const char *tag, int id, const struct __name__HasWarnings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasWarnings(soap, "tempuri:HasWarnings", -1, &a->tempuri__HasWarnings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasWarnings * SOAP_FMAC4 soap_in___name__HasWarnings(struct soap *soap, const char *tag, struct __name__HasWarnings *a, const char *type)
{
	size_t soap_flag_tempuri__HasWarnings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__HasWarnings*)soap_id_enter(soap, "", a, SOAP_TYPE___name__HasWarnings, sizeof(struct __name__HasWarnings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__HasWarnings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasWarnings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasWarnings(soap, "tempuri:HasWarnings", &a->tempuri__HasWarnings, ""))
				{	soap_flag_tempuri__HasWarnings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__HasWarnings * SOAP_FMAC2 soap_instantiate___name__HasWarnings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__HasWarnings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__HasWarnings *p;
	size_t k = sizeof(struct __name__HasWarnings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__HasWarnings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__HasWarnings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__HasWarnings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__HasWarnings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__HasWarnings(struct soap *soap, const struct __name__HasWarnings *a, const char *tag, const char *type)
{
	if (soap_out___name__HasWarnings(soap, tag ? tag : "-name:HasWarnings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasWarnings * SOAP_FMAC4 soap_get___name__HasWarnings(struct soap *soap, struct __name__HasWarnings *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__HasWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetErrors(struct soap *soap, struct __name__GetErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetErrors = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetErrors(struct soap *soap, const struct __name__GetErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetErrors(soap, &a->tempuri__GetErrors);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetErrors(struct soap *soap, const char *tag, int id, const struct __name__GetErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetErrors(soap, "tempuri:GetErrors", -1, &a->tempuri__GetErrors, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetErrors * SOAP_FMAC4 soap_in___name__GetErrors(struct soap *soap, const char *tag, struct __name__GetErrors *a, const char *type)
{
	size_t soap_flag_tempuri__GetErrors = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetErrors*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetErrors, sizeof(struct __name__GetErrors), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetErrors(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetErrors && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetErrors(soap, "tempuri:GetErrors", &a->tempuri__GetErrors, ""))
				{	soap_flag_tempuri__GetErrors--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetErrors * SOAP_FMAC2 soap_instantiate___name__GetErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetErrors *p;
	size_t k = sizeof(struct __name__GetErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetErrors);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetErrors, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetErrors(struct soap *soap, const struct __name__GetErrors *a, const char *tag, const char *type)
{
	if (soap_out___name__GetErrors(soap, tag ? tag : "-name:GetErrors", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetErrors * SOAP_FMAC4 soap_get___name__GetErrors(struct soap *soap, struct __name__GetErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__HasErrors(struct soap *soap, struct __name__HasErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasErrors = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__HasErrors(struct soap *soap, const struct __name__HasErrors *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasErrors(soap, &a->tempuri__HasErrors);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__HasErrors(struct soap *soap, const char *tag, int id, const struct __name__HasErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasErrors(soap, "tempuri:HasErrors", -1, &a->tempuri__HasErrors, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasErrors * SOAP_FMAC4 soap_in___name__HasErrors(struct soap *soap, const char *tag, struct __name__HasErrors *a, const char *type)
{
	size_t soap_flag_tempuri__HasErrors = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__HasErrors*)soap_id_enter(soap, "", a, SOAP_TYPE___name__HasErrors, sizeof(struct __name__HasErrors), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__HasErrors(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasErrors && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasErrors(soap, "tempuri:HasErrors", &a->tempuri__HasErrors, ""))
				{	soap_flag_tempuri__HasErrors--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__HasErrors * SOAP_FMAC2 soap_instantiate___name__HasErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__HasErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__HasErrors *p;
	size_t k = sizeof(struct __name__HasErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__HasErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__HasErrors);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__HasErrors, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__HasErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__HasErrors(struct soap *soap, const struct __name__HasErrors *a, const char *tag, const char *type)
{
	if (soap_out___name__HasErrors(soap, tag ? tag : "-name:HasErrors", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasErrors * SOAP_FMAC4 soap_get___name__HasErrors(struct soap *soap, struct __name__HasErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__HasErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetMessage(struct soap *soap, struct __name__GetMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetMessage(struct soap *soap, const struct __name__GetMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetMessage(soap, &a->tempuri__GetMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetMessage(struct soap *soap, const char *tag, int id, const struct __name__GetMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetMessage(soap, "tempuri:GetMessage", -1, &a->tempuri__GetMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetMessage * SOAP_FMAC4 soap_in___name__GetMessage(struct soap *soap, const char *tag, struct __name__GetMessage *a, const char *type)
{
	size_t soap_flag_tempuri__GetMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetMessage, sizeof(struct __name__GetMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetMessage(soap, "tempuri:GetMessage", &a->tempuri__GetMessage, ""))
				{	soap_flag_tempuri__GetMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetMessage * SOAP_FMAC2 soap_instantiate___name__GetMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetMessage *p;
	size_t k = sizeof(struct __name__GetMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetMessage(struct soap *soap, const struct __name__GetMessage *a, const char *tag, const char *type)
{
	if (soap_out___name__GetMessage(soap, tag ? tag : "-name:GetMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetMessage * SOAP_FMAC4 soap_get___name__GetMessage(struct soap *soap, struct __name__GetMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__HasMessage(struct soap *soap, struct __name__HasMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__HasMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__HasMessage(struct soap *soap, const struct __name__HasMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__HasMessage(soap, &a->tempuri__HasMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__HasMessage(struct soap *soap, const char *tag, int id, const struct __name__HasMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__HasMessage(soap, "tempuri:HasMessage", -1, &a->tempuri__HasMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasMessage * SOAP_FMAC4 soap_in___name__HasMessage(struct soap *soap, const char *tag, struct __name__HasMessage *a, const char *type)
{
	size_t soap_flag_tempuri__HasMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__HasMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___name__HasMessage, sizeof(struct __name__HasMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__HasMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__HasMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__HasMessage(soap, "tempuri:HasMessage", &a->tempuri__HasMessage, ""))
				{	soap_flag_tempuri__HasMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__HasMessage * SOAP_FMAC2 soap_instantiate___name__HasMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__HasMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__HasMessage *p;
	size_t k = sizeof(struct __name__HasMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__HasMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__HasMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__HasMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__HasMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__HasMessage(struct soap *soap, const struct __name__HasMessage *a, const char *tag, const char *type)
{
	if (soap_out___name__HasMessage(soap, tag ? tag : "-name:HasMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__HasMessage * SOAP_FMAC4 soap_get___name__HasMessage(struct soap *soap, struct __name__HasMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__HasMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__IsSamplePlateTrayIn(struct soap *soap, struct __name__IsSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__IsSamplePlateTrayIn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__IsSamplePlateTrayIn(struct soap *soap, const struct __name__IsSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__IsSamplePlateTrayIn(soap, &a->tempuri__IsSamplePlateTrayIn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__IsSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const struct __name__IsSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__IsSamplePlateTrayIn(soap, "tempuri:IsSamplePlateTrayIn", -1, &a->tempuri__IsSamplePlateTrayIn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__IsSamplePlateTrayIn * SOAP_FMAC4 soap_in___name__IsSamplePlateTrayIn(struct soap *soap, const char *tag, struct __name__IsSamplePlateTrayIn *a, const char *type)
{
	size_t soap_flag_tempuri__IsSamplePlateTrayIn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__IsSamplePlateTrayIn*)soap_id_enter(soap, "", a, SOAP_TYPE___name__IsSamplePlateTrayIn, sizeof(struct __name__IsSamplePlateTrayIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__IsSamplePlateTrayIn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__IsSamplePlateTrayIn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__IsSamplePlateTrayIn(soap, "tempuri:IsSamplePlateTrayIn", &a->tempuri__IsSamplePlateTrayIn, ""))
				{	soap_flag_tempuri__IsSamplePlateTrayIn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name__IsSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__IsSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__IsSamplePlateTrayIn *p;
	size_t k = sizeof(struct __name__IsSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__IsSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__IsSamplePlateTrayIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__IsSamplePlateTrayIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__IsSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__IsSamplePlateTrayIn(struct soap *soap, const struct __name__IsSamplePlateTrayIn *a, const char *tag, const char *type)
{
	if (soap_out___name__IsSamplePlateTrayIn(soap, tag ? tag : "-name:IsSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__IsSamplePlateTrayIn * SOAP_FMAC4 soap_get___name__IsSamplePlateTrayIn(struct soap *soap, struct __name__IsSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__IsSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__IsChipDocked(struct soap *soap, struct __name__IsChipDocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__IsChipDocked = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__IsChipDocked(struct soap *soap, const struct __name__IsChipDocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__IsChipDocked(soap, &a->tempuri__IsChipDocked);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__IsChipDocked(struct soap *soap, const char *tag, int id, const struct __name__IsChipDocked *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__IsChipDocked(soap, "tempuri:IsChipDocked", -1, &a->tempuri__IsChipDocked, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__IsChipDocked * SOAP_FMAC4 soap_in___name__IsChipDocked(struct soap *soap, const char *tag, struct __name__IsChipDocked *a, const char *type)
{
	size_t soap_flag_tempuri__IsChipDocked = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__IsChipDocked*)soap_id_enter(soap, "", a, SOAP_TYPE___name__IsChipDocked, sizeof(struct __name__IsChipDocked), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__IsChipDocked(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__IsChipDocked && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__IsChipDocked(soap, "tempuri:IsChipDocked", &a->tempuri__IsChipDocked, ""))
				{	soap_flag_tempuri__IsChipDocked--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__IsChipDocked * SOAP_FMAC2 soap_instantiate___name__IsChipDocked(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__IsChipDocked(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__IsChipDocked *p;
	size_t k = sizeof(struct __name__IsChipDocked);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__IsChipDocked, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__IsChipDocked);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__IsChipDocked, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__IsChipDocked location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__IsChipDocked(struct soap *soap, const struct __name__IsChipDocked *a, const char *tag, const char *type)
{
	if (soap_out___name__IsChipDocked(soap, tag ? tag : "-name:IsChipDocked", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__IsChipDocked * SOAP_FMAC4 soap_get___name__IsChipDocked(struct soap *soap, struct __name__IsChipDocked *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__IsChipDocked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetOperationMode(struct soap *soap, struct __name__GetOperationMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetOperationMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetOperationMode(struct soap *soap, const struct __name__GetOperationMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetOperationMode(soap, &a->tempuri__GetOperationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetOperationMode(struct soap *soap, const char *tag, int id, const struct __name__GetOperationMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetOperationMode(soap, "tempuri:GetOperationMode", -1, &a->tempuri__GetOperationMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetOperationMode * SOAP_FMAC4 soap_in___name__GetOperationMode(struct soap *soap, const char *tag, struct __name__GetOperationMode *a, const char *type)
{
	size_t soap_flag_tempuri__GetOperationMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetOperationMode*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetOperationMode, sizeof(struct __name__GetOperationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetOperationMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetOperationMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetOperationMode(soap, "tempuri:GetOperationMode", &a->tempuri__GetOperationMode, ""))
				{	soap_flag_tempuri__GetOperationMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetOperationMode * SOAP_FMAC2 soap_instantiate___name__GetOperationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetOperationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetOperationMode *p;
	size_t k = sizeof(struct __name__GetOperationMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetOperationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetOperationMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetOperationMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetOperationMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetOperationMode(struct soap *soap, const struct __name__GetOperationMode *a, const char *tag, const char *type)
{
	if (soap_out___name__GetOperationMode(soap, tag ? tag : "-name:GetOperationMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetOperationMode * SOAP_FMAC4 soap_get___name__GetOperationMode(struct soap *soap, struct __name__GetOperationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetOperationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__RunMaintenanceProcedure(struct soap *soap, struct __name__RunMaintenanceProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__RunMaintenanceProcedure = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__RunMaintenanceProcedure(struct soap *soap, const struct __name__RunMaintenanceProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__RunMaintenanceProcedure(soap, &a->tempuri__RunMaintenanceProcedure);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__RunMaintenanceProcedure(struct soap *soap, const char *tag, int id, const struct __name__RunMaintenanceProcedure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__RunMaintenanceProcedure(soap, "tempuri:RunMaintenanceProcedure", -1, &a->tempuri__RunMaintenanceProcedure, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__RunMaintenanceProcedure * SOAP_FMAC4 soap_in___name__RunMaintenanceProcedure(struct soap *soap, const char *tag, struct __name__RunMaintenanceProcedure *a, const char *type)
{
	size_t soap_flag_tempuri__RunMaintenanceProcedure = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__RunMaintenanceProcedure*)soap_id_enter(soap, "", a, SOAP_TYPE___name__RunMaintenanceProcedure, sizeof(struct __name__RunMaintenanceProcedure), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__RunMaintenanceProcedure(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__RunMaintenanceProcedure && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__RunMaintenanceProcedure(soap, "tempuri:RunMaintenanceProcedure", &a->tempuri__RunMaintenanceProcedure, ""))
				{	soap_flag_tempuri__RunMaintenanceProcedure--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate___name__RunMaintenanceProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__RunMaintenanceProcedure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__RunMaintenanceProcedure *p;
	size_t k = sizeof(struct __name__RunMaintenanceProcedure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__RunMaintenanceProcedure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__RunMaintenanceProcedure);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__RunMaintenanceProcedure, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__RunMaintenanceProcedure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__RunMaintenanceProcedure(struct soap *soap, const struct __name__RunMaintenanceProcedure *a, const char *tag, const char *type)
{
	if (soap_out___name__RunMaintenanceProcedure(soap, tag ? tag : "-name:RunMaintenanceProcedure", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__RunMaintenanceProcedure * SOAP_FMAC4 soap_get___name__RunMaintenanceProcedure(struct soap *soap, struct __name__RunMaintenanceProcedure *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__RunMaintenanceProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNamesOfMaintenanceProcedures(struct soap *soap, struct __name__GetNamesOfMaintenanceProcedures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMaintenanceProcedures = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNamesOfMaintenanceProcedures(struct soap *soap, const struct __name__GetNamesOfMaintenanceProcedures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, &a->tempuri__GetNamesOfMaintenanceProcedures);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, int id, const struct __name__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, "tempuri:GetNamesOfMaintenanceProcedures", -1, &a->tempuri__GetNamesOfMaintenanceProcedures, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_in___name__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, struct __name__GetNamesOfMaintenanceProcedures *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMaintenanceProcedures = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNamesOfMaintenanceProcedures*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNamesOfMaintenanceProcedures, sizeof(struct __name__GetNamesOfMaintenanceProcedures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNamesOfMaintenanceProcedures(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMaintenanceProcedures && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, "tempuri:GetNamesOfMaintenanceProcedures", &a->tempuri__GetNamesOfMaintenanceProcedures, ""))
				{	soap_flag_tempuri__GetNamesOfMaintenanceProcedures--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMaintenanceProcedures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNamesOfMaintenanceProcedures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNamesOfMaintenanceProcedures *p;
	size_t k = sizeof(struct __name__GetNamesOfMaintenanceProcedures);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNamesOfMaintenanceProcedures, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNamesOfMaintenanceProcedures);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNamesOfMaintenanceProcedures, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNamesOfMaintenanceProcedures location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNamesOfMaintenanceProcedures(struct soap *soap, const struct __name__GetNamesOfMaintenanceProcedures *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNamesOfMaintenanceProcedures(soap, tag ? tag : "-name:GetNamesOfMaintenanceProcedures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMaintenanceProcedures * SOAP_FMAC4 soap_get___name__GetNamesOfMaintenanceProcedures(struct soap *soap, struct __name__GetNamesOfMaintenanceProcedures *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNamesOfMaintenanceProcedures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetStandbyAfterFinish(struct soap *soap, struct __name__GetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetStandbyAfterFinish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetStandbyAfterFinish(struct soap *soap, const struct __name__GetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetStandbyAfterFinish(soap, &a->tempuri__GetStandbyAfterFinish);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const struct __name__GetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetStandbyAfterFinish(soap, "tempuri:GetStandbyAfterFinish", -1, &a->tempuri__GetStandbyAfterFinish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetStandbyAfterFinish * SOAP_FMAC4 soap_in___name__GetStandbyAfterFinish(struct soap *soap, const char *tag, struct __name__GetStandbyAfterFinish *a, const char *type)
{
	size_t soap_flag_tempuri__GetStandbyAfterFinish = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetStandbyAfterFinish*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetStandbyAfterFinish, sizeof(struct __name__GetStandbyAfterFinish), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetStandbyAfterFinish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetStandbyAfterFinish && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetStandbyAfterFinish(soap, "tempuri:GetStandbyAfterFinish", &a->tempuri__GetStandbyAfterFinish, ""))
				{	soap_flag_tempuri__GetStandbyAfterFinish--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name__GetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetStandbyAfterFinish *p;
	size_t k = sizeof(struct __name__GetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetStandbyAfterFinish);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetStandbyAfterFinish, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetStandbyAfterFinish(struct soap *soap, const struct __name__GetStandbyAfterFinish *a, const char *tag, const char *type)
{
	if (soap_out___name__GetStandbyAfterFinish(soap, tag ? tag : "-name:GetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetStandbyAfterFinish * SOAP_FMAC4 soap_get___name__GetStandbyAfterFinish(struct soap *soap, struct __name__GetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__SetStandbyAfterFinish(struct soap *soap, struct __name__SetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetStandbyAfterFinish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__SetStandbyAfterFinish(struct soap *soap, const struct __name__SetStandbyAfterFinish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetStandbyAfterFinish(soap, &a->tempuri__SetStandbyAfterFinish);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__SetStandbyAfterFinish(struct soap *soap, const char *tag, int id, const struct __name__SetStandbyAfterFinish *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetStandbyAfterFinish(soap, "tempuri:SetStandbyAfterFinish", -1, &a->tempuri__SetStandbyAfterFinish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SetStandbyAfterFinish * SOAP_FMAC4 soap_in___name__SetStandbyAfterFinish(struct soap *soap, const char *tag, struct __name__SetStandbyAfterFinish *a, const char *type)
{
	size_t soap_flag_tempuri__SetStandbyAfterFinish = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__SetStandbyAfterFinish*)soap_id_enter(soap, "", a, SOAP_TYPE___name__SetStandbyAfterFinish, sizeof(struct __name__SetStandbyAfterFinish), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__SetStandbyAfterFinish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetStandbyAfterFinish && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetStandbyAfterFinish(soap, "tempuri:SetStandbyAfterFinish", &a->tempuri__SetStandbyAfterFinish, ""))
				{	soap_flag_tempuri__SetStandbyAfterFinish--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name__SetStandbyAfterFinish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__SetStandbyAfterFinish(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__SetStandbyAfterFinish *p;
	size_t k = sizeof(struct __name__SetStandbyAfterFinish);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__SetStandbyAfterFinish, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__SetStandbyAfterFinish);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__SetStandbyAfterFinish, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__SetStandbyAfterFinish location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__SetStandbyAfterFinish(struct soap *soap, const struct __name__SetStandbyAfterFinish *a, const char *tag, const char *type)
{
	if (soap_out___name__SetStandbyAfterFinish(soap, tag ? tag : "-name:SetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SetStandbyAfterFinish * SOAP_FMAC4 soap_get___name__SetStandbyAfterFinish(struct soap *soap, struct __name__SetStandbyAfterFinish *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__SetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__LeaveStandby(struct soap *soap, struct __name__LeaveStandby *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LeaveStandby = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__LeaveStandby(struct soap *soap, const struct __name__LeaveStandby *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LeaveStandby(soap, &a->tempuri__LeaveStandby);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__LeaveStandby(struct soap *soap, const char *tag, int id, const struct __name__LeaveStandby *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LeaveStandby(soap, "tempuri:LeaveStandby", -1, &a->tempuri__LeaveStandby, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__LeaveStandby * SOAP_FMAC4 soap_in___name__LeaveStandby(struct soap *soap, const char *tag, struct __name__LeaveStandby *a, const char *type)
{
	size_t soap_flag_tempuri__LeaveStandby = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__LeaveStandby*)soap_id_enter(soap, "", a, SOAP_TYPE___name__LeaveStandby, sizeof(struct __name__LeaveStandby), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__LeaveStandby(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LeaveStandby && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LeaveStandby(soap, "tempuri:LeaveStandby", &a->tempuri__LeaveStandby, ""))
				{	soap_flag_tempuri__LeaveStandby--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__LeaveStandby * SOAP_FMAC2 soap_instantiate___name__LeaveStandby(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__LeaveStandby(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__LeaveStandby *p;
	size_t k = sizeof(struct __name__LeaveStandby);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__LeaveStandby, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__LeaveStandby);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__LeaveStandby, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__LeaveStandby location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__LeaveStandby(struct soap *soap, const struct __name__LeaveStandby *a, const char *tag, const char *type)
{
	if (soap_out___name__LeaveStandby(soap, tag ? tag : "-name:LeaveStandby", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__LeaveStandby * SOAP_FMAC4 soap_get___name__LeaveStandby(struct soap *soap, struct __name__LeaveStandby *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__LeaveStandby(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__AbortScript(struct soap *soap, struct __name__AbortScript *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AbortScript = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__AbortScript(struct soap *soap, const struct __name__AbortScript *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AbortScript(soap, &a->tempuri__AbortScript);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__AbortScript(struct soap *soap, const char *tag, int id, const struct __name__AbortScript *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AbortScript(soap, "tempuri:AbortScript", -1, &a->tempuri__AbortScript, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__AbortScript * SOAP_FMAC4 soap_in___name__AbortScript(struct soap *soap, const char *tag, struct __name__AbortScript *a, const char *type)
{
	size_t soap_flag_tempuri__AbortScript = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__AbortScript*)soap_id_enter(soap, "", a, SOAP_TYPE___name__AbortScript, sizeof(struct __name__AbortScript), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__AbortScript(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AbortScript && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AbortScript(soap, "tempuri:AbortScript", &a->tempuri__AbortScript, ""))
				{	soap_flag_tempuri__AbortScript--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__AbortScript * SOAP_FMAC2 soap_instantiate___name__AbortScript(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__AbortScript(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__AbortScript *p;
	size_t k = sizeof(struct __name__AbortScript);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__AbortScript, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__AbortScript);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__AbortScript, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__AbortScript location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__AbortScript(struct soap *soap, const struct __name__AbortScript *a, const char *tag, const char *type)
{
	if (soap_out___name__AbortScript(soap, tag ? tag : "-name:AbortScript", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__AbortScript * SOAP_FMAC4 soap_get___name__AbortScript(struct soap *soap, struct __name__AbortScript *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__AbortScript(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__ResetRunset(struct soap *soap, struct __name__ResetRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ResetRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__ResetRunset(struct soap *soap, const struct __name__ResetRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ResetRunset(soap, &a->tempuri__ResetRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__ResetRunset(struct soap *soap, const char *tag, int id, const struct __name__ResetRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ResetRunset(soap, "tempuri:ResetRunset", -1, &a->tempuri__ResetRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__ResetRunset * SOAP_FMAC4 soap_in___name__ResetRunset(struct soap *soap, const char *tag, struct __name__ResetRunset *a, const char *type)
{
	size_t soap_flag_tempuri__ResetRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__ResetRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__ResetRunset, sizeof(struct __name__ResetRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__ResetRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ResetRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ResetRunset(soap, "tempuri:ResetRunset", &a->tempuri__ResetRunset, ""))
				{	soap_flag_tempuri__ResetRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__ResetRunset * SOAP_FMAC2 soap_instantiate___name__ResetRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__ResetRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__ResetRunset *p;
	size_t k = sizeof(struct __name__ResetRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__ResetRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__ResetRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__ResetRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__ResetRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__ResetRunset(struct soap *soap, const struct __name__ResetRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__ResetRunset(soap, tag ? tag : "-name:ResetRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__ResetRunset * SOAP_FMAC4 soap_get___name__ResetRunset(struct soap *soap, struct __name__ResetRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__ResetRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__ResumeRunset(struct soap *soap, struct __name__ResumeRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ResumeRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__ResumeRunset(struct soap *soap, const struct __name__ResumeRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ResumeRunset(soap, &a->tempuri__ResumeRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__ResumeRunset(struct soap *soap, const char *tag, int id, const struct __name__ResumeRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ResumeRunset(soap, "tempuri:ResumeRunset", -1, &a->tempuri__ResumeRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__ResumeRunset * SOAP_FMAC4 soap_in___name__ResumeRunset(struct soap *soap, const char *tag, struct __name__ResumeRunset *a, const char *type)
{
	size_t soap_flag_tempuri__ResumeRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__ResumeRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__ResumeRunset, sizeof(struct __name__ResumeRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__ResumeRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ResumeRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ResumeRunset(soap, "tempuri:ResumeRunset", &a->tempuri__ResumeRunset, ""))
				{	soap_flag_tempuri__ResumeRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__ResumeRunset * SOAP_FMAC2 soap_instantiate___name__ResumeRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__ResumeRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__ResumeRunset *p;
	size_t k = sizeof(struct __name__ResumeRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__ResumeRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__ResumeRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__ResumeRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__ResumeRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__ResumeRunset(struct soap *soap, const struct __name__ResumeRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__ResumeRunset(soap, tag ? tag : "-name:ResumeRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__ResumeRunset * SOAP_FMAC4 soap_get___name__ResumeRunset(struct soap *soap, struct __name__ResumeRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__ResumeRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__PauseRunsetAfter(struct soap *soap, struct __name__PauseRunsetAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__PauseRunsetAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__PauseRunsetAfter(struct soap *soap, const struct __name__PauseRunsetAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__PauseRunsetAfter(soap, &a->tempuri__PauseRunsetAfter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__PauseRunsetAfter(struct soap *soap, const char *tag, int id, const struct __name__PauseRunsetAfter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__PauseRunsetAfter(soap, "tempuri:PauseRunsetAfter", -1, &a->tempuri__PauseRunsetAfter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__PauseRunsetAfter * SOAP_FMAC4 soap_in___name__PauseRunsetAfter(struct soap *soap, const char *tag, struct __name__PauseRunsetAfter *a, const char *type)
{
	size_t soap_flag_tempuri__PauseRunsetAfter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__PauseRunsetAfter*)soap_id_enter(soap, "", a, SOAP_TYPE___name__PauseRunsetAfter, sizeof(struct __name__PauseRunsetAfter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__PauseRunsetAfter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__PauseRunsetAfter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__PauseRunsetAfter(soap, "tempuri:PauseRunsetAfter", &a->tempuri__PauseRunsetAfter, ""))
				{	soap_flag_tempuri__PauseRunsetAfter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate___name__PauseRunsetAfter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__PauseRunsetAfter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__PauseRunsetAfter *p;
	size_t k = sizeof(struct __name__PauseRunsetAfter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__PauseRunsetAfter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__PauseRunsetAfter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__PauseRunsetAfter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__PauseRunsetAfter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__PauseRunsetAfter(struct soap *soap, const struct __name__PauseRunsetAfter *a, const char *tag, const char *type)
{
	if (soap_out___name__PauseRunsetAfter(soap, tag ? tag : "-name:PauseRunsetAfter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__PauseRunsetAfter * SOAP_FMAC4 soap_get___name__PauseRunsetAfter(struct soap *soap, struct __name__PauseRunsetAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__PauseRunsetAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__StartSelectedRunsetFrom(struct soap *soap, struct __name__StartSelectedRunsetFrom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__StartSelectedRunsetFrom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__StartSelectedRunsetFrom(struct soap *soap, const struct __name__StartSelectedRunsetFrom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__StartSelectedRunsetFrom(soap, &a->tempuri__StartSelectedRunsetFrom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__StartSelectedRunsetFrom(struct soap *soap, const char *tag, int id, const struct __name__StartSelectedRunsetFrom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__StartSelectedRunsetFrom(soap, "tempuri:StartSelectedRunsetFrom", -1, &a->tempuri__StartSelectedRunsetFrom, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__StartSelectedRunsetFrom * SOAP_FMAC4 soap_in___name__StartSelectedRunsetFrom(struct soap *soap, const char *tag, struct __name__StartSelectedRunsetFrom *a, const char *type)
{
	size_t soap_flag_tempuri__StartSelectedRunsetFrom = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__StartSelectedRunsetFrom*)soap_id_enter(soap, "", a, SOAP_TYPE___name__StartSelectedRunsetFrom, sizeof(struct __name__StartSelectedRunsetFrom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__StartSelectedRunsetFrom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__StartSelectedRunsetFrom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__StartSelectedRunsetFrom(soap, "tempuri:StartSelectedRunsetFrom", &a->tempuri__StartSelectedRunsetFrom, ""))
				{	soap_flag_tempuri__StartSelectedRunsetFrom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate___name__StartSelectedRunsetFrom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__StartSelectedRunsetFrom(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__StartSelectedRunsetFrom *p;
	size_t k = sizeof(struct __name__StartSelectedRunsetFrom);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__StartSelectedRunsetFrom, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__StartSelectedRunsetFrom);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__StartSelectedRunsetFrom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__StartSelectedRunsetFrom location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__StartSelectedRunsetFrom(struct soap *soap, const struct __name__StartSelectedRunsetFrom *a, const char *tag, const char *type)
{
	if (soap_out___name__StartSelectedRunsetFrom(soap, tag ? tag : "-name:StartSelectedRunsetFrom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__StartSelectedRunsetFrom * SOAP_FMAC4 soap_get___name__StartSelectedRunsetFrom(struct soap *soap, struct __name__StartSelectedRunsetFrom *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__StartSelectedRunsetFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__StartSelectedRunset(struct soap *soap, struct __name__StartSelectedRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__StartSelectedRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__StartSelectedRunset(struct soap *soap, const struct __name__StartSelectedRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__StartSelectedRunset(soap, &a->tempuri__StartSelectedRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__StartSelectedRunset(struct soap *soap, const char *tag, int id, const struct __name__StartSelectedRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__StartSelectedRunset(soap, "tempuri:StartSelectedRunset", -1, &a->tempuri__StartSelectedRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__StartSelectedRunset * SOAP_FMAC4 soap_in___name__StartSelectedRunset(struct soap *soap, const char *tag, struct __name__StartSelectedRunset *a, const char *type)
{
	size_t soap_flag_tempuri__StartSelectedRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__StartSelectedRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__StartSelectedRunset, sizeof(struct __name__StartSelectedRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__StartSelectedRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__StartSelectedRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__StartSelectedRunset(soap, "tempuri:StartSelectedRunset", &a->tempuri__StartSelectedRunset, ""))
				{	soap_flag_tempuri__StartSelectedRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__StartSelectedRunset * SOAP_FMAC2 soap_instantiate___name__StartSelectedRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__StartSelectedRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__StartSelectedRunset *p;
	size_t k = sizeof(struct __name__StartSelectedRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__StartSelectedRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__StartSelectedRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__StartSelectedRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__StartSelectedRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__StartSelectedRunset(struct soap *soap, const struct __name__StartSelectedRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__StartSelectedRunset(soap, tag ? tag : "-name:StartSelectedRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__StartSelectedRunset * SOAP_FMAC4 soap_get___name__StartSelectedRunset(struct soap *soap, struct __name__StartSelectedRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__StartSelectedRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__MoveSamplePlateTrayIn(struct soap *soap, struct __name__MoveSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__MoveSamplePlateTrayIn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__MoveSamplePlateTrayIn(struct soap *soap, const struct __name__MoveSamplePlateTrayIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, &a->tempuri__MoveSamplePlateTrayIn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, int id, const struct __name__MoveSamplePlateTrayIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, "tempuri:MoveSamplePlateTrayIn", -1, &a->tempuri__MoveSamplePlateTrayIn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_in___name__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, struct __name__MoveSamplePlateTrayIn *a, const char *type)
{
	size_t soap_flag_tempuri__MoveSamplePlateTrayIn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__MoveSamplePlateTrayIn*)soap_id_enter(soap, "", a, SOAP_TYPE___name__MoveSamplePlateTrayIn, sizeof(struct __name__MoveSamplePlateTrayIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__MoveSamplePlateTrayIn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__MoveSamplePlateTrayIn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, "tempuri:MoveSamplePlateTrayIn", &a->tempuri__MoveSamplePlateTrayIn, ""))
				{	soap_flag_tempuri__MoveSamplePlateTrayIn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name__MoveSamplePlateTrayIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__MoveSamplePlateTrayIn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__MoveSamplePlateTrayIn *p;
	size_t k = sizeof(struct __name__MoveSamplePlateTrayIn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__MoveSamplePlateTrayIn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__MoveSamplePlateTrayIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__MoveSamplePlateTrayIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__MoveSamplePlateTrayIn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__MoveSamplePlateTrayIn(struct soap *soap, const struct __name__MoveSamplePlateTrayIn *a, const char *tag, const char *type)
{
	if (soap_out___name__MoveSamplePlateTrayIn(soap, tag ? tag : "-name:MoveSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__MoveSamplePlateTrayIn * SOAP_FMAC4 soap_get___name__MoveSamplePlateTrayIn(struct soap *soap, struct __name__MoveSamplePlateTrayIn *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__MoveSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__MoveSamplePlateTrayOut(struct soap *soap, struct __name__MoveSamplePlateTrayOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__MoveSamplePlateTrayOut = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__MoveSamplePlateTrayOut(struct soap *soap, const struct __name__MoveSamplePlateTrayOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, &a->tempuri__MoveSamplePlateTrayOut);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, int id, const struct __name__MoveSamplePlateTrayOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, "tempuri:MoveSamplePlateTrayOut", -1, &a->tempuri__MoveSamplePlateTrayOut, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_in___name__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, struct __name__MoveSamplePlateTrayOut *a, const char *type)
{
	size_t soap_flag_tempuri__MoveSamplePlateTrayOut = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__MoveSamplePlateTrayOut*)soap_id_enter(soap, "", a, SOAP_TYPE___name__MoveSamplePlateTrayOut, sizeof(struct __name__MoveSamplePlateTrayOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__MoveSamplePlateTrayOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__MoveSamplePlateTrayOut && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, "tempuri:MoveSamplePlateTrayOut", &a->tempuri__MoveSamplePlateTrayOut, ""))
				{	soap_flag_tempuri__MoveSamplePlateTrayOut--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate___name__MoveSamplePlateTrayOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__MoveSamplePlateTrayOut(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__MoveSamplePlateTrayOut *p;
	size_t k = sizeof(struct __name__MoveSamplePlateTrayOut);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__MoveSamplePlateTrayOut, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__MoveSamplePlateTrayOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__MoveSamplePlateTrayOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__MoveSamplePlateTrayOut location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__MoveSamplePlateTrayOut(struct soap *soap, const struct __name__MoveSamplePlateTrayOut *a, const char *tag, const char *type)
{
	if (soap_out___name__MoveSamplePlateTrayOut(soap, tag ? tag : "-name:MoveSamplePlateTrayOut", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__MoveSamplePlateTrayOut * SOAP_FMAC4 soap_get___name__MoveSamplePlateTrayOut(struct soap *soap, struct __name__MoveSamplePlateTrayOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__MoveSamplePlateTrayOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetCurrentSamplePlateId(struct soap *soap, struct __name__GetCurrentSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetCurrentSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetCurrentSamplePlateId(struct soap *soap, const struct __name__GetCurrentSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetCurrentSamplePlateId(soap, &a->tempuri__GetCurrentSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetCurrentSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name__GetCurrentSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetCurrentSamplePlateId(soap, "tempuri:GetCurrentSamplePlateId", -1, &a->tempuri__GetCurrentSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetCurrentSamplePlateId * SOAP_FMAC4 soap_in___name__GetCurrentSamplePlateId(struct soap *soap, const char *tag, struct __name__GetCurrentSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__GetCurrentSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetCurrentSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetCurrentSamplePlateId, sizeof(struct __name__GetCurrentSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetCurrentSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetCurrentSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetCurrentSamplePlateId(soap, "tempuri:GetCurrentSamplePlateId", &a->tempuri__GetCurrentSamplePlateId, ""))
				{	soap_flag_tempuri__GetCurrentSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate___name__GetCurrentSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetCurrentSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetCurrentSamplePlateId *p;
	size_t k = sizeof(struct __name__GetCurrentSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetCurrentSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetCurrentSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetCurrentSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetCurrentSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetCurrentSamplePlateId(struct soap *soap, const struct __name__GetCurrentSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name__GetCurrentSamplePlateId(soap, tag ? tag : "-name:GetCurrentSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetCurrentSamplePlateId * SOAP_FMAC4 soap_get___name__GetCurrentSamplePlateId(struct soap *soap, struct __name__GetCurrentSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetCurrentSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetSamplePlateId(struct soap *soap, struct __name__GetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetSamplePlateId(struct soap *soap, const struct __name__GetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetSamplePlateId(soap, &a->tempuri__GetSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name__GetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetSamplePlateId(soap, "tempuri:GetSamplePlateId", -1, &a->tempuri__GetSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetSamplePlateId * SOAP_FMAC4 soap_in___name__GetSamplePlateId(struct soap *soap, const char *tag, struct __name__GetSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__GetSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetSamplePlateId, sizeof(struct __name__GetSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetSamplePlateId(soap, "tempuri:GetSamplePlateId", &a->tempuri__GetSamplePlateId, ""))
				{	soap_flag_tempuri__GetSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetSamplePlateId * SOAP_FMAC2 soap_instantiate___name__GetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetSamplePlateId *p;
	size_t k = sizeof(struct __name__GetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetSamplePlateId(struct soap *soap, const struct __name__GetSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name__GetSamplePlateId(soap, tag ? tag : "-name:GetSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetSamplePlateId * SOAP_FMAC4 soap_get___name__GetSamplePlateId(struct soap *soap, struct __name__GetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__SetSamplePlateId(struct soap *soap, struct __name__SetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetSamplePlateId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__SetSamplePlateId(struct soap *soap, const struct __name__SetSamplePlateId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetSamplePlateId(soap, &a->tempuri__SetSamplePlateId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__SetSamplePlateId(struct soap *soap, const char *tag, int id, const struct __name__SetSamplePlateId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetSamplePlateId(soap, "tempuri:SetSamplePlateId", -1, &a->tempuri__SetSamplePlateId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SetSamplePlateId * SOAP_FMAC4 soap_in___name__SetSamplePlateId(struct soap *soap, const char *tag, struct __name__SetSamplePlateId *a, const char *type)
{
	size_t soap_flag_tempuri__SetSamplePlateId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__SetSamplePlateId*)soap_id_enter(soap, "", a, SOAP_TYPE___name__SetSamplePlateId, sizeof(struct __name__SetSamplePlateId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__SetSamplePlateId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetSamplePlateId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetSamplePlateId(soap, "tempuri:SetSamplePlateId", &a->tempuri__SetSamplePlateId, ""))
				{	soap_flag_tempuri__SetSamplePlateId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__SetSamplePlateId * SOAP_FMAC2 soap_instantiate___name__SetSamplePlateId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__SetSamplePlateId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__SetSamplePlateId *p;
	size_t k = sizeof(struct __name__SetSamplePlateId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__SetSamplePlateId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__SetSamplePlateId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__SetSamplePlateId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__SetSamplePlateId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__SetSamplePlateId(struct soap *soap, const struct __name__SetSamplePlateId *a, const char *tag, const char *type)
{
	if (soap_out___name__SetSamplePlateId(soap, tag ? tag : "-name:SetSamplePlateId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SetSamplePlateId * SOAP_FMAC4 soap_get___name__SetSamplePlateId(struct soap *soap, struct __name__SetSamplePlateId *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__SetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__CreateRunset(struct soap *soap, struct __name__CreateRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__CreateRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__CreateRunset(struct soap *soap, const struct __name__CreateRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__CreateRunset(soap, &a->tempuri__CreateRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__CreateRunset(struct soap *soap, const char *tag, int id, const struct __name__CreateRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__CreateRunset(soap, "tempuri:CreateRunset", -1, &a->tempuri__CreateRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__CreateRunset * SOAP_FMAC4 soap_in___name__CreateRunset(struct soap *soap, const char *tag, struct __name__CreateRunset *a, const char *type)
{
	size_t soap_flag_tempuri__CreateRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__CreateRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__CreateRunset, sizeof(struct __name__CreateRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__CreateRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__CreateRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__CreateRunset(soap, "tempuri:CreateRunset", &a->tempuri__CreateRunset, ""))
				{	soap_flag_tempuri__CreateRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__CreateRunset * SOAP_FMAC2 soap_instantiate___name__CreateRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__CreateRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__CreateRunset *p;
	size_t k = sizeof(struct __name__CreateRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__CreateRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__CreateRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__CreateRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__CreateRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__CreateRunset(struct soap *soap, const struct __name__CreateRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__CreateRunset(soap, tag ? tag : "-name:CreateRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__CreateRunset * SOAP_FMAC4 soap_get___name__CreateRunset(struct soap *soap, struct __name__CreateRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__CreateRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__SelectRunset(struct soap *soap, struct __name__SelectRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SelectRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__SelectRunset(struct soap *soap, const struct __name__SelectRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SelectRunset(soap, &a->tempuri__SelectRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__SelectRunset(struct soap *soap, const char *tag, int id, const struct __name__SelectRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SelectRunset(soap, "tempuri:SelectRunset", -1, &a->tempuri__SelectRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SelectRunset * SOAP_FMAC4 soap_in___name__SelectRunset(struct soap *soap, const char *tag, struct __name__SelectRunset *a, const char *type)
{
	size_t soap_flag_tempuri__SelectRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__SelectRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__SelectRunset, sizeof(struct __name__SelectRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__SelectRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SelectRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SelectRunset(soap, "tempuri:SelectRunset", &a->tempuri__SelectRunset, ""))
				{	soap_flag_tempuri__SelectRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__SelectRunset * SOAP_FMAC2 soap_instantiate___name__SelectRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__SelectRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__SelectRunset *p;
	size_t k = sizeof(struct __name__SelectRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__SelectRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__SelectRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__SelectRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__SelectRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__SelectRunset(struct soap *soap, const struct __name__SelectRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__SelectRunset(soap, tag ? tag : "-name:SelectRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SelectRunset * SOAP_FMAC4 soap_get___name__SelectRunset(struct soap *soap, struct __name__SelectRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__SelectRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__SelectMethod(struct soap *soap, struct __name__SelectMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SelectMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__SelectMethod(struct soap *soap, const struct __name__SelectMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SelectMethod(soap, &a->tempuri__SelectMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__SelectMethod(struct soap *soap, const char *tag, int id, const struct __name__SelectMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SelectMethod(soap, "tempuri:SelectMethod", -1, &a->tempuri__SelectMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SelectMethod * SOAP_FMAC4 soap_in___name__SelectMethod(struct soap *soap, const char *tag, struct __name__SelectMethod *a, const char *type)
{
	size_t soap_flag_tempuri__SelectMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__SelectMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name__SelectMethod, sizeof(struct __name__SelectMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__SelectMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SelectMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SelectMethod(soap, "tempuri:SelectMethod", &a->tempuri__SelectMethod, ""))
				{	soap_flag_tempuri__SelectMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__SelectMethod * SOAP_FMAC2 soap_instantiate___name__SelectMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__SelectMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__SelectMethod *p;
	size_t k = sizeof(struct __name__SelectMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__SelectMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__SelectMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__SelectMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__SelectMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__SelectMethod(struct soap *soap, const struct __name__SelectMethod *a, const char *tag, const char *type)
{
	if (soap_out___name__SelectMethod(soap, tag ? tag : "-name:SelectMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__SelectMethod * SOAP_FMAC4 soap_get___name__SelectMethod(struct soap *soap, struct __name__SelectMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__SelectMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetMethodNamesOfRunset(struct soap *soap, struct __name__GetMethodNamesOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetMethodNamesOfRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetMethodNamesOfRunset(struct soap *soap, const struct __name__GetMethodNamesOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetMethodNamesOfRunset(soap, &a->tempuri__GetMethodNamesOfRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetMethodNamesOfRunset(struct soap *soap, const char *tag, int id, const struct __name__GetMethodNamesOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetMethodNamesOfRunset(soap, "tempuri:GetMethodNamesOfRunset", -1, &a->tempuri__GetMethodNamesOfRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetMethodNamesOfRunset * SOAP_FMAC4 soap_in___name__GetMethodNamesOfRunset(struct soap *soap, const char *tag, struct __name__GetMethodNamesOfRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetMethodNamesOfRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetMethodNamesOfRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetMethodNamesOfRunset, sizeof(struct __name__GetMethodNamesOfRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetMethodNamesOfRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetMethodNamesOfRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetMethodNamesOfRunset(soap, "tempuri:GetMethodNamesOfRunset", &a->tempuri__GetMethodNamesOfRunset, ""))
				{	soap_flag_tempuri__GetMethodNamesOfRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate___name__GetMethodNamesOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetMethodNamesOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetMethodNamesOfRunset *p;
	size_t k = sizeof(struct __name__GetMethodNamesOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetMethodNamesOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetMethodNamesOfRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetMethodNamesOfRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetMethodNamesOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetMethodNamesOfRunset(struct soap *soap, const struct __name__GetMethodNamesOfRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__GetMethodNamesOfRunset(soap, tag ? tag : "-name:GetMethodNamesOfRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetMethodNamesOfRunset * SOAP_FMAC4 soap_get___name__GetMethodNamesOfRunset(struct soap *soap, struct __name__GetMethodNamesOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetMethodNamesOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypeOfRunset(struct soap *soap, struct __name__GetAssayTypeOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypeOfRunset(struct soap *soap, const struct __name__GetAssayTypeOfRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfRunset(soap, &a->tempuri__GetAssayTypeOfRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypeOfRunset(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypeOfRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfRunset(soap, "tempuri:GetAssayTypeOfRunset", -1, &a->tempuri__GetAssayTypeOfRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfRunset * SOAP_FMAC4 soap_in___name__GetAssayTypeOfRunset(struct soap *soap, const char *tag, struct __name__GetAssayTypeOfRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypeOfRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypeOfRunset, sizeof(struct __name__GetAssayTypeOfRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypeOfRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfRunset(soap, "tempuri:GetAssayTypeOfRunset", &a->tempuri__GetAssayTypeOfRunset, ""))
				{	soap_flag_tempuri__GetAssayTypeOfRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypeOfRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypeOfRunset *p;
	size_t k = sizeof(struct __name__GetAssayTypeOfRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypeOfRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypeOfRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypeOfRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypeOfRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypeOfRunset(struct soap *soap, const struct __name__GetAssayTypeOfRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypeOfRunset(soap, tag ? tag : "-name:GetAssayTypeOfRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfRunset * SOAP_FMAC4 soap_get___name__GetAssayTypeOfRunset(struct soap *soap, struct __name__GetAssayTypeOfRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypeOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypeOfCurrentRunset(struct soap *soap, struct __name__GetAssayTypeOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfCurrentRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypeOfCurrentRunset(struct soap *soap, const struct __name__GetAssayTypeOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, &a->tempuri__GetAssayTypeOfCurrentRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, "tempuri:GetAssayTypeOfCurrentRunset", -1, &a->tempuri__GetAssayTypeOfCurrentRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_in___name__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, struct __name__GetAssayTypeOfCurrentRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfCurrentRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypeOfCurrentRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypeOfCurrentRunset, sizeof(struct __name__GetAssayTypeOfCurrentRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypeOfCurrentRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfCurrentRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, "tempuri:GetAssayTypeOfCurrentRunset", &a->tempuri__GetAssayTypeOfCurrentRunset, ""))
				{	soap_flag_tempuri__GetAssayTypeOfCurrentRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypeOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypeOfCurrentRunset *p;
	size_t k = sizeof(struct __name__GetAssayTypeOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypeOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypeOfCurrentRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypeOfCurrentRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypeOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypeOfCurrentRunset(struct soap *soap, const struct __name__GetAssayTypeOfCurrentRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypeOfCurrentRunset(soap, tag ? tag : "-name:GetAssayTypeOfCurrentRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfCurrentRunset * SOAP_FMAC4 soap_get___name__GetAssayTypeOfCurrentRunset(struct soap *soap, struct __name__GetAssayTypeOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypeOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNameOfCurrentRunset(struct soap *soap, struct __name__GetNameOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNameOfCurrentRunset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNameOfCurrentRunset(struct soap *soap, const struct __name__GetNameOfCurrentRunset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNameOfCurrentRunset(soap, &a->tempuri__GetNameOfCurrentRunset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNameOfCurrentRunset(struct soap *soap, const char *tag, int id, const struct __name__GetNameOfCurrentRunset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentRunset(soap, "tempuri:GetNameOfCurrentRunset", -1, &a->tempuri__GetNameOfCurrentRunset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNameOfCurrentRunset * SOAP_FMAC4 soap_in___name__GetNameOfCurrentRunset(struct soap *soap, const char *tag, struct __name__GetNameOfCurrentRunset *a, const char *type)
{
	size_t soap_flag_tempuri__GetNameOfCurrentRunset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNameOfCurrentRunset*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNameOfCurrentRunset, sizeof(struct __name__GetNameOfCurrentRunset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNameOfCurrentRunset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNameOfCurrentRunset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNameOfCurrentRunset(soap, "tempuri:GetNameOfCurrentRunset", &a->tempuri__GetNameOfCurrentRunset, ""))
				{	soap_flag_tempuri__GetNameOfCurrentRunset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name__GetNameOfCurrentRunset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNameOfCurrentRunset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNameOfCurrentRunset *p;
	size_t k = sizeof(struct __name__GetNameOfCurrentRunset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNameOfCurrentRunset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNameOfCurrentRunset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNameOfCurrentRunset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNameOfCurrentRunset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNameOfCurrentRunset(struct soap *soap, const struct __name__GetNameOfCurrentRunset *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNameOfCurrentRunset(soap, tag ? tag : "-name:GetNameOfCurrentRunset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNameOfCurrentRunset * SOAP_FMAC4 soap_get___name__GetNameOfCurrentRunset(struct soap *soap, struct __name__GetNameOfCurrentRunset *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNameOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypesOfAllRunsets(struct soap *soap, struct __name__GetAssayTypesOfAllRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypesOfAllRunsets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypesOfAllRunsets(struct soap *soap, const struct __name__GetAssayTypesOfAllRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, &a->tempuri__GetAssayTypesOfAllRunsets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypesOfAllRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, "tempuri:GetAssayTypesOfAllRunsets", -1, &a->tempuri__GetAssayTypesOfAllRunsets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_in___name__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, struct __name__GetAssayTypesOfAllRunsets *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypesOfAllRunsets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypesOfAllRunsets*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypesOfAllRunsets, sizeof(struct __name__GetAssayTypesOfAllRunsets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypesOfAllRunsets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypesOfAllRunsets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, "tempuri:GetAssayTypesOfAllRunsets", &a->tempuri__GetAssayTypesOfAllRunsets, ""))
				{	soap_flag_tempuri__GetAssayTypesOfAllRunsets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate___name__GetAssayTypesOfAllRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypesOfAllRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypesOfAllRunsets *p;
	size_t k = sizeof(struct __name__GetAssayTypesOfAllRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypesOfAllRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypesOfAllRunsets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypesOfAllRunsets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypesOfAllRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypesOfAllRunsets(struct soap *soap, const struct __name__GetAssayTypesOfAllRunsets *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypesOfAllRunsets(soap, tag ? tag : "-name:GetAssayTypesOfAllRunsets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypesOfAllRunsets * SOAP_FMAC4 soap_get___name__GetAssayTypesOfAllRunsets(struct soap *soap, struct __name__GetAssayTypesOfAllRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypesOfAllRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, struct __name__GetNamesOfRunsetsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfRunsetsOfAssayType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, const struct __name__GetNamesOfRunsetsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, &a->tempuri__GetNamesOfRunsetsOfAssayType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, int id, const struct __name__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, "tempuri:GetNamesOfRunsetsOfAssayType", -1, &a->tempuri__GetNamesOfRunsetsOfAssayType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_in___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, struct __name__GetNamesOfRunsetsOfAssayType *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfRunsetsOfAssayType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNamesOfRunsetsOfAssayType*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType, sizeof(struct __name__GetNamesOfRunsetsOfAssayType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNamesOfRunsetsOfAssayType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfRunsetsOfAssayType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, "tempuri:GetNamesOfRunsetsOfAssayType", &a->tempuri__GetNamesOfRunsetsOfAssayType, ""))
				{	soap_flag_tempuri__GetNamesOfRunsetsOfAssayType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNamesOfRunsetsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNamesOfRunsetsOfAssayType *p;
	size_t k = sizeof(struct __name__GetNamesOfRunsetsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNamesOfRunsetsOfAssayType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNamesOfRunsetsOfAssayType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNamesOfRunsetsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, const struct __name__GetNamesOfRunsetsOfAssayType *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNamesOfRunsetsOfAssayType(soap, tag ? tag : "-name:GetNamesOfRunsetsOfAssayType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfRunsetsOfAssayType * SOAP_FMAC4 soap_get___name__GetNamesOfRunsetsOfAssayType(struct soap *soap, struct __name__GetNamesOfRunsetsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNamesOfRunsetsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNamesOfRunsets(struct soap *soap, struct __name__GetNamesOfRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfRunsets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNamesOfRunsets(struct soap *soap, const struct __name__GetNamesOfRunsets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfRunsets(soap, &a->tempuri__GetNamesOfRunsets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNamesOfRunsets(struct soap *soap, const char *tag, int id, const struct __name__GetNamesOfRunsets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsets(soap, "tempuri:GetNamesOfRunsets", -1, &a->tempuri__GetNamesOfRunsets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfRunsets * SOAP_FMAC4 soap_in___name__GetNamesOfRunsets(struct soap *soap, const char *tag, struct __name__GetNamesOfRunsets *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfRunsets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNamesOfRunsets*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNamesOfRunsets, sizeof(struct __name__GetNamesOfRunsets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNamesOfRunsets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfRunsets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfRunsets(soap, "tempuri:GetNamesOfRunsets", &a->tempuri__GetNamesOfRunsets, ""))
				{	soap_flag_tempuri__GetNamesOfRunsets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate___name__GetNamesOfRunsets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNamesOfRunsets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNamesOfRunsets *p;
	size_t k = sizeof(struct __name__GetNamesOfRunsets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNamesOfRunsets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNamesOfRunsets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNamesOfRunsets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNamesOfRunsets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNamesOfRunsets(struct soap *soap, const struct __name__GetNamesOfRunsets *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNamesOfRunsets(soap, tag ? tag : "-name:GetNamesOfRunsets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfRunsets * SOAP_FMAC4 soap_get___name__GetNamesOfRunsets(struct soap *soap, struct __name__GetNamesOfRunsets *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNamesOfRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypeOfMethod(struct soap *soap, struct __name__GetAssayTypeOfMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypeOfMethod(struct soap *soap, const struct __name__GetAssayTypeOfMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfMethod(soap, &a->tempuri__GetAssayTypeOfMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypeOfMethod(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypeOfMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfMethod(soap, "tempuri:GetAssayTypeOfMethod", -1, &a->tempuri__GetAssayTypeOfMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfMethod * SOAP_FMAC4 soap_in___name__GetAssayTypeOfMethod(struct soap *soap, const char *tag, struct __name__GetAssayTypeOfMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypeOfMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypeOfMethod, sizeof(struct __name__GetAssayTypeOfMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypeOfMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfMethod(soap, "tempuri:GetAssayTypeOfMethod", &a->tempuri__GetAssayTypeOfMethod, ""))
				{	soap_flag_tempuri__GetAssayTypeOfMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypeOfMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypeOfMethod *p;
	size_t k = sizeof(struct __name__GetAssayTypeOfMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypeOfMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypeOfMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypeOfMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypeOfMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypeOfMethod(struct soap *soap, const struct __name__GetAssayTypeOfMethod *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypeOfMethod(soap, tag ? tag : "-name:GetAssayTypeOfMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfMethod * SOAP_FMAC4 soap_get___name__GetAssayTypeOfMethod(struct soap *soap, struct __name__GetAssayTypeOfMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypeOfMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypeOfCurrentMethod(struct soap *soap, struct __name__GetAssayTypeOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypeOfCurrentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypeOfCurrentMethod(struct soap *soap, const struct __name__GetAssayTypeOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, &a->tempuri__GetAssayTypeOfCurrentMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, "tempuri:GetAssayTypeOfCurrentMethod", -1, &a->tempuri__GetAssayTypeOfCurrentMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_in___name__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, struct __name__GetAssayTypeOfCurrentMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypeOfCurrentMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypeOfCurrentMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypeOfCurrentMethod, sizeof(struct __name__GetAssayTypeOfCurrentMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypeOfCurrentMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypeOfCurrentMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, "tempuri:GetAssayTypeOfCurrentMethod", &a->tempuri__GetAssayTypeOfCurrentMethod, ""))
				{	soap_flag_tempuri__GetAssayTypeOfCurrentMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypeOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypeOfCurrentMethod *p;
	size_t k = sizeof(struct __name__GetAssayTypeOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypeOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypeOfCurrentMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypeOfCurrentMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypeOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypeOfCurrentMethod(struct soap *soap, const struct __name__GetAssayTypeOfCurrentMethod *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypeOfCurrentMethod(soap, tag ? tag : "-name:GetAssayTypeOfCurrentMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypeOfCurrentMethod * SOAP_FMAC4 soap_get___name__GetAssayTypeOfCurrentMethod(struct soap *soap, struct __name__GetAssayTypeOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypeOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNameOfCurrentMethod(struct soap *soap, struct __name__GetNameOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNameOfCurrentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNameOfCurrentMethod(struct soap *soap, const struct __name__GetNameOfCurrentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNameOfCurrentMethod(soap, &a->tempuri__GetNameOfCurrentMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNameOfCurrentMethod(struct soap *soap, const char *tag, int id, const struct __name__GetNameOfCurrentMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentMethod(soap, "tempuri:GetNameOfCurrentMethod", -1, &a->tempuri__GetNameOfCurrentMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNameOfCurrentMethod * SOAP_FMAC4 soap_in___name__GetNameOfCurrentMethod(struct soap *soap, const char *tag, struct __name__GetNameOfCurrentMethod *a, const char *type)
{
	size_t soap_flag_tempuri__GetNameOfCurrentMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNameOfCurrentMethod*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNameOfCurrentMethod, sizeof(struct __name__GetNameOfCurrentMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNameOfCurrentMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNameOfCurrentMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNameOfCurrentMethod(soap, "tempuri:GetNameOfCurrentMethod", &a->tempuri__GetNameOfCurrentMethod, ""))
				{	soap_flag_tempuri__GetNameOfCurrentMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name__GetNameOfCurrentMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNameOfCurrentMethod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNameOfCurrentMethod *p;
	size_t k = sizeof(struct __name__GetNameOfCurrentMethod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNameOfCurrentMethod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNameOfCurrentMethod);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNameOfCurrentMethod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNameOfCurrentMethod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNameOfCurrentMethod(struct soap *soap, const struct __name__GetNameOfCurrentMethod *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNameOfCurrentMethod(soap, tag ? tag : "-name:GetNameOfCurrentMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNameOfCurrentMethod * SOAP_FMAC4 soap_get___name__GetNameOfCurrentMethod(struct soap *soap, struct __name__GetNameOfCurrentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNameOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetAssayTypesOfAllMethods(struct soap *soap, struct __name__GetAssayTypesOfAllMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetAssayTypesOfAllMethods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetAssayTypesOfAllMethods(struct soap *soap, const struct __name__GetAssayTypesOfAllMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, &a->tempuri__GetAssayTypesOfAllMethods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, int id, const struct __name__GetAssayTypesOfAllMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, "tempuri:GetAssayTypesOfAllMethods", -1, &a->tempuri__GetAssayTypesOfAllMethods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_in___name__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, struct __name__GetAssayTypesOfAllMethods *a, const char *type)
{
	size_t soap_flag_tempuri__GetAssayTypesOfAllMethods = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetAssayTypesOfAllMethods*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetAssayTypesOfAllMethods, sizeof(struct __name__GetAssayTypesOfAllMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetAssayTypesOfAllMethods(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetAssayTypesOfAllMethods && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, "tempuri:GetAssayTypesOfAllMethods", &a->tempuri__GetAssayTypesOfAllMethods, ""))
				{	soap_flag_tempuri__GetAssayTypesOfAllMethods--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate___name__GetAssayTypesOfAllMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetAssayTypesOfAllMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetAssayTypesOfAllMethods *p;
	size_t k = sizeof(struct __name__GetAssayTypesOfAllMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetAssayTypesOfAllMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetAssayTypesOfAllMethods);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetAssayTypesOfAllMethods, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetAssayTypesOfAllMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetAssayTypesOfAllMethods(struct soap *soap, const struct __name__GetAssayTypesOfAllMethods *a, const char *tag, const char *type)
{
	if (soap_out___name__GetAssayTypesOfAllMethods(soap, tag ? tag : "-name:GetAssayTypesOfAllMethods", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetAssayTypesOfAllMethods * SOAP_FMAC4 soap_get___name__GetAssayTypesOfAllMethods(struct soap *soap, struct __name__GetAssayTypesOfAllMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetAssayTypesOfAllMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNamesOfMethodsOfAssayType(struct soap *soap, struct __name__GetNamesOfMethodsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMethodsOfAssayType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNamesOfMethodsOfAssayType(struct soap *soap, const struct __name__GetNamesOfMethodsOfAssayType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, &a->tempuri__GetNamesOfMethodsOfAssayType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, int id, const struct __name__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, "tempuri:GetNamesOfMethodsOfAssayType", -1, &a->tempuri__GetNamesOfMethodsOfAssayType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_in___name__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, struct __name__GetNamesOfMethodsOfAssayType *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMethodsOfAssayType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNamesOfMethodsOfAssayType*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNamesOfMethodsOfAssayType, sizeof(struct __name__GetNamesOfMethodsOfAssayType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNamesOfMethodsOfAssayType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMethodsOfAssayType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, "tempuri:GetNamesOfMethodsOfAssayType", &a->tempuri__GetNamesOfMethodsOfAssayType, ""))
				{	soap_flag_tempuri__GetNamesOfMethodsOfAssayType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMethodsOfAssayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNamesOfMethodsOfAssayType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNamesOfMethodsOfAssayType *p;
	size_t k = sizeof(struct __name__GetNamesOfMethodsOfAssayType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNamesOfMethodsOfAssayType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNamesOfMethodsOfAssayType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNamesOfMethodsOfAssayType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNamesOfMethodsOfAssayType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNamesOfMethodsOfAssayType(struct soap *soap, const struct __name__GetNamesOfMethodsOfAssayType *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNamesOfMethodsOfAssayType(soap, tag ? tag : "-name:GetNamesOfMethodsOfAssayType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMethodsOfAssayType * SOAP_FMAC4 soap_get___name__GetNamesOfMethodsOfAssayType(struct soap *soap, struct __name__GetNamesOfMethodsOfAssayType *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNamesOfMethodsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___name__GetNamesOfMethods(struct soap *soap, struct __name__GetNamesOfMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetNamesOfMethods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___name__GetNamesOfMethods(struct soap *soap, const struct __name__GetNamesOfMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetNamesOfMethods(soap, &a->tempuri__GetNamesOfMethods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___name__GetNamesOfMethods(struct soap *soap, const char *tag, int id, const struct __name__GetNamesOfMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetNamesOfMethods(soap, "tempuri:GetNamesOfMethods", -1, &a->tempuri__GetNamesOfMethods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMethods * SOAP_FMAC4 soap_in___name__GetNamesOfMethods(struct soap *soap, const char *tag, struct __name__GetNamesOfMethods *a, const char *type)
{
	size_t soap_flag_tempuri__GetNamesOfMethods = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __name__GetNamesOfMethods*)soap_id_enter(soap, "", a, SOAP_TYPE___name__GetNamesOfMethods, sizeof(struct __name__GetNamesOfMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___name__GetNamesOfMethods(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetNamesOfMethods && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetNamesOfMethods(soap, "tempuri:GetNamesOfMethods", &a->tempuri__GetNamesOfMethods, ""))
				{	soap_flag_tempuri__GetNamesOfMethods--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __name__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMethods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___name__GetNamesOfMethods(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __name__GetNamesOfMethods *p;
	size_t k = sizeof(struct __name__GetNamesOfMethods);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___name__GetNamesOfMethods, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __name__GetNamesOfMethods);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __name__GetNamesOfMethods, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __name__GetNamesOfMethods location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___name__GetNamesOfMethods(struct soap *soap, const struct __name__GetNamesOfMethods *a, const char *tag, const char *type)
{
	if (soap_out___name__GetNamesOfMethods(soap, tag ? tag : "-name:GetNamesOfMethods", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __name__GetNamesOfMethods * SOAP_FMAC4 soap_get___name__GetNamesOfMethods(struct soap *soap, struct __name__GetNamesOfMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in___name__GetNamesOfMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_ULONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_ULONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_ULONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_ULONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__TerminateSequenceResponseType))
		soap_serialize_wsrm__TerminateSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__TerminateSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__TerminateSequenceResponseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__TerminateSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceResponseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__TerminateSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__TerminateSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__TerminateSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__TerminateSequenceResponseType, sizeof(struct wsrm__TerminateSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, tag ? tag : "wsrm:TerminateSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__TerminateSequenceType))
		soap_serialize_wsrm__TerminateSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__TerminateSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__TerminateSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__TerminateSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__TerminateSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__TerminateSequenceType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__TerminateSequenceType **)soap_malloc(soap, sizeof(struct wsrm__TerminateSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__TerminateSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__TerminateSequenceType, sizeof(struct wsrm__TerminateSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__TerminateSequenceType(soap, tag ? tag : "wsrm:TerminateSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__TerminateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CloseSequenceResponseType))
		soap_serialize_wsrm__CloseSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__CloseSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CloseSequenceResponseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CloseSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceResponseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CloseSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__CloseSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CloseSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CloseSequenceResponseType, sizeof(struct wsrm__CloseSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__CloseSequenceResponseType(soap, tag ? tag : "wsrm:CloseSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CloseSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CloseSequenceType))
		soap_serialize_wsrm__CloseSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CloseSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__CloseSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CloseSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CloseSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__CloseSequenceType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CloseSequenceType **)soap_malloc(soap, sizeof(struct wsrm__CloseSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CloseSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CloseSequenceType, sizeof(struct wsrm__CloseSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__CloseSequenceType(soap, tag ? tag : "wsrm:CloseSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CloseSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CreateSequenceResponseType))
		soap_serialize_wsrm__CreateSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__CreateSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CreateSequenceResponseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CreateSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceResponseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CreateSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__CreateSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CreateSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CreateSequenceResponseType, sizeof(struct wsrm__CreateSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__CreateSequenceResponseType(soap, tag ? tag : "wsrm:CreateSequenceResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CreateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CreateSequenceType))
		soap_serialize_wsrm__CreateSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CreateSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__CreateSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CreateSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CreateSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__CreateSequenceType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CreateSequenceType **)soap_malloc(soap, sizeof(struct wsrm__CreateSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CreateSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CreateSequenceType, sizeof(struct wsrm__CreateSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__CreateSequenceType(soap, tag ? tag : "wsrm:CreateSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CreateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__SequenceFaultType))
		soap_serialize_wsrm__SequenceFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__SequenceFaultType(struct soap *soap, const char *tag, int id, struct wsrm__SequenceFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__SequenceFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__SequenceFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType ** SOAP_FMAC4 soap_in_PointerTowsrm__SequenceFaultType(struct soap *soap, const char *tag, struct wsrm__SequenceFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__SequenceFaultType **)soap_malloc(soap, sizeof(struct wsrm__SequenceFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__SequenceFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__SequenceFaultType, sizeof(struct wsrm__SequenceFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__SequenceFaultType(soap, tag ? tag : "wsrm:SequenceFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType ** SOAP_FMAC4 soap_get_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__SequenceFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement))
		soap_serialize__wsrm__SequenceAcknowledgement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement(soap, tag ? tag : "wsrm:SequenceAcknowledgement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__AckRequestedType))
		soap_serialize_wsrm__AckRequestedType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__AckRequestedType(struct soap *soap, const char *tag, int id, struct wsrm__AckRequestedType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__AckRequestedType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__AckRequestedType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__AckRequestedType ** SOAP_FMAC4 soap_in_PointerTowsrm__AckRequestedType(struct soap *soap, const char *tag, struct wsrm__AckRequestedType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__AckRequestedType **)soap_malloc(soap, sizeof(struct wsrm__AckRequestedType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__AckRequestedType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__AckRequestedType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__AckRequestedType, sizeof(struct wsrm__AckRequestedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__AckRequestedType(soap, tag ? tag : "wsrm:AckRequestedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AckRequestedType ** SOAP_FMAC4 soap_get_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__AckRequestedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__SequenceType))
		soap_serialize_wsrm__SequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__SequenceType(struct soap *soap, const char *tag, int id, struct wsrm__SequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__SequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__SequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__SequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__SequenceType(struct soap *soap, const char *tag, struct wsrm__SequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__SequenceType **)soap_malloc(soap, sizeof(struct wsrm__SequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__SequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__SequenceType, sizeof(struct wsrm__SequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__SequenceType(soap, tag ? tag : "wsrm:SequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__SequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None))
		soap_serialize__wsrm__SequenceAcknowledgement_None(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_None *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_None(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_None **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_None **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_None *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_None(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_None **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, sizeof(struct _wsrm__SequenceAcknowledgement_None), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag ? tag : "wsrm:SequenceAcknowledgement-None", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange))
		soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag ? tag : "wsrm:SequenceAcknowledgement-AcknowledgementRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final))
		soap_serialize__wsrm__SequenceAcknowledgement_Final(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_Final *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_Final(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_Final **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_Final **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_Final *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_Final(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_Final **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, sizeof(struct _wsrm__SequenceAcknowledgement_Final), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag ? tag : "wsrm:SequenceAcknowledgement-Final", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__AcceptType))
		soap_serialize_wsrm__AcceptType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__AcceptType(struct soap *soap, const char *tag, int id, struct wsrm__AcceptType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__AcceptType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__AcceptType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__AcceptType ** SOAP_FMAC4 soap_in_PointerTowsrm__AcceptType(struct soap *soap, const char *tag, struct wsrm__AcceptType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__AcceptType **)soap_malloc(soap, sizeof(struct wsrm__AcceptType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__AcceptType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__AcceptType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__AcceptType, sizeof(struct wsrm__AcceptType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__AcceptType(soap, tag ? tag : "wsrm:AcceptType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AcceptType ** SOAP_FMAC4 soap_get_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__AcceptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, int id, enum wsrm__IncompleteSequenceBehaviorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType ** SOAP_FMAC4 soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, enum wsrm__IncompleteSequenceBehaviorType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum wsrm__IncompleteSequenceBehaviorType **)soap_malloc(soap, sizeof(enum wsrm__IncompleteSequenceBehaviorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum wsrm__IncompleteSequenceBehaviorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, sizeof(enum wsrm__IncompleteSequenceBehaviorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag ? tag : "wsrm:IncompleteSequenceBehaviorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType ** SOAP_FMAC4 soap_get_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__OfferType))
		soap_serialize_wsrm__OfferType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__OfferType(struct soap *soap, const char *tag, int id, struct wsrm__OfferType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__OfferType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__OfferType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__OfferType ** SOAP_FMAC4 soap_in_PointerTowsrm__OfferType(struct soap *soap, const char *tag, struct wsrm__OfferType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__OfferType **)soap_malloc(soap, sizeof(struct wsrm__OfferType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__OfferType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__OfferType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__OfferType, sizeof(struct wsrm__OfferType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrm__OfferType(soap, tag ? tag : "wsrm:OfferType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__OfferType ** SOAP_FMAC4 soap_get_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__OfferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__UsesSequenceSSL))
		soap_serialize__wsrm__UsesSequenceSSL(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, int id, struct _wsrm__UsesSequenceSSL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__UsesSequenceSSL, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__UsesSequenceSSL(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL ** SOAP_FMAC4 soap_in_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSSL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__UsesSequenceSSL **)soap_malloc(soap, sizeof(struct _wsrm__UsesSequenceSSL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__UsesSequenceSSL(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSSL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__UsesSequenceSSL, sizeof(struct _wsrm__UsesSequenceSSL), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, tag ? tag : "wsrm:UsesSequenceSSL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL ** SOAP_FMAC4 soap_get_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__Identifier(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsrm__Identifier(soap, tag ? tag : "wsrm:Identifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestSecurityTokenCollectionType(struct soap *soap, struct wst__RequestSecurityTokenCollectionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestSecurityTokenCollectionType))
		soap_serialize_wst__RequestSecurityTokenCollectionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestSecurityTokenCollectionType(struct soap *soap, const char *tag, int id, struct wst__RequestSecurityTokenCollectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestSecurityTokenCollectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenCollectionType ** SOAP_FMAC4 soap_in_PointerTowst__RequestSecurityTokenCollectionType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenCollectionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestSecurityTokenCollectionType **)soap_malloc(soap, sizeof(struct wst__RequestSecurityTokenCollectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestSecurityTokenCollectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenCollectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestSecurityTokenCollectionType, sizeof(struct wst__RequestSecurityTokenCollectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestSecurityTokenCollectionType(struct soap *soap, struct wst__RequestSecurityTokenCollectionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestSecurityTokenCollectionType(soap, tag ? tag : "wst:RequestSecurityTokenCollectionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenCollectionType ** SOAP_FMAC4 soap_get_PointerTowst__RequestSecurityTokenCollectionType(struct soap *soap, struct wst__RequestSecurityTokenCollectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestSecurityTokenCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestSecurityTokenResponseCollectionType(struct soap *soap, struct wst__RequestSecurityTokenResponseCollectionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType))
		soap_serialize_wst__RequestSecurityTokenResponseCollectionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const char *tag, int id, struct wst__RequestSecurityTokenResponseCollectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestSecurityTokenResponseCollectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseCollectionType ** SOAP_FMAC4 soap_in_PointerTowst__RequestSecurityTokenResponseCollectionType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenResponseCollectionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestSecurityTokenResponseCollectionType **)soap_malloc(soap, sizeof(struct wst__RequestSecurityTokenResponseCollectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestSecurityTokenResponseCollectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenResponseCollectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType, sizeof(struct wst__RequestSecurityTokenResponseCollectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestSecurityTokenResponseCollectionType(struct soap *soap, struct wst__RequestSecurityTokenResponseCollectionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestSecurityTokenResponseCollectionType(soap, tag ? tag : "wst:RequestSecurityTokenResponseCollectionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseCollectionType ** SOAP_FMAC4 soap_get_PointerTowst__RequestSecurityTokenResponseCollectionType(struct soap *soap, struct wst__RequestSecurityTokenResponseCollectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestSecurityTokenResponseCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Delegatable(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__Delegatable(soap, tag ? tag : "wst:Delegatable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Forwardable(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__Forwardable(soap, tag ? tag : "wst:Forwardable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__EncryptWith(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__EncryptWith(soap, tag ? tag : "wst:EncryptWith", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__SignWith(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__SignWith(soap, tag ? tag : "wst:SignWith", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__KeyWrapAlgorithm(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__KeyWrapAlgorithm(soap, tag ? tag : "wst:KeyWrapAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__ComputedKeyAlgorithm(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__ComputedKeyAlgorithm(soap, tag ? tag : "wst:ComputedKeyAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__CanonicalizationAlgorithm(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__CanonicalizationAlgorithm(soap, tag ? tag : "wst:CanonicalizationAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__EncryptionAlgorithm(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__EncryptionAlgorithm(soap, tag ? tag : "wst:EncryptionAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__SignatureAlgorithm(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__SignatureAlgorithm(soap, tag ? tag : "wst:SignatureAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__KeyType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__KeyType(soap, tag ? tag : "wst:KeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__AuthenticationType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__AuthenticationType(soap, tag ? tag : "wst:AuthenticationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__CombinedHash(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__CombinedHash(soap, tag ? tag : "wst:CombinedHash", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__Challenge(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__Challenge(soap, tag ? tag : "wst:Challenge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__ComputedKey(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__ComputedKey(soap, tag ? tag : "wst:ComputedKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__RequestType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__RequestType(soap, tag ? tag : "wst:RequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wst__TokenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wst__TokenType(soap, tag ? tag : "wst:TokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__ParticipantType(struct soap *soap, struct wst__ParticipantType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__ParticipantType))
		soap_serialize_wst__ParticipantType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__ParticipantType(struct soap *soap, const char *tag, int id, struct wst__ParticipantType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__ParticipantType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__ParticipantType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__ParticipantType ** SOAP_FMAC4 soap_in_PointerTowst__ParticipantType(struct soap *soap, const char *tag, struct wst__ParticipantType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__ParticipantType **)soap_malloc(soap, sizeof(struct wst__ParticipantType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__ParticipantType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__ParticipantType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__ParticipantType, sizeof(struct wst__ParticipantType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__ParticipantType(struct soap *soap, struct wst__ParticipantType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__ParticipantType(soap, tag ? tag : "wst:ParticipantType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__ParticipantType ** SOAP_FMAC4 soap_get_PointerTowst__ParticipantType(struct soap *soap, struct wst__ParticipantType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__ParticipantType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestSecurityTokenResponseType(struct soap *soap, struct wst__RequestSecurityTokenResponseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestSecurityTokenResponseType))
		soap_serialize_wst__RequestSecurityTokenResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestSecurityTokenResponseType(struct soap *soap, const char *tag, int id, struct wst__RequestSecurityTokenResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestSecurityTokenResponseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestSecurityTokenResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseType ** SOAP_FMAC4 soap_in_PointerTowst__RequestSecurityTokenResponseType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenResponseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestSecurityTokenResponseType **)soap_malloc(soap, sizeof(struct wst__RequestSecurityTokenResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestSecurityTokenResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestSecurityTokenResponseType, sizeof(struct wst__RequestSecurityTokenResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestSecurityTokenResponseType(struct soap *soap, struct wst__RequestSecurityTokenResponseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestSecurityTokenResponseType(soap, tag ? tag : "wst:RequestSecurityTokenResponseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenResponseType ** SOAP_FMAC4 soap_get_PointerTowst__RequestSecurityTokenResponseType(struct soap *soap, struct wst__RequestSecurityTokenResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestSecurityTokenResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestSecurityTokenType(struct soap *soap, struct wst__RequestSecurityTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestSecurityTokenType))
		soap_serialize_wst__RequestSecurityTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestSecurityTokenType(struct soap *soap, const char *tag, int id, struct wst__RequestSecurityTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestSecurityTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestSecurityTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenType ** SOAP_FMAC4 soap_in_PointerTowst__RequestSecurityTokenType(struct soap *soap, const char *tag, struct wst__RequestSecurityTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestSecurityTokenType **)soap_malloc(soap, sizeof(struct wst__RequestSecurityTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestSecurityTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestSecurityTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestSecurityTokenType, sizeof(struct wst__RequestSecurityTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestSecurityTokenType(struct soap *soap, struct wst__RequestSecurityTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestSecurityTokenType(soap, tag ? tag : "wst:RequestSecurityTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestSecurityTokenType ** SOAP_FMAC4 soap_get_PointerTowst__RequestSecurityTokenType(struct soap *soap, struct wst__RequestSecurityTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestSecurityTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__LifetimeType(struct soap *soap, struct wst__LifetimeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__LifetimeType))
		soap_serialize_wst__LifetimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__LifetimeType(struct soap *soap, const char *tag, int id, struct wst__LifetimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__LifetimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__LifetimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__LifetimeType ** SOAP_FMAC4 soap_in_PointerTowst__LifetimeType(struct soap *soap, const char *tag, struct wst__LifetimeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__LifetimeType **)soap_malloc(soap, sizeof(struct wst__LifetimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__LifetimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__LifetimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__LifetimeType, sizeof(struct wst__LifetimeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__LifetimeType(struct soap *soap, struct wst__LifetimeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__LifetimeType(soap, tag ? tag : "wst:LifetimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__LifetimeType ** SOAP_FMAC4 soap_get_PointerTowst__LifetimeType(struct soap *soap, struct wst__LifetimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__LifetimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestedProofTokenType(struct soap *soap, struct wst__RequestedProofTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestedProofTokenType))
		soap_serialize_wst__RequestedProofTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestedProofTokenType(struct soap *soap, const char *tag, int id, struct wst__RequestedProofTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestedProofTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestedProofTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestedProofTokenType ** SOAP_FMAC4 soap_in_PointerTowst__RequestedProofTokenType(struct soap *soap, const char *tag, struct wst__RequestedProofTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestedProofTokenType **)soap_malloc(soap, sizeof(struct wst__RequestedProofTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestedProofTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedProofTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestedProofTokenType, sizeof(struct wst__RequestedProofTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestedProofTokenType(struct soap *soap, struct wst__RequestedProofTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestedProofTokenType(soap, tag ? tag : "wst:RequestedProofTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedProofTokenType ** SOAP_FMAC4 soap_get_PointerTowst__RequestedProofTokenType(struct soap *soap, struct wst__RequestedProofTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestedProofTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestedReferenceType(struct soap *soap, struct wst__RequestedReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestedReferenceType))
		soap_serialize_wst__RequestedReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestedReferenceType(struct soap *soap, const char *tag, int id, struct wst__RequestedReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestedReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestedReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestedReferenceType ** SOAP_FMAC4 soap_in_PointerTowst__RequestedReferenceType(struct soap *soap, const char *tag, struct wst__RequestedReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestedReferenceType **)soap_malloc(soap, sizeof(struct wst__RequestedReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestedReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestedReferenceType, sizeof(struct wst__RequestedReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestedReferenceType(struct soap *soap, struct wst__RequestedReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestedReferenceType(soap, tag ? tag : "wst:RequestedReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedReferenceType ** SOAP_FMAC4 soap_get_PointerTowst__RequestedReferenceType(struct soap *soap, struct wst__RequestedReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestedReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__RequestedSecurityTokenType(struct soap *soap, struct wst__RequestedSecurityTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__RequestedSecurityTokenType))
		soap_serialize_wst__RequestedSecurityTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__RequestedSecurityTokenType(struct soap *soap, const char *tag, int id, struct wst__RequestedSecurityTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__RequestedSecurityTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__RequestedSecurityTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__RequestedSecurityTokenType ** SOAP_FMAC4 soap_in_PointerTowst__RequestedSecurityTokenType(struct soap *soap, const char *tag, struct wst__RequestedSecurityTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__RequestedSecurityTokenType **)soap_malloc(soap, sizeof(struct wst__RequestedSecurityTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__RequestedSecurityTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__RequestedSecurityTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__RequestedSecurityTokenType, sizeof(struct wst__RequestedSecurityTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__RequestedSecurityTokenType(struct soap *soap, struct wst__RequestedSecurityTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__RequestedSecurityTokenType(soap, tag ? tag : "wst:RequestedSecurityTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__RequestedSecurityTokenType ** SOAP_FMAC4 soap_get_PointerTowst__RequestedSecurityTokenType(struct soap *soap, struct wst__RequestedSecurityTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__RequestedSecurityTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__AuthenticatorType(struct soap *soap, struct wst__AuthenticatorType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__AuthenticatorType))
		soap_serialize_wst__AuthenticatorType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__AuthenticatorType(struct soap *soap, const char *tag, int id, struct wst__AuthenticatorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__AuthenticatorType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__AuthenticatorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__AuthenticatorType ** SOAP_FMAC4 soap_in_PointerTowst__AuthenticatorType(struct soap *soap, const char *tag, struct wst__AuthenticatorType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__AuthenticatorType **)soap_malloc(soap, sizeof(struct wst__AuthenticatorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__AuthenticatorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__AuthenticatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__AuthenticatorType, sizeof(struct wst__AuthenticatorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__AuthenticatorType(struct soap *soap, struct wst__AuthenticatorType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__AuthenticatorType(soap, tag ? tag : "wst:AuthenticatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__AuthenticatorType ** SOAP_FMAC4 soap_get_PointerTowst__AuthenticatorType(struct soap *soap, struct wst__AuthenticatorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__AuthenticatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__BinaryExchangeType(struct soap *soap, struct wst__BinaryExchangeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__BinaryExchangeType))
		soap_serialize_wst__BinaryExchangeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__BinaryExchangeType(struct soap *soap, const char *tag, int id, struct wst__BinaryExchangeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__BinaryExchangeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__BinaryExchangeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__BinaryExchangeType ** SOAP_FMAC4 soap_in_PointerTowst__BinaryExchangeType(struct soap *soap, const char *tag, struct wst__BinaryExchangeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__BinaryExchangeType **)soap_malloc(soap, sizeof(struct wst__BinaryExchangeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__BinaryExchangeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__BinaryExchangeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__BinaryExchangeType, sizeof(struct wst__BinaryExchangeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__BinaryExchangeType(struct soap *soap, struct wst__BinaryExchangeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__BinaryExchangeType(soap, tag ? tag : "wst:BinaryExchangeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__BinaryExchangeType ** SOAP_FMAC4 soap_get_PointerTowst__BinaryExchangeType(struct soap *soap, struct wst__BinaryExchangeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__BinaryExchangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__EntropyType(struct soap *soap, struct wst__EntropyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__EntropyType))
		soap_serialize_wst__EntropyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__EntropyType(struct soap *soap, const char *tag, int id, struct wst__EntropyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__EntropyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__EntropyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__EntropyType ** SOAP_FMAC4 soap_in_PointerTowst__EntropyType(struct soap *soap, const char *tag, struct wst__EntropyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__EntropyType **)soap_malloc(soap, sizeof(struct wst__EntropyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__EntropyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__EntropyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__EntropyType, sizeof(struct wst__EntropyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__EntropyType(struct soap *soap, struct wst__EntropyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__EntropyType(soap, tag ? tag : "wst:EntropyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__EntropyType ** SOAP_FMAC4 soap_get_PointerTowst__EntropyType(struct soap *soap, struct wst__EntropyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__EntropyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsp__AppliesTo_(struct soap *soap, struct _wsp__AppliesTo_ *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsp__AppliesTo_))
		soap_serialize__wsp__AppliesTo_(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsp__AppliesTo_(struct soap *soap, const char *tag, int id, struct _wsp__AppliesTo_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsp__AppliesTo_, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsp__AppliesTo_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsp__AppliesTo_ ** SOAP_FMAC4 soap_in_PointerTo_wsp__AppliesTo_(struct soap *soap, const char *tag, struct _wsp__AppliesTo_ **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsp__AppliesTo_ **)soap_malloc(soap, sizeof(struct _wsp__AppliesTo_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsp__AppliesTo_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsp__AppliesTo_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsp__AppliesTo_, sizeof(struct _wsp__AppliesTo_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsp__AppliesTo_(struct soap *soap, struct _wsp__AppliesTo_ *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsp__AppliesTo_(soap, tag ? tag : "wsp:AppliesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsp__AppliesTo_ ** SOAP_FMAC4 soap_get_PointerTo_wsp__AppliesTo_(struct soap *soap, struct _wsp__AppliesTo_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsp__AppliesTo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__BinarySecretType(struct soap *soap, struct wst__BinarySecretType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__BinarySecretType))
		soap_serialize_wst__BinarySecretType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__BinarySecretType(struct soap *soap, const char *tag, int id, struct wst__BinarySecretType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__BinarySecretType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wst__BinarySecretType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wst__BinarySecretType ** SOAP_FMAC4 soap_in_PointerTowst__BinarySecretType(struct soap *soap, const char *tag, struct wst__BinarySecretType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wst__BinarySecretType **)soap_malloc(soap, sizeof(struct wst__BinarySecretType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wst__BinarySecretType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wst__BinarySecretType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__BinarySecretType, sizeof(struct wst__BinarySecretType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__BinarySecretType(struct soap *soap, struct wst__BinarySecretType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__BinarySecretType(soap, tag ? tag : "wst:BinarySecretType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wst__BinarySecretType ** SOAP_FMAC4 soap_get_PointerTowst__BinarySecretType(struct soap *soap, struct wst__BinarySecretType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__BinarySecretType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__SecurityContextTokenType))
		soap_serialize_wsc__SecurityContextTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, struct wsc__SecurityContextTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__SecurityContextTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__SecurityContextTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_in_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__SecurityContextTokenType **)soap_malloc(soap, sizeof(struct wsc__SecurityContextTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__SecurityContextTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_get_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthenticatingAuthority(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthenticatingAuthority(soap, tag ? tag : "saml2:AuthenticatingAuthority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextDeclRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextDeclRef(soap, tag ? tag : "saml2:AuthnContextDeclRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextClassRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextClassRef(soap, tag ? tag : "saml2:AuthnContextClassRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__Audience(soap, tag ? tag : "saml2:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionURIRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionURIRef(soap, tag ? tag : "saml2:AssertionURIRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionIDRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionIDRef(soap, tag ? tag : "saml2:AssertionIDRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ds__KeyInfo))
		soap_serialize_PointerTo_ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_in_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType ***)soap_malloc(soap, sizeof(struct ds__KeyInfoType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_get_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AttributeStatementType))
		soap_serialize___saml2__union_AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, struct __saml2__union_AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AttributeStatementType **)soap_malloc(soap, sizeof(struct __saml2__union_AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeType))
		soap_serialize_saml2__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, int id, struct saml2__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeType **)soap_malloc(soap, sizeof(struct saml2__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EvidenceType))
		soap_serialize_saml2__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, int id, struct saml2__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EvidenceType **)soap_malloc(soap, sizeof(struct saml2__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ActionType))
		soap_serialize_saml2__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ActionType(struct soap *soap, const char *tag, int id, struct saml2__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ActionType **)soap_malloc(soap, sizeof(struct saml2__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnContextType))
		soap_serialize_saml2__AuthnContextType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, int id, struct saml2__AuthnContextType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnContextType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnContextType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnContextType **)soap_malloc(soap, sizeof(struct saml2__AuthnContextType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnContextType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectLocalityType))
		soap_serialize_saml2__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml2__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml2__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_EvidenceType))
		soap_serialize___saml2__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml2__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml2__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AdviceType))
		soap_serialize___saml2__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml2__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml2__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AssertionType))
		soap_serialize_saml2__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, int id, struct saml2__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml2__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AssertionType **)soap_malloc(soap, sizeof(struct saml2__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_ConditionsType))
		soap_serialize___saml2__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml2__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml2__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ProxyRestrictionType))
		soap_serialize_saml2__ProxyRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__ProxyRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ProxyRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ProxyRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ProxyRestrictionType **)soap_malloc(soap, sizeof(struct saml2__ProxyRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ProxyRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__OneTimeUseType))
		soap_serialize_saml2__OneTimeUseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, int id, struct saml2__OneTimeUseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__OneTimeUseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__OneTimeUseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_in_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__OneTimeUseType **)soap_malloc(soap, sizeof(struct saml2__OneTimeUseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__OneTimeUseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_get_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AudienceRestrictionType))
		soap_serialize_saml2__AudienceRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__AudienceRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AudienceRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AudienceRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AudienceRestrictionType **)soap_malloc(soap, sizeof(struct saml2__AudienceRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AudienceRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionAbstractType))
		soap_serialize_saml2__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml2__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml2__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationDataType))
		soap_serialize_saml2__SubjectConfirmationDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationDataType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationType))
		soap_serialize_saml2__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EncryptedElementType))
		soap_serialize_saml2__EncryptedElementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, int id, struct saml2__EncryptedElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EncryptedElementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EncryptedElementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_in_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EncryptedElementType **)soap_malloc(soap, sizeof(struct saml2__EncryptedElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EncryptedElementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_get_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__BaseIDAbstractType))
		soap_serialize_saml2__BaseIDAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, struct saml2__BaseIDAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__BaseIDAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__BaseIDAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__BaseIDAbstractType **)soap_malloc(soap, sizeof(struct saml2__BaseIDAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__BaseIDAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AssertionType))
		soap_serialize___saml2__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml2__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml2__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeStatementType))
		soap_serialize_saml2__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml2__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml2__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthzDecisionStatementType))
		soap_serialize_saml2__AuthzDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthzDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthzDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthzDecisionStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthzDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthzDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnStatementType))
		soap_serialize_saml2__AuthnStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthnStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthnStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__StatementAbstractType))
		soap_serialize_saml2__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml2__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml2__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AdviceType))
		soap_serialize_saml2__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, int id, struct saml2__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AdviceType **)soap_malloc(soap, sizeof(struct saml2__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionsType))
		soap_serialize_saml2__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, int id, struct saml2__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionsType **)soap_malloc(soap, sizeof(struct saml2__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectType))
		soap_serialize_saml2__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, int id, struct saml2__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectType **)soap_malloc(soap, sizeof(struct saml2__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__NameIDType))
		soap_serialize_saml2__NameIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, int id, struct saml2__NameIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__NameIDType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__NameIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_in_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__NameIDType **)soap_malloc(soap, sizeof(struct saml2__NameIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__NameIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__NameIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_get_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToxenc__EncryptedKeyType))
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToxenc__EncryptedKeyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_in_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType ***)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_get_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__ConfirmationMethod(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__ConfirmationMethod(soap, tag ? tag : "saml1:ConfirmationMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__Audience(soap, tag ? tag : "saml1:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AssertionIDReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__AssertionIDReference(soap, tag ? tag : "saml1:AssertionIDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeType))
		soap_serialize_saml1__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, int id, struct saml1__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeType **)soap_malloc(soap, sizeof(struct saml1__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__EvidenceType))
		soap_serialize_saml1__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, int id, struct saml1__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__EvidenceType **)soap_malloc(soap, sizeof(struct saml1__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ActionType))
		soap_serialize_saml1__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ActionType(struct soap *soap, const char *tag, int id, struct saml1__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ActionType **)soap_malloc(soap, sizeof(struct saml1__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorityBindingType))
		soap_serialize_saml1__AuthorityBindingType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, struct saml1__AuthorityBindingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorityBindingType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorityBindingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorityBindingType **)soap_malloc(soap, sizeof(struct saml1__AuthorityBindingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorityBindingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectLocalityType))
		soap_serialize_saml1__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml1__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml1__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectType))
		soap_serialize_saml1__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, int id, struct saml1__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectType **)soap_malloc(soap, sizeof(struct saml1__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_EvidenceType))
		soap_serialize___saml1__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml1__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml1__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectConfirmationType))
		soap_serialize_saml1__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml1__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml1__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__NameIdentifierType))
		soap_serialize_saml1__NameIdentifierType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, int id, struct saml1__NameIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__NameIdentifierType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__NameIdentifierType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_in_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__NameIdentifierType **)soap_malloc(soap, sizeof(struct saml1__NameIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__NameIdentifierType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__NameIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_get_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AdviceType))
		soap_serialize___saml1__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml1__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml1__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AssertionType))
		soap_serialize_saml1__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, int id, struct saml1__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml1__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AssertionType **)soap_malloc(soap, sizeof(struct saml1__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_ConditionsType))
		soap_serialize___saml1__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml1__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml1__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionAbstractType))
		soap_serialize_saml1__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml1__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml1__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__DoNotCacheConditionType))
		soap_serialize_saml1__DoNotCacheConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, struct saml1__DoNotCacheConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__DoNotCacheConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__DoNotCacheConditionType **)soap_malloc(soap, sizeof(struct saml1__DoNotCacheConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__DoNotCacheConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AudienceRestrictionConditionType))
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, struct saml1__AudienceRestrictionConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AudienceRestrictionConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AudienceRestrictionConditionType **)soap_malloc(soap, sizeof(struct saml1__AudienceRestrictionConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__Signature))
		soap_serialize__ds__Signature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__Signature(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__Signature, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__Signature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTo_ds__Signature(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__Signature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__Signature, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__Signature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AssertionType))
		soap_serialize___saml1__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml1__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml1__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeStatementType))
		soap_serialize_saml1__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml1__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml1__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType))
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthorizationDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorizationDecisionStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthorizationDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthenticationStatementType))
		soap_serialize_saml1__AuthenticationStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthenticationStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthenticationStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthenticationStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthenticationStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthenticationStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthenticationStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectStatementAbstractType))
		soap_serialize_saml1__SubjectStatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__SubjectStatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectStatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectStatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__SubjectStatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectStatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__StatementAbstractType))
		soap_serialize_saml1__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AdviceType))
		soap_serialize_saml1__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, int id, struct saml1__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AdviceType **)soap_malloc(soap, sizeof(struct saml1__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionsType))
		soap_serialize_saml1__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, int id, struct saml1__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionsType **)soap_malloc(soap, sizeof(struct saml1__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence))
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_malloc(soap, sizeof(struct __wsc__DerivedKeyTokenType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_get_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToULONG64(struct soap *soap, ULONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ULONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToULONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ULONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ULONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerToULONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ULONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ULONG64, sizeof(ULONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToULONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerToULONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__PropertiesType))
		soap_serialize_wsc__PropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, int id, struct wsc__PropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__PropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__PropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_in_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__PropertiesType **)soap_malloc(soap, sizeof(struct wsc__PropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__PropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_get_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeOpenEnumType(soap, tag ? tag : "wsc:FaultCodeOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsc__FaultCodeOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__SignatureValue(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__ds__SignatureValue(soap, tag ? tag : "ds:SignatureValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsse__EncodedString))
		soap_serialize_wsse__EncodedString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsse__EncodedString(struct soap *soap, const char *tag, int id, struct wsse__EncodedString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsse__EncodedString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsse__EncodedString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_in_PointerTowsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsse__EncodedString **)soap_malloc(soap, sizeof(struct wsse__EncodedString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsse__EncodedString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsse__EncodedString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_get_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetWarnings(struct soap *soap, _tempuri__GetWarnings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetWarnings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetWarnings(struct soap *soap, const char *tag, int id, _tempuri__GetWarnings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetWarnings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetWarnings ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetWarnings ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetWarnings(struct soap *soap, const char *tag, _tempuri__GetWarnings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetWarnings **)soap_malloc(soap, sizeof(_tempuri__GetWarnings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetWarnings *)soap_instantiate__tempuri__GetWarnings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetWarnings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetWarnings, sizeof(_tempuri__GetWarnings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetWarnings(struct soap *soap, _tempuri__GetWarnings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetWarnings(soap, tag ? tag : "tempuri:GetWarnings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetWarnings ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetWarnings(struct soap *soap, _tempuri__GetWarnings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__HasWarnings(struct soap *soap, _tempuri__HasWarnings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__HasWarnings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__HasWarnings(struct soap *soap, const char *tag, int id, _tempuri__HasWarnings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__HasWarnings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__HasWarnings ? type : NULL);
}

SOAP_FMAC3 _tempuri__HasWarnings ** SOAP_FMAC4 soap_in_PointerTo_tempuri__HasWarnings(struct soap *soap, const char *tag, _tempuri__HasWarnings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__HasWarnings **)soap_malloc(soap, sizeof(_tempuri__HasWarnings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__HasWarnings *)soap_instantiate__tempuri__HasWarnings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__HasWarnings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__HasWarnings, sizeof(_tempuri__HasWarnings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__HasWarnings(struct soap *soap, _tempuri__HasWarnings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__HasWarnings(soap, tag ? tag : "tempuri:HasWarnings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__HasWarnings ** SOAP_FMAC4 soap_get_PointerTo_tempuri__HasWarnings(struct soap *soap, _tempuri__HasWarnings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__HasWarnings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetErrors(struct soap *soap, _tempuri__GetErrors *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetErrors))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetErrors(struct soap *soap, const char *tag, int id, _tempuri__GetErrors *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetErrors, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetErrors ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetErrors ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetErrors(struct soap *soap, const char *tag, _tempuri__GetErrors **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetErrors **)soap_malloc(soap, sizeof(_tempuri__GetErrors *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetErrors *)soap_instantiate__tempuri__GetErrors(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetErrors **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetErrors, sizeof(_tempuri__GetErrors), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetErrors(struct soap *soap, _tempuri__GetErrors *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetErrors(soap, tag ? tag : "tempuri:GetErrors", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetErrors ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetErrors(struct soap *soap, _tempuri__GetErrors **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__HasErrors(struct soap *soap, _tempuri__HasErrors *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__HasErrors))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__HasErrors(struct soap *soap, const char *tag, int id, _tempuri__HasErrors *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__HasErrors, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__HasErrors ? type : NULL);
}

SOAP_FMAC3 _tempuri__HasErrors ** SOAP_FMAC4 soap_in_PointerTo_tempuri__HasErrors(struct soap *soap, const char *tag, _tempuri__HasErrors **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__HasErrors **)soap_malloc(soap, sizeof(_tempuri__HasErrors *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__HasErrors *)soap_instantiate__tempuri__HasErrors(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__HasErrors **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__HasErrors, sizeof(_tempuri__HasErrors), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__HasErrors(struct soap *soap, _tempuri__HasErrors *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__HasErrors(soap, tag ? tag : "tempuri:HasErrors", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__HasErrors ** SOAP_FMAC4 soap_get_PointerTo_tempuri__HasErrors(struct soap *soap, _tempuri__HasErrors **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__HasErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetMessage(struct soap *soap, _tempuri__GetMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetMessage(struct soap *soap, const char *tag, int id, _tempuri__GetMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetMessage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetMessage ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetMessage ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetMessage(struct soap *soap, const char *tag, _tempuri__GetMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetMessage **)soap_malloc(soap, sizeof(_tempuri__GetMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetMessage *)soap_instantiate__tempuri__GetMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetMessage, sizeof(_tempuri__GetMessage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetMessage(struct soap *soap, _tempuri__GetMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetMessage(soap, tag ? tag : "tempuri:GetMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetMessage ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetMessage(struct soap *soap, _tempuri__GetMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__HasMessage(struct soap *soap, _tempuri__HasMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__HasMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__HasMessage(struct soap *soap, const char *tag, int id, _tempuri__HasMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__HasMessage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__HasMessage ? type : NULL);
}

SOAP_FMAC3 _tempuri__HasMessage ** SOAP_FMAC4 soap_in_PointerTo_tempuri__HasMessage(struct soap *soap, const char *tag, _tempuri__HasMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__HasMessage **)soap_malloc(soap, sizeof(_tempuri__HasMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__HasMessage *)soap_instantiate__tempuri__HasMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__HasMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__HasMessage, sizeof(_tempuri__HasMessage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__HasMessage(struct soap *soap, _tempuri__HasMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__HasMessage(soap, tag ? tag : "tempuri:HasMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__HasMessage ** SOAP_FMAC4 soap_get_PointerTo_tempuri__HasMessage(struct soap *soap, _tempuri__HasMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__HasMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__IsSamplePlateTrayIn(struct soap *soap, _tempuri__IsSamplePlateTrayIn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__IsSamplePlateTrayIn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__IsSamplePlateTrayIn(struct soap *soap, const char *tag, int id, _tempuri__IsSamplePlateTrayIn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__IsSamplePlateTrayIn ? type : NULL);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayIn ** SOAP_FMAC4 soap_in_PointerTo_tempuri__IsSamplePlateTrayIn(struct soap *soap, const char *tag, _tempuri__IsSamplePlateTrayIn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__IsSamplePlateTrayIn **)soap_malloc(soap, sizeof(_tempuri__IsSamplePlateTrayIn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__IsSamplePlateTrayIn *)soap_instantiate__tempuri__IsSamplePlateTrayIn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__IsSamplePlateTrayIn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__IsSamplePlateTrayIn, sizeof(_tempuri__IsSamplePlateTrayIn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__IsSamplePlateTrayIn(struct soap *soap, _tempuri__IsSamplePlateTrayIn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__IsSamplePlateTrayIn(soap, tag ? tag : "tempuri:IsSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__IsSamplePlateTrayIn ** SOAP_FMAC4 soap_get_PointerTo_tempuri__IsSamplePlateTrayIn(struct soap *soap, _tempuri__IsSamplePlateTrayIn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__IsSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__IsChipDocked(struct soap *soap, _tempuri__IsChipDocked *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__IsChipDocked))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__IsChipDocked(struct soap *soap, const char *tag, int id, _tempuri__IsChipDocked *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__IsChipDocked, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__IsChipDocked ? type : NULL);
}

SOAP_FMAC3 _tempuri__IsChipDocked ** SOAP_FMAC4 soap_in_PointerTo_tempuri__IsChipDocked(struct soap *soap, const char *tag, _tempuri__IsChipDocked **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__IsChipDocked **)soap_malloc(soap, sizeof(_tempuri__IsChipDocked *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__IsChipDocked *)soap_instantiate__tempuri__IsChipDocked(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__IsChipDocked **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__IsChipDocked, sizeof(_tempuri__IsChipDocked), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__IsChipDocked(struct soap *soap, _tempuri__IsChipDocked *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__IsChipDocked(soap, tag ? tag : "tempuri:IsChipDocked", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__IsChipDocked ** SOAP_FMAC4 soap_get_PointerTo_tempuri__IsChipDocked(struct soap *soap, _tempuri__IsChipDocked **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__IsChipDocked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetOperationMode(struct soap *soap, _tempuri__GetOperationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetOperationMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetOperationMode(struct soap *soap, const char *tag, int id, _tempuri__GetOperationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetOperationMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetOperationMode ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetOperationMode ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetOperationMode(struct soap *soap, const char *tag, _tempuri__GetOperationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetOperationMode **)soap_malloc(soap, sizeof(_tempuri__GetOperationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetOperationMode *)soap_instantiate__tempuri__GetOperationMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetOperationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetOperationMode, sizeof(_tempuri__GetOperationMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetOperationMode(struct soap *soap, _tempuri__GetOperationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetOperationMode(soap, tag ? tag : "tempuri:GetOperationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetOperationMode ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetOperationMode(struct soap *soap, _tempuri__GetOperationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetOperationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__RunMaintenanceProcedure(struct soap *soap, _tempuri__RunMaintenanceProcedure *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__RunMaintenanceProcedure))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__RunMaintenanceProcedure(struct soap *soap, const char *tag, int id, _tempuri__RunMaintenanceProcedure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__RunMaintenanceProcedure, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__RunMaintenanceProcedure ? type : NULL);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedure ** SOAP_FMAC4 soap_in_PointerTo_tempuri__RunMaintenanceProcedure(struct soap *soap, const char *tag, _tempuri__RunMaintenanceProcedure **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__RunMaintenanceProcedure **)soap_malloc(soap, sizeof(_tempuri__RunMaintenanceProcedure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__RunMaintenanceProcedure *)soap_instantiate__tempuri__RunMaintenanceProcedure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__RunMaintenanceProcedure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__RunMaintenanceProcedure, sizeof(_tempuri__RunMaintenanceProcedure), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__RunMaintenanceProcedure(struct soap *soap, _tempuri__RunMaintenanceProcedure *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__RunMaintenanceProcedure(soap, tag ? tag : "tempuri:RunMaintenanceProcedure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__RunMaintenanceProcedure ** SOAP_FMAC4 soap_get_PointerTo_tempuri__RunMaintenanceProcedure(struct soap *soap, _tempuri__RunMaintenanceProcedure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__RunMaintenanceProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, _tempuri__GetNamesOfMaintenanceProcedures *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, int id, _tempuri__GetNamesOfMaintenanceProcedures *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProcedures ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, const char *tag, _tempuri__GetNamesOfMaintenanceProcedures **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNamesOfMaintenanceProcedures **)soap_malloc(soap, sizeof(_tempuri__GetNamesOfMaintenanceProcedures *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNamesOfMaintenanceProcedures *)soap_instantiate__tempuri__GetNamesOfMaintenanceProcedures(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNamesOfMaintenanceProcedures **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures, sizeof(_tempuri__GetNamesOfMaintenanceProcedures), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, _tempuri__GetNamesOfMaintenanceProcedures *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, tag ? tag : "tempuri:GetNamesOfMaintenanceProcedures", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNamesOfMaintenanceProcedures ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(struct soap *soap, _tempuri__GetNamesOfMaintenanceProcedures **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNamesOfMaintenanceProcedures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetStandbyAfterFinish(struct soap *soap, _tempuri__GetStandbyAfterFinish *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetStandbyAfterFinish))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetStandbyAfterFinish(struct soap *soap, const char *tag, int id, _tempuri__GetStandbyAfterFinish *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetStandbyAfterFinish, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetStandbyAfterFinish ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinish ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetStandbyAfterFinish(struct soap *soap, const char *tag, _tempuri__GetStandbyAfterFinish **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetStandbyAfterFinish **)soap_malloc(soap, sizeof(_tempuri__GetStandbyAfterFinish *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetStandbyAfterFinish *)soap_instantiate__tempuri__GetStandbyAfterFinish(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetStandbyAfterFinish **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetStandbyAfterFinish, sizeof(_tempuri__GetStandbyAfterFinish), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetStandbyAfterFinish(struct soap *soap, _tempuri__GetStandbyAfterFinish *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetStandbyAfterFinish(soap, tag ? tag : "tempuri:GetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetStandbyAfterFinish ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetStandbyAfterFinish(struct soap *soap, _tempuri__GetStandbyAfterFinish **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__SetStandbyAfterFinish(struct soap *soap, _tempuri__SetStandbyAfterFinish *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__SetStandbyAfterFinish))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__SetStandbyAfterFinish(struct soap *soap, const char *tag, int id, _tempuri__SetStandbyAfterFinish *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__SetStandbyAfterFinish, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__SetStandbyAfterFinish ? type : NULL);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinish ** SOAP_FMAC4 soap_in_PointerTo_tempuri__SetStandbyAfterFinish(struct soap *soap, const char *tag, _tempuri__SetStandbyAfterFinish **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__SetStandbyAfterFinish **)soap_malloc(soap, sizeof(_tempuri__SetStandbyAfterFinish *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__SetStandbyAfterFinish *)soap_instantiate__tempuri__SetStandbyAfterFinish(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__SetStandbyAfterFinish **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__SetStandbyAfterFinish, sizeof(_tempuri__SetStandbyAfterFinish), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__SetStandbyAfterFinish(struct soap *soap, _tempuri__SetStandbyAfterFinish *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__SetStandbyAfterFinish(soap, tag ? tag : "tempuri:SetStandbyAfterFinish", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__SetStandbyAfterFinish ** SOAP_FMAC4 soap_get_PointerTo_tempuri__SetStandbyAfterFinish(struct soap *soap, _tempuri__SetStandbyAfterFinish **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__SetStandbyAfterFinish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LeaveStandby(struct soap *soap, _tempuri__LeaveStandby *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LeaveStandby))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LeaveStandby(struct soap *soap, const char *tag, int id, _tempuri__LeaveStandby *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LeaveStandby, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LeaveStandby ? type : NULL);
}

SOAP_FMAC3 _tempuri__LeaveStandby ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LeaveStandby(struct soap *soap, const char *tag, _tempuri__LeaveStandby **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LeaveStandby **)soap_malloc(soap, sizeof(_tempuri__LeaveStandby *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LeaveStandby *)soap_instantiate__tempuri__LeaveStandby(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LeaveStandby **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LeaveStandby, sizeof(_tempuri__LeaveStandby), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LeaveStandby(struct soap *soap, _tempuri__LeaveStandby *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LeaveStandby(soap, tag ? tag : "tempuri:LeaveStandby", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LeaveStandby ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LeaveStandby(struct soap *soap, _tempuri__LeaveStandby **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LeaveStandby(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AbortScript(struct soap *soap, _tempuri__AbortScript *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AbortScript))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AbortScript(struct soap *soap, const char *tag, int id, _tempuri__AbortScript *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AbortScript, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AbortScript ? type : NULL);
}

SOAP_FMAC3 _tempuri__AbortScript ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AbortScript(struct soap *soap, const char *tag, _tempuri__AbortScript **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AbortScript **)soap_malloc(soap, sizeof(_tempuri__AbortScript *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AbortScript *)soap_instantiate__tempuri__AbortScript(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AbortScript **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AbortScript, sizeof(_tempuri__AbortScript), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AbortScript(struct soap *soap, _tempuri__AbortScript *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AbortScript(soap, tag ? tag : "tempuri:AbortScript", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AbortScript ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AbortScript(struct soap *soap, _tempuri__AbortScript **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AbortScript(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ResetRunset(struct soap *soap, _tempuri__ResetRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ResetRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ResetRunset(struct soap *soap, const char *tag, int id, _tempuri__ResetRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ResetRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ResetRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__ResetRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ResetRunset(struct soap *soap, const char *tag, _tempuri__ResetRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ResetRunset **)soap_malloc(soap, sizeof(_tempuri__ResetRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ResetRunset *)soap_instantiate__tempuri__ResetRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ResetRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ResetRunset, sizeof(_tempuri__ResetRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ResetRunset(struct soap *soap, _tempuri__ResetRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ResetRunset(soap, tag ? tag : "tempuri:ResetRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ResetRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ResetRunset(struct soap *soap, _tempuri__ResetRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ResetRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ResumeRunset(struct soap *soap, _tempuri__ResumeRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ResumeRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ResumeRunset(struct soap *soap, const char *tag, int id, _tempuri__ResumeRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ResumeRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ResumeRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__ResumeRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ResumeRunset(struct soap *soap, const char *tag, _tempuri__ResumeRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ResumeRunset **)soap_malloc(soap, sizeof(_tempuri__ResumeRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ResumeRunset *)soap_instantiate__tempuri__ResumeRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ResumeRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ResumeRunset, sizeof(_tempuri__ResumeRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ResumeRunset(struct soap *soap, _tempuri__ResumeRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ResumeRunset(soap, tag ? tag : "tempuri:ResumeRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ResumeRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ResumeRunset(struct soap *soap, _tempuri__ResumeRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ResumeRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__PauseRunsetAfter(struct soap *soap, _tempuri__PauseRunsetAfter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__PauseRunsetAfter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__PauseRunsetAfter(struct soap *soap, const char *tag, int id, _tempuri__PauseRunsetAfter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__PauseRunsetAfter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__PauseRunsetAfter ? type : NULL);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfter ** SOAP_FMAC4 soap_in_PointerTo_tempuri__PauseRunsetAfter(struct soap *soap, const char *tag, _tempuri__PauseRunsetAfter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__PauseRunsetAfter **)soap_malloc(soap, sizeof(_tempuri__PauseRunsetAfter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__PauseRunsetAfter *)soap_instantiate__tempuri__PauseRunsetAfter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__PauseRunsetAfter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__PauseRunsetAfter, sizeof(_tempuri__PauseRunsetAfter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__PauseRunsetAfter(struct soap *soap, _tempuri__PauseRunsetAfter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__PauseRunsetAfter(soap, tag ? tag : "tempuri:PauseRunsetAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__PauseRunsetAfter ** SOAP_FMAC4 soap_get_PointerTo_tempuri__PauseRunsetAfter(struct soap *soap, _tempuri__PauseRunsetAfter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__PauseRunsetAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__StartSelectedRunsetFrom(struct soap *soap, _tempuri__StartSelectedRunsetFrom *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__StartSelectedRunsetFrom))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__StartSelectedRunsetFrom(struct soap *soap, const char *tag, int id, _tempuri__StartSelectedRunsetFrom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__StartSelectedRunsetFrom ? type : NULL);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFrom ** SOAP_FMAC4 soap_in_PointerTo_tempuri__StartSelectedRunsetFrom(struct soap *soap, const char *tag, _tempuri__StartSelectedRunsetFrom **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__StartSelectedRunsetFrom **)soap_malloc(soap, sizeof(_tempuri__StartSelectedRunsetFrom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__StartSelectedRunsetFrom *)soap_instantiate__tempuri__StartSelectedRunsetFrom(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__StartSelectedRunsetFrom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__StartSelectedRunsetFrom, sizeof(_tempuri__StartSelectedRunsetFrom), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__StartSelectedRunsetFrom(struct soap *soap, _tempuri__StartSelectedRunsetFrom *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__StartSelectedRunsetFrom(soap, tag ? tag : "tempuri:StartSelectedRunsetFrom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__StartSelectedRunsetFrom ** SOAP_FMAC4 soap_get_PointerTo_tempuri__StartSelectedRunsetFrom(struct soap *soap, _tempuri__StartSelectedRunsetFrom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__StartSelectedRunsetFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__StartSelectedRunset(struct soap *soap, _tempuri__StartSelectedRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__StartSelectedRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__StartSelectedRunset(struct soap *soap, const char *tag, int id, _tempuri__StartSelectedRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__StartSelectedRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__StartSelectedRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__StartSelectedRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__StartSelectedRunset(struct soap *soap, const char *tag, _tempuri__StartSelectedRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__StartSelectedRunset **)soap_malloc(soap, sizeof(_tempuri__StartSelectedRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__StartSelectedRunset *)soap_instantiate__tempuri__StartSelectedRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__StartSelectedRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__StartSelectedRunset, sizeof(_tempuri__StartSelectedRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__StartSelectedRunset(struct soap *soap, _tempuri__StartSelectedRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__StartSelectedRunset(soap, tag ? tag : "tempuri:StartSelectedRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__StartSelectedRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__StartSelectedRunset(struct soap *soap, _tempuri__StartSelectedRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__StartSelectedRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayIn(struct soap *soap, _tempuri__MoveSamplePlateTrayIn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, int id, _tempuri__MoveSamplePlateTrayIn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__MoveSamplePlateTrayIn ? type : NULL);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayIn ** SOAP_FMAC4 soap_in_PointerTo_tempuri__MoveSamplePlateTrayIn(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayIn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__MoveSamplePlateTrayIn **)soap_malloc(soap, sizeof(_tempuri__MoveSamplePlateTrayIn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__MoveSamplePlateTrayIn *)soap_instantiate__tempuri__MoveSamplePlateTrayIn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayIn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__MoveSamplePlateTrayIn, sizeof(_tempuri__MoveSamplePlateTrayIn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__MoveSamplePlateTrayIn(struct soap *soap, _tempuri__MoveSamplePlateTrayIn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, tag ? tag : "tempuri:MoveSamplePlateTrayIn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayIn ** SOAP_FMAC4 soap_get_PointerTo_tempuri__MoveSamplePlateTrayIn(struct soap *soap, _tempuri__MoveSamplePlateTrayIn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__MoveSamplePlateTrayIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__MoveSamplePlateTrayOut(struct soap *soap, _tempuri__MoveSamplePlateTrayOut *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, int id, _tempuri__MoveSamplePlateTrayOut *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__MoveSamplePlateTrayOut ? type : NULL);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOut ** SOAP_FMAC4 soap_in_PointerTo_tempuri__MoveSamplePlateTrayOut(struct soap *soap, const char *tag, _tempuri__MoveSamplePlateTrayOut **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__MoveSamplePlateTrayOut **)soap_malloc(soap, sizeof(_tempuri__MoveSamplePlateTrayOut *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__MoveSamplePlateTrayOut *)soap_instantiate__tempuri__MoveSamplePlateTrayOut(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__MoveSamplePlateTrayOut **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__MoveSamplePlateTrayOut, sizeof(_tempuri__MoveSamplePlateTrayOut), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__MoveSamplePlateTrayOut(struct soap *soap, _tempuri__MoveSamplePlateTrayOut *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, tag ? tag : "tempuri:MoveSamplePlateTrayOut", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__MoveSamplePlateTrayOut ** SOAP_FMAC4 soap_get_PointerTo_tempuri__MoveSamplePlateTrayOut(struct soap *soap, _tempuri__MoveSamplePlateTrayOut **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__MoveSamplePlateTrayOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetCurrentSamplePlateId(struct soap *soap, _tempuri__GetCurrentSamplePlateId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetCurrentSamplePlateId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetCurrentSamplePlateId(struct soap *soap, const char *tag, int id, _tempuri__GetCurrentSamplePlateId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetCurrentSamplePlateId ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateId ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetCurrentSamplePlateId(struct soap *soap, const char *tag, _tempuri__GetCurrentSamplePlateId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetCurrentSamplePlateId **)soap_malloc(soap, sizeof(_tempuri__GetCurrentSamplePlateId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetCurrentSamplePlateId *)soap_instantiate__tempuri__GetCurrentSamplePlateId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetCurrentSamplePlateId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetCurrentSamplePlateId, sizeof(_tempuri__GetCurrentSamplePlateId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetCurrentSamplePlateId(struct soap *soap, _tempuri__GetCurrentSamplePlateId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetCurrentSamplePlateId(soap, tag ? tag : "tempuri:GetCurrentSamplePlateId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetCurrentSamplePlateId ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetCurrentSamplePlateId(struct soap *soap, _tempuri__GetCurrentSamplePlateId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetCurrentSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetSamplePlateId(struct soap *soap, _tempuri__GetSamplePlateId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetSamplePlateId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetSamplePlateId(struct soap *soap, const char *tag, int id, _tempuri__GetSamplePlateId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetSamplePlateId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetSamplePlateId ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetSamplePlateId ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetSamplePlateId(struct soap *soap, const char *tag, _tempuri__GetSamplePlateId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetSamplePlateId **)soap_malloc(soap, sizeof(_tempuri__GetSamplePlateId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetSamplePlateId *)soap_instantiate__tempuri__GetSamplePlateId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetSamplePlateId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetSamplePlateId, sizeof(_tempuri__GetSamplePlateId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetSamplePlateId(struct soap *soap, _tempuri__GetSamplePlateId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetSamplePlateId(soap, tag ? tag : "tempuri:GetSamplePlateId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetSamplePlateId ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetSamplePlateId(struct soap *soap, _tempuri__GetSamplePlateId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__SetSamplePlateId(struct soap *soap, _tempuri__SetSamplePlateId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__SetSamplePlateId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__SetSamplePlateId(struct soap *soap, const char *tag, int id, _tempuri__SetSamplePlateId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__SetSamplePlateId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__SetSamplePlateId ? type : NULL);
}

SOAP_FMAC3 _tempuri__SetSamplePlateId ** SOAP_FMAC4 soap_in_PointerTo_tempuri__SetSamplePlateId(struct soap *soap, const char *tag, _tempuri__SetSamplePlateId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__SetSamplePlateId **)soap_malloc(soap, sizeof(_tempuri__SetSamplePlateId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__SetSamplePlateId *)soap_instantiate__tempuri__SetSamplePlateId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__SetSamplePlateId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__SetSamplePlateId, sizeof(_tempuri__SetSamplePlateId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__SetSamplePlateId(struct soap *soap, _tempuri__SetSamplePlateId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__SetSamplePlateId(soap, tag ? tag : "tempuri:SetSamplePlateId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__SetSamplePlateId ** SOAP_FMAC4 soap_get_PointerTo_tempuri__SetSamplePlateId(struct soap *soap, _tempuri__SetSamplePlateId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__SetSamplePlateId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__CreateRunset(struct soap *soap, _tempuri__CreateRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__CreateRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__CreateRunset(struct soap *soap, const char *tag, int id, _tempuri__CreateRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__CreateRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__CreateRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__CreateRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__CreateRunset(struct soap *soap, const char *tag, _tempuri__CreateRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__CreateRunset **)soap_malloc(soap, sizeof(_tempuri__CreateRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__CreateRunset *)soap_instantiate__tempuri__CreateRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__CreateRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__CreateRunset, sizeof(_tempuri__CreateRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__CreateRunset(struct soap *soap, _tempuri__CreateRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__CreateRunset(soap, tag ? tag : "tempuri:CreateRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__CreateRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__CreateRunset(struct soap *soap, _tempuri__CreateRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__CreateRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__SelectRunset(struct soap *soap, _tempuri__SelectRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__SelectRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__SelectRunset(struct soap *soap, const char *tag, int id, _tempuri__SelectRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__SelectRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__SelectRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__SelectRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__SelectRunset(struct soap *soap, const char *tag, _tempuri__SelectRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__SelectRunset **)soap_malloc(soap, sizeof(_tempuri__SelectRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__SelectRunset *)soap_instantiate__tempuri__SelectRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__SelectRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__SelectRunset, sizeof(_tempuri__SelectRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__SelectRunset(struct soap *soap, _tempuri__SelectRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__SelectRunset(soap, tag ? tag : "tempuri:SelectRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__SelectRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__SelectRunset(struct soap *soap, _tempuri__SelectRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__SelectRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__SelectMethod(struct soap *soap, _tempuri__SelectMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__SelectMethod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__SelectMethod(struct soap *soap, const char *tag, int id, _tempuri__SelectMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__SelectMethod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__SelectMethod ? type : NULL);
}

SOAP_FMAC3 _tempuri__SelectMethod ** SOAP_FMAC4 soap_in_PointerTo_tempuri__SelectMethod(struct soap *soap, const char *tag, _tempuri__SelectMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__SelectMethod **)soap_malloc(soap, sizeof(_tempuri__SelectMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__SelectMethod *)soap_instantiate__tempuri__SelectMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__SelectMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__SelectMethod, sizeof(_tempuri__SelectMethod), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__SelectMethod(struct soap *soap, _tempuri__SelectMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__SelectMethod(soap, tag ? tag : "tempuri:SelectMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__SelectMethod ** SOAP_FMAC4 soap_get_PointerTo_tempuri__SelectMethod(struct soap *soap, _tempuri__SelectMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__SelectMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetMethodNamesOfRunset(struct soap *soap, _tempuri__GetMethodNamesOfRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetMethodNamesOfRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetMethodNamesOfRunset(struct soap *soap, const char *tag, int id, _tempuri__GetMethodNamesOfRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetMethodNamesOfRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetMethodNamesOfRunset(struct soap *soap, const char *tag, _tempuri__GetMethodNamesOfRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetMethodNamesOfRunset **)soap_malloc(soap, sizeof(_tempuri__GetMethodNamesOfRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetMethodNamesOfRunset *)soap_instantiate__tempuri__GetMethodNamesOfRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetMethodNamesOfRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetMethodNamesOfRunset, sizeof(_tempuri__GetMethodNamesOfRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetMethodNamesOfRunset(struct soap *soap, _tempuri__GetMethodNamesOfRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetMethodNamesOfRunset(soap, tag ? tag : "tempuri:GetMethodNamesOfRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetMethodNamesOfRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetMethodNamesOfRunset(struct soap *soap, _tempuri__GetMethodNamesOfRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetMethodNamesOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypeOfRunset(struct soap *soap, _tempuri__GetAssayTypeOfRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypeOfRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypeOfRunset(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypeOfRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypeOfRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypeOfRunset(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypeOfRunset **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypeOfRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypeOfRunset *)soap_instantiate__tempuri__GetAssayTypeOfRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypeOfRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypeOfRunset, sizeof(_tempuri__GetAssayTypeOfRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypeOfRunset(struct soap *soap, _tempuri__GetAssayTypeOfRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfRunset(soap, tag ? tag : "tempuri:GetAssayTypeOfRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypeOfRunset(struct soap *soap, _tempuri__GetAssayTypeOfRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypeOfRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, _tempuri__GetAssayTypeOfCurrentRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypeOfCurrentRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypeOfCurrentRunset **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypeOfCurrentRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypeOfCurrentRunset *)soap_instantiate__tempuri__GetAssayTypeOfCurrentRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset, sizeof(_tempuri__GetAssayTypeOfCurrentRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, _tempuri__GetAssayTypeOfCurrentRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(struct soap *soap, _tempuri__GetAssayTypeOfCurrentRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNameOfCurrentRunset(struct soap *soap, _tempuri__GetNameOfCurrentRunset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNameOfCurrentRunset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNameOfCurrentRunset(struct soap *soap, const char *tag, int id, _tempuri__GetNameOfCurrentRunset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNameOfCurrentRunset ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunset ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNameOfCurrentRunset(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentRunset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNameOfCurrentRunset **)soap_malloc(soap, sizeof(_tempuri__GetNameOfCurrentRunset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNameOfCurrentRunset *)soap_instantiate__tempuri__GetNameOfCurrentRunset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNameOfCurrentRunset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNameOfCurrentRunset, sizeof(_tempuri__GetNameOfCurrentRunset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNameOfCurrentRunset(struct soap *soap, _tempuri__GetNameOfCurrentRunset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentRunset(soap, tag ? tag : "tempuri:GetNameOfCurrentRunset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentRunset ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNameOfCurrentRunset(struct soap *soap, _tempuri__GetNameOfCurrentRunset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNameOfCurrentRunset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, _tempuri__GetAssayTypesOfAllRunsets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypesOfAllRunsets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsets ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllRunsets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypesOfAllRunsets **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypesOfAllRunsets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypesOfAllRunsets *)soap_instantiate__tempuri__GetAssayTypesOfAllRunsets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllRunsets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets, sizeof(_tempuri__GetAssayTypesOfAllRunsets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, _tempuri__GetAssayTypesOfAllRunsets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, tag ? tag : "tempuri:GetAssayTypesOfAllRunsets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllRunsets ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypesOfAllRunsets(struct soap *soap, _tempuri__GetAssayTypesOfAllRunsets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypesOfAllRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, _tempuri__GetNamesOfRunsetsOfAssayType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, int id, _tempuri__GetNamesOfRunsetsOfAssayType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayType ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsetsOfAssayType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNamesOfRunsetsOfAssayType **)soap_malloc(soap, sizeof(_tempuri__GetNamesOfRunsetsOfAssayType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNamesOfRunsetsOfAssayType *)soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNamesOfRunsetsOfAssayType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType, sizeof(_tempuri__GetNamesOfRunsetsOfAssayType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, _tempuri__GetNamesOfRunsetsOfAssayType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, tag ? tag : "tempuri:GetNamesOfRunsetsOfAssayType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsetsOfAssayType ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(struct soap *soap, _tempuri__GetNamesOfRunsetsOfAssayType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNamesOfRunsets(struct soap *soap, _tempuri__GetNamesOfRunsets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNamesOfRunsets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNamesOfRunsets(struct soap *soap, const char *tag, int id, _tempuri__GetNamesOfRunsets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNamesOfRunsets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNamesOfRunsets ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsets ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNamesOfRunsets(struct soap *soap, const char *tag, _tempuri__GetNamesOfRunsets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNamesOfRunsets **)soap_malloc(soap, sizeof(_tempuri__GetNamesOfRunsets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNamesOfRunsets *)soap_instantiate__tempuri__GetNamesOfRunsets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNamesOfRunsets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNamesOfRunsets, sizeof(_tempuri__GetNamesOfRunsets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNamesOfRunsets(struct soap *soap, _tempuri__GetNamesOfRunsets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNamesOfRunsets(soap, tag ? tag : "tempuri:GetNamesOfRunsets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNamesOfRunsets ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNamesOfRunsets(struct soap *soap, _tempuri__GetNamesOfRunsets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNamesOfRunsets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypeOfMethod(struct soap *soap, _tempuri__GetAssayTypeOfMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypeOfMethod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypeOfMethod(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypeOfMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypeOfMethod ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethod ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypeOfMethod(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypeOfMethod **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypeOfMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypeOfMethod *)soap_instantiate__tempuri__GetAssayTypeOfMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypeOfMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypeOfMethod, sizeof(_tempuri__GetAssayTypeOfMethod), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypeOfMethod(struct soap *soap, _tempuri__GetAssayTypeOfMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfMethod(soap, tag ? tag : "tempuri:GetAssayTypeOfMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfMethod ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypeOfMethod(struct soap *soap, _tempuri__GetAssayTypeOfMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypeOfMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, _tempuri__GetAssayTypeOfCurrentMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypeOfCurrentMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethod ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, const char *tag, _tempuri__GetAssayTypeOfCurrentMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypeOfCurrentMethod **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypeOfCurrentMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypeOfCurrentMethod *)soap_instantiate__tempuri__GetAssayTypeOfCurrentMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypeOfCurrentMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod, sizeof(_tempuri__GetAssayTypeOfCurrentMethod), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, _tempuri__GetAssayTypeOfCurrentMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, tag ? tag : "tempuri:GetAssayTypeOfCurrentMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypeOfCurrentMethod ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(struct soap *soap, _tempuri__GetAssayTypeOfCurrentMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypeOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNameOfCurrentMethod(struct soap *soap, _tempuri__GetNameOfCurrentMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNameOfCurrentMethod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNameOfCurrentMethod(struct soap *soap, const char *tag, int id, _tempuri__GetNameOfCurrentMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNameOfCurrentMethod ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethod ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNameOfCurrentMethod(struct soap *soap, const char *tag, _tempuri__GetNameOfCurrentMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNameOfCurrentMethod **)soap_malloc(soap, sizeof(_tempuri__GetNameOfCurrentMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNameOfCurrentMethod *)soap_instantiate__tempuri__GetNameOfCurrentMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNameOfCurrentMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNameOfCurrentMethod, sizeof(_tempuri__GetNameOfCurrentMethod), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNameOfCurrentMethod(struct soap *soap, _tempuri__GetNameOfCurrentMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNameOfCurrentMethod(soap, tag ? tag : "tempuri:GetNameOfCurrentMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNameOfCurrentMethod ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNameOfCurrentMethod(struct soap *soap, _tempuri__GetNameOfCurrentMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNameOfCurrentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetAssayTypesOfAllMethods(struct soap *soap, _tempuri__GetAssayTypesOfAllMethods *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, int id, _tempuri__GetAssayTypesOfAllMethods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethods ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetAssayTypesOfAllMethods(struct soap *soap, const char *tag, _tempuri__GetAssayTypesOfAllMethods **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetAssayTypesOfAllMethods **)soap_malloc(soap, sizeof(_tempuri__GetAssayTypesOfAllMethods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetAssayTypesOfAllMethods *)soap_instantiate__tempuri__GetAssayTypesOfAllMethods(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetAssayTypesOfAllMethods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods, sizeof(_tempuri__GetAssayTypesOfAllMethods), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetAssayTypesOfAllMethods(struct soap *soap, _tempuri__GetAssayTypesOfAllMethods *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, tag ? tag : "tempuri:GetAssayTypesOfAllMethods", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetAssayTypesOfAllMethods ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetAssayTypesOfAllMethods(struct soap *soap, _tempuri__GetAssayTypesOfAllMethods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetAssayTypesOfAllMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, _tempuri__GetNamesOfMethodsOfAssayType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, int id, _tempuri__GetNamesOfMethodsOfAssayType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayType ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethodsOfAssayType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNamesOfMethodsOfAssayType **)soap_malloc(soap, sizeof(_tempuri__GetNamesOfMethodsOfAssayType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNamesOfMethodsOfAssayType *)soap_instantiate__tempuri__GetNamesOfMethodsOfAssayType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNamesOfMethodsOfAssayType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType, sizeof(_tempuri__GetNamesOfMethodsOfAssayType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, _tempuri__GetNamesOfMethodsOfAssayType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, tag ? tag : "tempuri:GetNamesOfMethodsOfAssayType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethodsOfAssayType ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(struct soap *soap, _tempuri__GetNamesOfMethodsOfAssayType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNamesOfMethodsOfAssayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetNamesOfMethods(struct soap *soap, _tempuri__GetNamesOfMethods *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetNamesOfMethods))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetNamesOfMethods(struct soap *soap, const char *tag, int id, _tempuri__GetNamesOfMethods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetNamesOfMethods, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetNamesOfMethods ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethods ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetNamesOfMethods(struct soap *soap, const char *tag, _tempuri__GetNamesOfMethods **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetNamesOfMethods **)soap_malloc(soap, sizeof(_tempuri__GetNamesOfMethods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetNamesOfMethods *)soap_instantiate__tempuri__GetNamesOfMethods(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetNamesOfMethods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetNamesOfMethods, sizeof(_tempuri__GetNamesOfMethods), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetNamesOfMethods(struct soap *soap, _tempuri__GetNamesOfMethods *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetNamesOfMethods(soap, tag ? tag : "tempuri:GetNamesOfMethods", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetNamesOfMethods ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetNamesOfMethods(struct soap *soap, _tempuri__GetNamesOfMethods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetNamesOfMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_arr__ArrayOfstring))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToarr__ArrayOfstring(struct soap *soap, const char *tag, int id, arr__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_arr__ArrayOfstring, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_arr__ArrayOfstring ? type : NULL);
}

SOAP_FMAC3 arr__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToarr__ArrayOfstring(struct soap *soap, const char *tag, arr__ArrayOfstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (arr__ArrayOfstring **)soap_malloc(soap, sizeof(arr__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (arr__ArrayOfstring *)soap_instantiate_arr__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (arr__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToarr__ArrayOfstring(soap, tag ? tag : "arr:ArrayOfstring", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 arr__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToarr__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
