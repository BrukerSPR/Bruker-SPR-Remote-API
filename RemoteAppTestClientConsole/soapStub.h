/* soapStub.h
   Generated by gSOAP 2.8.89 for spr.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/Imports"
#define SOAP_NAMESPACE_OF_tempuri	"http://tempuri.org/"
#define SOAP_NAMESPACE_OF_arr	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"
#define SOAP_NAMESPACE_OF_wsu	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
#define SOAP_NAMESPACE_OF_wsse	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"
#define SOAP_NAMESPACE_OF_wst	"http://docs.oasis-open.org/ws-sx/ws-trust/200512"
#define SOAP_WSRM_2005
#define SOAP_NAMESPACE_OF_wsrm	"http://schemas.xmlsoap.org/ws/2005/02/rm"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20889
# error "GSOAP VERSION 20889 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsu.h:67 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (345)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:101 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (348)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:64 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (422)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:113 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (452)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:119 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (533)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/* wsa5.h:95 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (617)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:103 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (618)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:253 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (635)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* wsrm5.h:135 */
#ifndef SOAP_TYPE_wsrm__FaultCodes
#define SOAP_TYPE_wsrm__FaultCodes (773)
/* wsrm:FaultCodes */
enum wsrm__FaultCodes {
	wsrm__SequenceTerminated = 0,
	wsrm__UnknownSequence = 1,
	wsrm__InvalidAcknowledgement = 2,
	wsrm__MessageNumberRollover = 3,
	wsrm__LastMessageNumberExceeded = 4,
	wsrm__CreateSequenceRefused = 5,
	wsrm__WSRMRequired = 6
};
#endif

/* wsrm5.h:149 */
#ifndef SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType
#define SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType (774)
/* wsrm:IncompleteSequenceBehaviorType */
enum wsrm__IncompleteSequenceBehaviorType {
	DiscardEntireSequence = 0,
	DiscardFollowingFirstGap = 1,
	NoDiscard = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (770)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _tempuri__GetNamesOfMethods;	/* spr.h:163 */
class _tempuri__GetNamesOfMethodsResponse;	/* spr.h:165 */
class _tempuri__GetNamesOfMethodsOfAssayType;	/* spr.h:167 */
class _tempuri__GetNamesOfMethodsOfAssayTypeResponse;	/* spr.h:169 */
class _tempuri__GetAssayTypesOfAllMethods;	/* spr.h:171 */
class _tempuri__GetAssayTypesOfAllMethodsResponse;	/* spr.h:173 */
class _tempuri__GetNameOfCurrentMethod;	/* spr.h:175 */
class _tempuri__GetNameOfCurrentMethodResponse;	/* spr.h:177 */
class _tempuri__GetAssayTypeOfCurrentMethod;	/* spr.h:179 */
class _tempuri__GetAssayTypeOfCurrentMethodResponse;	/* spr.h:181 */
class _tempuri__GetAssayTypeOfMethod;	/* spr.h:183 */
class _tempuri__GetAssayTypeOfMethodResponse;	/* spr.h:185 */
class _tempuri__GetNamesOfRunsets;	/* spr.h:187 */
class _tempuri__GetNamesOfRunsetsResponse;	/* spr.h:189 */
class _tempuri__GetNamesOfRunsetsOfAssayType;	/* spr.h:191 */
class _tempuri__GetNamesOfRunsetsOfAssayTypeResponse;	/* spr.h:193 */
class _tempuri__GetAssayTypesOfAllRunsets;	/* spr.h:195 */
class _tempuri__GetAssayTypesOfAllRunsetsResponse;	/* spr.h:197 */
class _tempuri__GetNameOfCurrentRunset;	/* spr.h:199 */
class _tempuri__GetNameOfCurrentRunsetResponse;	/* spr.h:201 */
class _tempuri__GetAssayTypeOfCurrentRunset;	/* spr.h:203 */
class _tempuri__GetAssayTypeOfCurrentRunsetResponse;	/* spr.h:205 */
class _tempuri__GetAssayTypeOfRunset;	/* spr.h:207 */
class _tempuri__GetAssayTypeOfRunsetResponse;	/* spr.h:209 */
class _tempuri__GetMethodNamesOfRunset;	/* spr.h:211 */
class _tempuri__GetMethodNamesOfRunsetResponse;	/* spr.h:213 */
class _tempuri__SelectMethod;	/* spr.h:215 */
class _tempuri__SelectMethodResponse;	/* spr.h:217 */
class _tempuri__SelectRunset;	/* spr.h:219 */
class _tempuri__SelectRunsetResponse;	/* spr.h:221 */
class _tempuri__CreateRunset;	/* spr.h:223 */
class _tempuri__CreateRunsetResponse;	/* spr.h:225 */
class _tempuri__SetSamplePlateId;	/* spr.h:227 */
class _tempuri__SetSamplePlateIdResponse;	/* spr.h:229 */
class _tempuri__GetSamplePlateId;	/* spr.h:231 */
class _tempuri__GetSamplePlateIdResponse;	/* spr.h:233 */
class _tempuri__GetCurrentSamplePlateId;	/* spr.h:235 */
class _tempuri__GetCurrentSamplePlateIdResponse;	/* spr.h:237 */
class _tempuri__MoveSamplePlateTrayOut;	/* spr.h:239 */
class _tempuri__MoveSamplePlateTrayOutResponse;	/* spr.h:241 */
class _tempuri__MoveSamplePlateTrayIn;	/* spr.h:243 */
class _tempuri__MoveSamplePlateTrayInResponse;	/* spr.h:245 */
class _tempuri__StartSelectedRunset;	/* spr.h:247 */
class _tempuri__StartSelectedRunsetResponse;	/* spr.h:249 */
class _tempuri__StartSelectedRunsetFrom;	/* spr.h:251 */
class _tempuri__StartSelectedRunsetFromResponse;	/* spr.h:253 */
class _tempuri__PauseRunsetAfter;	/* spr.h:255 */
class _tempuri__PauseRunsetAfterResponse;	/* spr.h:257 */
class _tempuri__ResumeRunset;	/* spr.h:259 */
class _tempuri__ResumeRunsetResponse;	/* spr.h:261 */
class _tempuri__ResetRunset;	/* spr.h:263 */
class _tempuri__ResetRunsetResponse;	/* spr.h:265 */
class _tempuri__AbortScript;	/* spr.h:267 */
class _tempuri__AbortScriptResponse;	/* spr.h:269 */
class _tempuri__LeaveStandby;	/* spr.h:271 */
class _tempuri__LeaveStandbyResponse;	/* spr.h:273 */
class _tempuri__SetStandbyAfterFinish;	/* spr.h:275 */
class _tempuri__SetStandbyAfterFinishResponse;	/* spr.h:277 */
class _tempuri__GetStandbyAfterFinish;	/* spr.h:279 */
class _tempuri__GetStandbyAfterFinishResponse;	/* spr.h:281 */
class _tempuri__GetNamesOfMaintenanceProcedures;	/* spr.h:283 */
class _tempuri__GetNamesOfMaintenanceProceduresResponse;	/* spr.h:285 */
class _tempuri__RunMaintenanceProcedure;	/* spr.h:287 */
class _tempuri__RunMaintenanceProcedureResponse;	/* spr.h:289 */
class _tempuri__GetOperationMode;	/* spr.h:291 */
class _tempuri__GetOperationModeResponse;	/* spr.h:293 */
class _tempuri__IsChipDocked;	/* spr.h:295 */
class _tempuri__IsChipDockedResponse;	/* spr.h:297 */
class _tempuri__IsSamplePlateTrayIn;	/* spr.h:299 */
class _tempuri__IsSamplePlateTrayInResponse;	/* spr.h:301 */
class _tempuri__HasMessage;	/* spr.h:303 */
class _tempuri__HasMessageResponse;	/* spr.h:305 */
class _tempuri__GetMessage;	/* spr.h:307 */
class _tempuri__GetMessageResponse;	/* spr.h:309 */
class _tempuri__HasErrors;	/* spr.h:311 */
class _tempuri__HasErrorsResponse;	/* spr.h:313 */
class _tempuri__GetErrors;	/* spr.h:315 */
class _tempuri__GetErrorsResponse;	/* spr.h:317 */
class _tempuri__HasWarnings;	/* spr.h:319 */
class _tempuri__HasWarningsResponse;	/* spr.h:321 */
class _tempuri__GetWarnings;	/* spr.h:323 */
class _tempuri__GetWarningsResponse;	/* spr.h:325 */
class arr__ArrayOfstring;	/* spr.h:327 */
struct __name__GetNamesOfMethods;	/* spr.h:2612 */
struct __name__GetNamesOfMethodsOfAssayType;	/* spr.h:2682 */
struct __name__GetAssayTypesOfAllMethods;	/* spr.h:2752 */
struct __name__GetNameOfCurrentMethod;	/* spr.h:2822 */
struct __name__GetAssayTypeOfCurrentMethod;	/* spr.h:2892 */
struct __name__GetAssayTypeOfMethod;	/* spr.h:2962 */
struct __name__GetNamesOfRunsets;	/* spr.h:3032 */
struct __name__GetNamesOfRunsetsOfAssayType;	/* spr.h:3102 */
struct __name__GetAssayTypesOfAllRunsets;	/* spr.h:3172 */
struct __name__GetNameOfCurrentRunset;	/* spr.h:3242 */
struct __name__GetAssayTypeOfCurrentRunset;	/* spr.h:3312 */
struct __name__GetAssayTypeOfRunset;	/* spr.h:3382 */
struct __name__GetMethodNamesOfRunset;	/* spr.h:3452 */
struct __name__SelectMethod;	/* spr.h:3522 */
struct __name__SelectRunset;	/* spr.h:3592 */
struct __name__CreateRunset;	/* spr.h:3662 */
struct __name__SetSamplePlateId;	/* spr.h:3732 */
struct __name__GetSamplePlateId;	/* spr.h:3802 */
struct __name__GetCurrentSamplePlateId;	/* spr.h:3872 */
struct __name__MoveSamplePlateTrayOut;	/* spr.h:3942 */
struct __name__MoveSamplePlateTrayIn;	/* spr.h:4012 */
struct __name__StartSelectedRunset;	/* spr.h:4082 */
struct __name__StartSelectedRunsetFrom;	/* spr.h:4152 */
struct __name__PauseRunsetAfter;	/* spr.h:4222 */
struct __name__ResumeRunset;	/* spr.h:4292 */
struct __name__ResetRunset;	/* spr.h:4362 */
struct __name__AbortScript;	/* spr.h:4432 */
struct __name__LeaveStandby;	/* spr.h:4502 */
struct __name__SetStandbyAfterFinish;	/* spr.h:4572 */
struct __name__GetStandbyAfterFinish;	/* spr.h:4642 */
struct __name__GetNamesOfMaintenanceProcedures;	/* spr.h:4712 */
struct __name__RunMaintenanceProcedure;	/* spr.h:4782 */
struct __name__GetOperationMode;	/* spr.h:4852 */
struct __name__IsChipDocked;	/* spr.h:4922 */
struct __name__IsSamplePlateTrayIn;	/* spr.h:4992 */
struct __name__HasMessage;	/* spr.h:5062 */
struct __name__GetMessage;	/* spr.h:5132 */
struct __name__HasErrors;	/* spr.h:5202 */
struct __name__GetErrors;	/* spr.h:5272 */
struct __name__HasWarnings;	/* spr.h:5342 */
struct __name__GetWarnings;	/* spr.h:5412 */
struct __name2__GetNamesOfMethods;	/* spr.h:5540 */
struct __name2__GetNamesOfMethodsOfAssayType;	/* spr.h:5652 */
struct __name2__GetAssayTypesOfAllMethods;	/* spr.h:5764 */
struct __name2__GetNameOfCurrentMethod;	/* spr.h:5876 */
struct __name2__GetAssayTypeOfCurrentMethod;	/* spr.h:5988 */
struct __name2__GetAssayTypeOfMethod;	/* spr.h:6100 */
struct __name2__GetNamesOfRunsets;	/* spr.h:6212 */
struct __name2__GetNamesOfRunsetsOfAssayType;	/* spr.h:6324 */
struct __name2__GetAssayTypesOfAllRunsets;	/* spr.h:6436 */
struct __name2__GetNameOfCurrentRunset;	/* spr.h:6548 */
struct __name2__GetAssayTypeOfCurrentRunset;	/* spr.h:6660 */
struct __name2__GetAssayTypeOfRunset;	/* spr.h:6772 */
struct __name2__GetMethodNamesOfRunset;	/* spr.h:6884 */
struct __name2__SelectMethod;	/* spr.h:6996 */
struct __name2__SelectRunset;	/* spr.h:7108 */
struct __name2__CreateRunset;	/* spr.h:7220 */
struct __name2__SetSamplePlateId;	/* spr.h:7332 */
struct __name2__GetSamplePlateId;	/* spr.h:7444 */
struct __name2__GetCurrentSamplePlateId;	/* spr.h:7556 */
struct __name2__MoveSamplePlateTrayOut;	/* spr.h:7668 */
struct __name2__MoveSamplePlateTrayIn;	/* spr.h:7780 */
struct __name2__StartSelectedRunset;	/* spr.h:7892 */
struct __name2__StartSelectedRunsetFrom;	/* spr.h:8004 */
struct __name2__PauseRunsetAfter;	/* spr.h:8116 */
struct __name2__ResumeRunset;	/* spr.h:8228 */
struct __name2__ResetRunset;	/* spr.h:8340 */
struct __name2__AbortScript;	/* spr.h:8452 */
struct __name2__LeaveStandby;	/* spr.h:8564 */
struct __name2__SetStandbyAfterFinish;	/* spr.h:8676 */
struct __name2__GetStandbyAfterFinish;	/* spr.h:8788 */
struct __name2__GetNamesOfMaintenanceProcedures;	/* spr.h:8900 */
struct __name2__RunMaintenanceProcedure;	/* spr.h:9012 */
struct __name2__GetOperationMode;	/* spr.h:9124 */
struct __name2__IsChipDocked;	/* spr.h:9236 */
struct __name2__IsSamplePlateTrayIn;	/* spr.h:9348 */
struct __name2__HasMessage;	/* spr.h:9460 */
struct __name2__GetMessage;	/* spr.h:9572 */
struct __name2__HasErrors;	/* spr.h:9684 */
struct __name2__GetErrors;	/* spr.h:9796 */
struct __name2__HasWarnings;	/* spr.h:9908 */
struct __name2__GetWarnings;	/* spr.h:10020 */
struct _wsu__Timestamp;	/* wsu.h:77 */
struct wsse__EncodedString;	/* wsse.h:58 */
struct _wsse__UsernameToken;	/* wsse.h:129 */
struct _wsse__BinarySecurityToken;	/* wsse.h:140 */
struct _wsse__Reference;	/* wsse.h:150 */
struct _wsse__Embedded;	/* wsse.h:158 */
struct _wsse__KeyIdentifier;	/* wsse.h:167 */
struct _wsse__SecurityTokenReference;	/* wsse.h:177 */
struct ds__SignatureType;	/* ds.h:46 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:73 */
struct ds__KeyInfoType;	/* ds.h:48 */
struct ds__SignedInfoType;	/* ds.h:46 */
struct ds__CanonicalizationMethodType;	/* ds.h:59 */
struct ds__SignatureMethodType;	/* ds.h:62 */
struct ds__ReferenceType;	/* ds.h:65 */
struct ds__TransformsType;	/* ds.h:68 */
struct ds__DigestMethodType;	/* ds.h:79 */
struct ds__KeyValueType;	/* ds.h:84 */
struct ds__RetrievalMethodType;	/* ds.h:85 */
struct ds__X509DataType;	/* wsse.h:180 */
struct ds__X509IssuerSerialType;	/* ds.h:102 */
struct ds__DSAKeyValueType;	/* ds.h:123 */
struct ds__RSAKeyValueType;	/* ds.h:126 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:236 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:89 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:122 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:118 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:111 */
struct wsc__PropertiesType;	/* wsc.h:115 */
struct __saml1__union_AssertionType;	/* saml1.h:147 */
struct saml1__AssertionType;	/* saml1.h:62 */
struct __saml1__union_ConditionsType;	/* saml1.h:190 */
struct saml1__ConditionsType;	/* saml1.h:64 */
struct saml1__ConditionAbstractType;	/* saml1.h:66 */
struct __saml1__union_AdviceType;	/* saml1.h:232 */
struct saml1__AdviceType;	/* saml1.h:72 */
struct saml1__StatementAbstractType;	/* saml1.h:74 */
struct saml1__SubjectType;	/* saml1.h:78 */
struct saml1__SubjectConfirmationType;	/* saml1.h:82 */
struct saml1__SubjectLocalityType;	/* saml1.h:86 */
struct saml1__AuthorityBindingType;	/* saml1.h:88 */
struct __saml1__union_EvidenceType;	/* saml1.h:354 */
struct saml1__EvidenceType;	/* saml1.h:94 */
struct saml1__AttributeDesignatorType;	/* saml1.h:98 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:68 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:70 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:76 */
struct saml1__NameIdentifierType;	/* saml1.h:80 */
struct saml1__ActionType;	/* saml1.h:92 */
struct saml1__AttributeType;	/* saml1.h:100 */
struct saml1__AuthenticationStatementType;	/* saml1.h:84 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:90 */
struct saml1__AttributeStatementType;	/* saml1.h:96 */
struct saml2__BaseIDAbstractType;	/* saml2.h:62 */
struct saml2__EncryptedElementType;	/* saml2.h:66 */
struct __saml2__union_AssertionType;	/* saml2.h:197 */
struct saml2__AssertionType;	/* saml2.h:68 */
struct saml2__SubjectType;	/* saml2.h:70 */
struct saml2__SubjectConfirmationType;	/* saml2.h:72 */
struct __saml2__union_ConditionsType;	/* saml2.h:290 */
struct saml2__ConditionsType;	/* saml2.h:78 */
struct saml2__ConditionAbstractType;	/* saml2.h:80 */
struct __saml2__union_AdviceType;	/* saml2.h:334 */
struct saml2__AdviceType;	/* saml2.h:88 */
struct saml2__StatementAbstractType;	/* saml2.h:90 */
struct saml2__SubjectLocalityType;	/* saml2.h:94 */
struct saml2__AuthnContextType;	/* saml2.h:96 */
struct __saml2__union_EvidenceType;	/* saml2.h:432 */
struct saml2__EvidenceType;	/* saml2.h:102 */
struct saml2__AttributeType;	/* saml2.h:106 */
struct saml2__NameIDType;	/* saml2.h:64 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:74 */
struct saml2__AudienceRestrictionType;	/* saml2.h:82 */
struct saml2__OneTimeUseType;	/* saml2.h:84 */
struct saml2__ProxyRestrictionType;	/* saml2.h:86 */
struct saml2__AuthnStatementType;	/* saml2.h:92 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:98 */
struct saml2__ActionType;	/* saml2.h:100 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:674 */
struct saml2__AttributeStatementType;	/* saml2.h:104 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:76 */
struct _wsse__Security;	/* wsse.h:194 */
struct _wsse__Password;	/* wsse.h:130 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:64 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:67 */
struct wsa5__MetadataType;	/* wsa5.h:70 */
struct wsa5__ProblemActionType;	/* wsa5.h:85 */
struct wsa5__RelatesToType;	/* wsa5.h:73 */
struct chan__ChannelInstanceType;	/* wsa5.h:259 */
struct _wsp__AppliesTo_;	/* wsp_appliesto.h:6 */
struct wst__RequestedSecurityTokenType;	/* wst.h:65 */
struct wst__EntropyType;	/* wst.h:77 */
struct wst__AuthenticatorType;	/* wst.h:114 */
struct wst__RequestSecurityTokenType;	/* wst.h:58 */
struct wst__RequestSecurityTokenResponseType;	/* wst.h:60 */
struct wst__ClaimsType;	/* wst.h:74 */
struct wst__LifetimeType;	/* wst.h:81 */
struct wst__RequestSecurityTokenCollectionType;	/* wst.h:83 */
struct wst__RequestSecurityTokenResponseCollectionType;	/* wst.h:85 */
struct wst__RequestedReferenceType;	/* wst.h:87 */
struct wst__RequestedProofTokenType;	/* wst.h:89 */
struct wst__RenewTargetType;	/* wst.h:91 */
struct wst__AllowPostdatingType;	/* wst.h:93 */
struct wst__RenewingType;	/* wst.h:95 */
struct wst__CancelTargetType;	/* wst.h:97 */
struct wst__RequestedTokenCancelledType;	/* wst.h:99 */
struct wst__ValidateTargetType;	/* wst.h:101 */
struct wst__StatusType;	/* wst.h:103 */
struct wst__SignChallengeType;	/* wst.h:105 */
struct wst__RequestKETType;	/* wst.h:109 */
struct wst__KeyExchangeTokenType;	/* wst.h:111 */
struct wst__OnBehalfOfType;	/* wst.h:118 */
struct wst__EncryptionType;	/* wst.h:120 */
struct wst__ProofEncryptionType;	/* wst.h:122 */
struct wst__UseKeyType;	/* wst.h:124 */
struct wst__DelegateToType;	/* wst.h:126 */
struct wst__ParticipantsType;	/* wst.h:128 */
struct wst__ParticipantType;	/* wst.h:130 */
struct wst__BinarySecretType;	/* wst.h:72 */
struct wst__BinaryExchangeType;	/* wst.h:107 */
struct __wst__RequestSecurityToken;	/* wstx.h:74 */
struct __wst__RequestSecurityTokenResponse;	/* wstx.h:89 */
struct __wst__RequestSecurityTokenCollection;	/* wstx.h:104 */
struct wsrm__SequenceType;	/* wsrm5.h:68 */
struct wsrm__AckRequestedType;	/* wsrm5.h:71 */
struct wsrm__SequenceFaultType;	/* wsrm5.h:74 */
struct wsrm__CreateSequenceType;	/* wsrm5.h:80 */
struct wsrm__CreateSequenceResponseType;	/* wsrm5.h:83 */
struct wsrm__CloseSequenceType;	/* wsrm5.h:86 */
struct wsrm__CloseSequenceResponseType;	/* wsrm5.h:89 */
struct wsrm__TerminateSequenceType;	/* wsrm5.h:92 */
struct wsrm__TerminateSequenceResponseType;	/* wsrm5.h:95 */
struct wsrm__OfferType;	/* wsrm5.h:98 */
struct wsrm__AcceptType;	/* wsrm5.h:101 */
struct _wsrm__SequenceAcknowledgement_Final;	/* wsrm5.h:391 */
struct _wsrm__SequenceAcknowledgement_AcknowledgementRange;	/* wsrm5.h:400 */
struct _wsrm__SequenceAcknowledgement_None;	/* wsrm5.h:414 */
struct _wsrm__SequenceAcknowledgement;	/* wsrm5.h:104 */
struct _wsrm__UsesSequenceSTR;	/* wsrm5.h:117 */
struct _wsrm__UsesSequenceSSL;	/* wsrm5.h:120 */
struct __wsrm__CreateSequence;	/* wsrx5.h:78 */
struct __wsrm__CloseSequence;	/* wsrx5.h:91 */
struct __wsrm__TerminateSequence;	/* wsrx5.h:104 */
struct __wsrm__CreateSequenceResponse;	/* wsrx5.h:114 */
struct __wsrm__CloseSequenceResponse;	/* wsrx5.h:124 */
struct __wsrm__TerminateSequenceResponse;	/* wsrx5.h:134 */
struct __wsrm__SequenceAcknowledgement;	/* wsrx5.h:144 */
struct __wsrm__AckRequested;	/* wsrx5.h:154 */
struct __wsrm__LastMessage;	/* wsrx5.h:164 */

/* spr.h:163 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethods
#define SOAP_TYPE__tempuri__GetNamesOfMethods (8)
/* complex XML schema type 'tempuri:GetNamesOfMethods': */
class SOAP_CMAC _tempuri__GetNamesOfMethods {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMethods
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMethods; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMethods, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMethods *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMethods); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMethods() : soap() { }
        virtual ~_tempuri__GetNamesOfMethods() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMethods(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:165 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsResponse
#define SOAP_TYPE__tempuri__GetNamesOfMethodsResponse (9)
/* complex XML schema type 'tempuri:GetNamesOfMethodsResponse': */
class SOAP_CMAC _tempuri__GetNamesOfMethodsResponse {
      public:
        /// Optional element 'tempuri:GetNamesOfMethodsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetNamesOfMethodsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMethodsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMethodsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMethodsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMethodsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMethodsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMethodsResponse() : GetNamesOfMethodsResult(), soap() { }
        virtual ~_tempuri__GetNamesOfMethodsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMethodsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMethodsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:167 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType
#define SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType (10)
/* complex XML schema type 'tempuri:GetNamesOfMethodsOfAssayType': */
class SOAP_CMAC _tempuri__GetNamesOfMethodsOfAssayType {
      public:
        /// Optional element 'tempuri:assayType' of XML schema type 'xsd:string'
        std::string *assayType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMethodsOfAssayType, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMethodsOfAssayType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMethodsOfAssayType); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMethodsOfAssayType() : assayType(), soap() { }
        virtual ~_tempuri__GetNamesOfMethodsOfAssayType() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMethodsOfAssayType(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:169 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse
#define SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse (11)
/* complex XML schema type 'tempuri:GetNamesOfMethodsOfAssayTypeResponse': */
class SOAP_CMAC _tempuri__GetNamesOfMethodsOfAssayTypeResponse {
      public:
        /// Optional element 'tempuri:GetNamesOfMethodsOfAssayTypeResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetNamesOfMethodsOfAssayTypeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMethodsOfAssayTypeResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMethodsOfAssayTypeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMethodsOfAssayTypeResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMethodsOfAssayTypeResponse() : GetNamesOfMethodsOfAssayTypeResult(), soap() { }
        virtual ~_tempuri__GetNamesOfMethodsOfAssayTypeResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMethodsOfAssayTypeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMethodsOfAssayTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:171 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods (12)
/* complex XML schema type 'tempuri:GetAssayTypesOfAllMethods': */
class SOAP_CMAC _tempuri__GetAssayTypesOfAllMethods {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypesOfAllMethods, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypesOfAllMethods *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypesOfAllMethods); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypesOfAllMethods() : soap() { }
        virtual ~_tempuri__GetAssayTypesOfAllMethods() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypesOfAllMethods(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:173 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse (13)
/* complex XML schema type 'tempuri:GetAssayTypesOfAllMethodsResponse': */
class SOAP_CMAC _tempuri__GetAssayTypesOfAllMethodsResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypesOfAllMethodsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetAssayTypesOfAllMethodsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypesOfAllMethodsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypesOfAllMethodsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypesOfAllMethodsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypesOfAllMethodsResponse() : GetAssayTypesOfAllMethodsResult(), soap() { }
        virtual ~_tempuri__GetAssayTypesOfAllMethodsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypesOfAllMethodsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllMethodsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:175 */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentMethod
#define SOAP_TYPE__tempuri__GetNameOfCurrentMethod (14)
/* complex XML schema type 'tempuri:GetNameOfCurrentMethod': */
class SOAP_CMAC _tempuri__GetNameOfCurrentMethod {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNameOfCurrentMethod
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNameOfCurrentMethod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNameOfCurrentMethod, default initialized and not managed by a soap context
        virtual _tempuri__GetNameOfCurrentMethod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNameOfCurrentMethod); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNameOfCurrentMethod() : soap() { }
        virtual ~_tempuri__GetNameOfCurrentMethod() { }
        /// Friend allocator used by soap_new__tempuri__GetNameOfCurrentMethod(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:177 */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse
#define SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse (15)
/* complex XML schema type 'tempuri:GetNameOfCurrentMethodResponse': */
class SOAP_CMAC _tempuri__GetNameOfCurrentMethodResponse {
      public:
        /// Optional element 'tempuri:GetNameOfCurrentMethodResult' of XML schema type 'xsd:string'
        std::string *GetNameOfCurrentMethodResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNameOfCurrentMethodResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNameOfCurrentMethodResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNameOfCurrentMethodResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNameOfCurrentMethodResponse() : GetNameOfCurrentMethodResult(), soap() { }
        virtual ~_tempuri__GetNameOfCurrentMethodResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNameOfCurrentMethodResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNameOfCurrentMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentMethodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:179 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod (16)
/* complex XML schema type 'tempuri:GetAssayTypeOfCurrentMethod': */
class SOAP_CMAC _tempuri__GetAssayTypeOfCurrentMethod {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfCurrentMethod, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfCurrentMethod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfCurrentMethod); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfCurrentMethod() : soap() { }
        virtual ~_tempuri__GetAssayTypeOfCurrentMethod() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfCurrentMethod(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:181 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse (17)
/* complex XML schema type 'tempuri:GetAssayTypeOfCurrentMethodResponse': */
class SOAP_CMAC _tempuri__GetAssayTypeOfCurrentMethodResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypeOfCurrentMethodResult' of XML schema type 'xsd:string'
        std::string *GetAssayTypeOfCurrentMethodResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfCurrentMethodResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfCurrentMethodResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfCurrentMethodResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfCurrentMethodResponse() : GetAssayTypeOfCurrentMethodResult(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfCurrentMethodResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentMethodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:183 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfMethod
#define SOAP_TYPE__tempuri__GetAssayTypeOfMethod (18)
/* complex XML schema type 'tempuri:GetAssayTypeOfMethod': */
class SOAP_CMAC _tempuri__GetAssayTypeOfMethod {
      public:
        /// Optional element 'tempuri:methodName' of XML schema type 'xsd:string'
        std::string *methodName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfMethod
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfMethod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfMethod, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfMethod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfMethod); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfMethod() : methodName(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfMethod() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfMethod(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:185 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse (19)
/* complex XML schema type 'tempuri:GetAssayTypeOfMethodResponse': */
class SOAP_CMAC _tempuri__GetAssayTypeOfMethodResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypeOfMethodResult' of XML schema type 'xsd:string'
        std::string *GetAssayTypeOfMethodResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfMethodResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfMethodResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfMethodResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfMethodResponse() : GetAssayTypeOfMethodResult(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfMethodResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfMethodResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfMethodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:187 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsets
#define SOAP_TYPE__tempuri__GetNamesOfRunsets (20)
/* complex XML schema type 'tempuri:GetNamesOfRunsets': */
class SOAP_CMAC _tempuri__GetNamesOfRunsets {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfRunsets
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfRunsets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfRunsets, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfRunsets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfRunsets); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfRunsets() : soap() { }
        virtual ~_tempuri__GetNamesOfRunsets() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfRunsets(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:189 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse (21)
/* complex XML schema type 'tempuri:GetNamesOfRunsetsResponse': */
class SOAP_CMAC _tempuri__GetNamesOfRunsetsResponse {
      public:
        /// Optional element 'tempuri:GetNamesOfRunsetsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetNamesOfRunsetsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfRunsetsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfRunsetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfRunsetsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfRunsetsResponse() : GetNamesOfRunsetsResult(), soap() { }
        virtual ~_tempuri__GetNamesOfRunsetsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfRunsetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfRunsetsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:191 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType (22)
/* complex XML schema type 'tempuri:GetNamesOfRunsetsOfAssayType': */
class SOAP_CMAC _tempuri__GetNamesOfRunsetsOfAssayType {
      public:
        /// Optional element 'tempuri:assayType' of XML schema type 'xsd:string'
        std::string *assayType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfRunsetsOfAssayType, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfRunsetsOfAssayType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfRunsetsOfAssayType); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfRunsetsOfAssayType() : assayType(), soap() { }
        virtual ~_tempuri__GetNamesOfRunsetsOfAssayType() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfRunsetsOfAssayType(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:193 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse (23)
/* complex XML schema type 'tempuri:GetNamesOfRunsetsOfAssayTypeResponse': */
class SOAP_CMAC _tempuri__GetNamesOfRunsetsOfAssayTypeResponse {
      public:
        /// Optional element 'tempuri:GetNamesOfRunsetsOfAssayTypeResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetNamesOfRunsetsOfAssayTypeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfRunsetsOfAssayTypeResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfRunsetsOfAssayTypeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfRunsetsOfAssayTypeResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfRunsetsOfAssayTypeResponse() : GetNamesOfRunsetsOfAssayTypeResult(), soap() { }
        virtual ~_tempuri__GetNamesOfRunsetsOfAssayTypeResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfRunsetsOfAssayTypeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfRunsetsOfAssayTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:195 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets (24)
/* complex XML schema type 'tempuri:GetAssayTypesOfAllRunsets': */
class SOAP_CMAC _tempuri__GetAssayTypesOfAllRunsets {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypesOfAllRunsets, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypesOfAllRunsets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypesOfAllRunsets); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypesOfAllRunsets() : soap() { }
        virtual ~_tempuri__GetAssayTypesOfAllRunsets() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypesOfAllRunsets(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:197 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse (25)
/* complex XML schema type 'tempuri:GetAssayTypesOfAllRunsetsResponse': */
class SOAP_CMAC _tempuri__GetAssayTypesOfAllRunsetsResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypesOfAllRunsetsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetAssayTypesOfAllRunsetsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypesOfAllRunsetsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypesOfAllRunsetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypesOfAllRunsetsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypesOfAllRunsetsResponse() : GetAssayTypesOfAllRunsetsResult(), soap() { }
        virtual ~_tempuri__GetAssayTypesOfAllRunsetsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypesOfAllRunsetsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypesOfAllRunsetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:199 */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentRunset
#define SOAP_TYPE__tempuri__GetNameOfCurrentRunset (26)
/* complex XML schema type 'tempuri:GetNameOfCurrentRunset': */
class SOAP_CMAC _tempuri__GetNameOfCurrentRunset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNameOfCurrentRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNameOfCurrentRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNameOfCurrentRunset, default initialized and not managed by a soap context
        virtual _tempuri__GetNameOfCurrentRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNameOfCurrentRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNameOfCurrentRunset() : soap() { }
        virtual ~_tempuri__GetNameOfCurrentRunset() { }
        /// Friend allocator used by soap_new__tempuri__GetNameOfCurrentRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:201 */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse
#define SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse (27)
/* complex XML schema type 'tempuri:GetNameOfCurrentRunsetResponse': */
class SOAP_CMAC _tempuri__GetNameOfCurrentRunsetResponse {
      public:
        /// Optional element 'tempuri:GetNameOfCurrentRunsetResult' of XML schema type 'xsd:string'
        std::string *GetNameOfCurrentRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNameOfCurrentRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNameOfCurrentRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNameOfCurrentRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNameOfCurrentRunsetResponse() : GetNameOfCurrentRunsetResult(), soap() { }
        virtual ~_tempuri__GetNameOfCurrentRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNameOfCurrentRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNameOfCurrentRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNameOfCurrentRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:203 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset (28)
/* complex XML schema type 'tempuri:GetAssayTypeOfCurrentRunset': */
class SOAP_CMAC _tempuri__GetAssayTypeOfCurrentRunset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfCurrentRunset, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfCurrentRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfCurrentRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfCurrentRunset() : soap() { }
        virtual ~_tempuri__GetAssayTypeOfCurrentRunset() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfCurrentRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:205 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse (29)
/* complex XML schema type 'tempuri:GetAssayTypeOfCurrentRunsetResponse': */
class SOAP_CMAC _tempuri__GetAssayTypeOfCurrentRunsetResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypeOfCurrentRunsetResult' of XML schema type 'xsd:string'
        std::string *GetAssayTypeOfCurrentRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfCurrentRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfCurrentRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfCurrentRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfCurrentRunsetResponse() : GetAssayTypeOfCurrentRunsetResult(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfCurrentRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfCurrentRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfCurrentRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:207 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfRunset
#define SOAP_TYPE__tempuri__GetAssayTypeOfRunset (30)
/* complex XML schema type 'tempuri:GetAssayTypeOfRunset': */
class SOAP_CMAC _tempuri__GetAssayTypeOfRunset {
      public:
        /// Optional element 'tempuri:runsetName' of XML schema type 'xsd:string'
        std::string *runsetName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfRunset, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfRunset() : runsetName(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfRunset() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:209 */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse (31)
/* complex XML schema type 'tempuri:GetAssayTypeOfRunsetResponse': */
class SOAP_CMAC _tempuri__GetAssayTypeOfRunsetResponse {
      public:
        /// Optional element 'tempuri:GetAssayTypeOfRunsetResult' of XML schema type 'xsd:string'
        std::string *GetAssayTypeOfRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetAssayTypeOfRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetAssayTypeOfRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetAssayTypeOfRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetAssayTypeOfRunsetResponse() : GetAssayTypeOfRunsetResult(), soap() { }
        virtual ~_tempuri__GetAssayTypeOfRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetAssayTypeOfRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetAssayTypeOfRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetAssayTypeOfRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:211 */
#ifndef SOAP_TYPE__tempuri__GetMethodNamesOfRunset
#define SOAP_TYPE__tempuri__GetMethodNamesOfRunset (32)
/* complex XML schema type 'tempuri:GetMethodNamesOfRunset': */
class SOAP_CMAC _tempuri__GetMethodNamesOfRunset {
      public:
        /// Optional element 'tempuri:runsetName' of XML schema type 'xsd:string'
        std::string *runsetName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetMethodNamesOfRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetMethodNamesOfRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetMethodNamesOfRunset, default initialized and not managed by a soap context
        virtual _tempuri__GetMethodNamesOfRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetMethodNamesOfRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__GetMethodNamesOfRunset() : runsetName(), soap() { }
        virtual ~_tempuri__GetMethodNamesOfRunset() { }
        /// Friend allocator used by soap_new__tempuri__GetMethodNamesOfRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate__tempuri__GetMethodNamesOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:213 */
#ifndef SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse
#define SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse (33)
/* complex XML schema type 'tempuri:GetMethodNamesOfRunsetResponse': */
class SOAP_CMAC _tempuri__GetMethodNamesOfRunsetResponse {
      public:
        /// Optional element 'tempuri:GetMethodNamesOfRunsetResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetMethodNamesOfRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetMethodNamesOfRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetMethodNamesOfRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetMethodNamesOfRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetMethodNamesOfRunsetResponse() : GetMethodNamesOfRunsetResult(), soap() { }
        virtual ~_tempuri__GetMethodNamesOfRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetMethodNamesOfRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetMethodNamesOfRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetMethodNamesOfRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:215 */
#ifndef SOAP_TYPE__tempuri__SelectMethod
#define SOAP_TYPE__tempuri__SelectMethod (34)
/* complex XML schema type 'tempuri:SelectMethod': */
class SOAP_CMAC _tempuri__SelectMethod {
      public:
        /// Optional element 'tempuri:methodName' of XML schema type 'xsd:string'
        std::string *methodName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SelectMethod
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SelectMethod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SelectMethod, default initialized and not managed by a soap context
        virtual _tempuri__SelectMethod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SelectMethod); }
      public:
        /// Constructor with default initializations
        _tempuri__SelectMethod() : methodName(), soap() { }
        virtual ~_tempuri__SelectMethod() { }
        /// Friend allocator used by soap_new__tempuri__SelectMethod(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SelectMethod * SOAP_FMAC2 soap_instantiate__tempuri__SelectMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:217 */
#ifndef SOAP_TYPE__tempuri__SelectMethodResponse
#define SOAP_TYPE__tempuri__SelectMethodResponse (35)
/* complex XML schema type 'tempuri:SelectMethodResponse': */
class SOAP_CMAC _tempuri__SelectMethodResponse {
      public:
        /// Optional element 'tempuri:SelectMethodResult' of XML schema type 'xsd:boolean'
        bool *SelectMethodResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SelectMethodResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SelectMethodResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SelectMethodResponse, default initialized and not managed by a soap context
        virtual _tempuri__SelectMethodResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SelectMethodResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__SelectMethodResponse() : SelectMethodResult(), soap() { }
        virtual ~_tempuri__SelectMethodResponse() { }
        /// Friend allocator used by soap_new__tempuri__SelectMethodResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SelectMethodResponse * SOAP_FMAC2 soap_instantiate__tempuri__SelectMethodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:219 */
#ifndef SOAP_TYPE__tempuri__SelectRunset
#define SOAP_TYPE__tempuri__SelectRunset (36)
/* complex XML schema type 'tempuri:SelectRunset': */
class SOAP_CMAC _tempuri__SelectRunset {
      public:
        /// Optional element 'tempuri:runsetName' of XML schema type 'xsd:string'
        std::string *runsetName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SelectRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SelectRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SelectRunset, default initialized and not managed by a soap context
        virtual _tempuri__SelectRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SelectRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__SelectRunset() : runsetName(), soap() { }
        virtual ~_tempuri__SelectRunset() { }
        /// Friend allocator used by soap_new__tempuri__SelectRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SelectRunset * SOAP_FMAC2 soap_instantiate__tempuri__SelectRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:221 */
#ifndef SOAP_TYPE__tempuri__SelectRunsetResponse
#define SOAP_TYPE__tempuri__SelectRunsetResponse (37)
/* complex XML schema type 'tempuri:SelectRunsetResponse': */
class SOAP_CMAC _tempuri__SelectRunsetResponse {
      public:
        /// Optional element 'tempuri:SelectRunsetResult' of XML schema type 'xsd:boolean'
        bool *SelectRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SelectRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SelectRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SelectRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__SelectRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SelectRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__SelectRunsetResponse() : SelectRunsetResult(), soap() { }
        virtual ~_tempuri__SelectRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__SelectRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SelectRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__SelectRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:223 */
#ifndef SOAP_TYPE__tempuri__CreateRunset
#define SOAP_TYPE__tempuri__CreateRunset (38)
/* complex XML schema type 'tempuri:CreateRunset': */
class SOAP_CMAC _tempuri__CreateRunset {
      public:
        /// Optional element 'tempuri:methodNames' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *methodNames;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__CreateRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__CreateRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__CreateRunset, default initialized and not managed by a soap context
        virtual _tempuri__CreateRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__CreateRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__CreateRunset() : methodNames(), soap() { }
        virtual ~_tempuri__CreateRunset() { }
        /// Friend allocator used by soap_new__tempuri__CreateRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__CreateRunset * SOAP_FMAC2 soap_instantiate__tempuri__CreateRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:225 */
#ifndef SOAP_TYPE__tempuri__CreateRunsetResponse
#define SOAP_TYPE__tempuri__CreateRunsetResponse (39)
/* complex XML schema type 'tempuri:CreateRunsetResponse': */
class SOAP_CMAC _tempuri__CreateRunsetResponse {
      public:
        /// Optional element 'tempuri:CreateRunsetResult' of XML schema type 'xsd:boolean'
        bool *CreateRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__CreateRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__CreateRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__CreateRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__CreateRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__CreateRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__CreateRunsetResponse() : CreateRunsetResult(), soap() { }
        virtual ~_tempuri__CreateRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__CreateRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__CreateRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__CreateRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:227 */
#ifndef SOAP_TYPE__tempuri__SetSamplePlateId
#define SOAP_TYPE__tempuri__SetSamplePlateId (40)
/* complex XML schema type 'tempuri:SetSamplePlateId': */
class SOAP_CMAC _tempuri__SetSamplePlateId {
      public:
        /// Optional element 'tempuri:methodIndex' of XML schema type 'xsd:int'
        int *methodIndex;
        /// Optional element 'tempuri:plateId' of XML schema type 'xsd:string'
        std::string *plateId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetSamplePlateId
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SetSamplePlateId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetSamplePlateId, default initialized and not managed by a soap context
        virtual _tempuri__SetSamplePlateId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SetSamplePlateId); }
      public:
        /// Constructor with default initializations
        _tempuri__SetSamplePlateId() : methodIndex(), plateId(), soap() { }
        virtual ~_tempuri__SetSamplePlateId() { }
        /// Friend allocator used by soap_new__tempuri__SetSamplePlateId(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__SetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:229 */
#ifndef SOAP_TYPE__tempuri__SetSamplePlateIdResponse
#define SOAP_TYPE__tempuri__SetSamplePlateIdResponse (41)
/* complex XML schema type 'tempuri:SetSamplePlateIdResponse': */
class SOAP_CMAC _tempuri__SetSamplePlateIdResponse {
      public:
        /// Optional element 'tempuri:SetSamplePlateIdResult' of XML schema type 'xsd:boolean'
        bool *SetSamplePlateIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetSamplePlateIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SetSamplePlateIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetSamplePlateIdResponse, default initialized and not managed by a soap context
        virtual _tempuri__SetSamplePlateIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SetSamplePlateIdResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__SetSamplePlateIdResponse() : SetSamplePlateIdResult(), soap() { }
        virtual ~_tempuri__SetSamplePlateIdResponse() { }
        /// Friend allocator used by soap_new__tempuri__SetSamplePlateIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetSamplePlateIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:231 */
#ifndef SOAP_TYPE__tempuri__GetSamplePlateId
#define SOAP_TYPE__tempuri__GetSamplePlateId (42)
/* complex XML schema type 'tempuri:GetSamplePlateId': */
class SOAP_CMAC _tempuri__GetSamplePlateId {
      public:
        /// Optional element 'tempuri:methodIndex' of XML schema type 'xsd:int'
        int *methodIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetSamplePlateId
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetSamplePlateId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetSamplePlateId, default initialized and not managed by a soap context
        virtual _tempuri__GetSamplePlateId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetSamplePlateId); }
      public:
        /// Constructor with default initializations
        _tempuri__GetSamplePlateId() : methodIndex(), soap() { }
        virtual ~_tempuri__GetSamplePlateId() { }
        /// Friend allocator used by soap_new__tempuri__GetSamplePlateId(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__GetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:233 */
#ifndef SOAP_TYPE__tempuri__GetSamplePlateIdResponse
#define SOAP_TYPE__tempuri__GetSamplePlateIdResponse (43)
/* complex XML schema type 'tempuri:GetSamplePlateIdResponse': */
class SOAP_CMAC _tempuri__GetSamplePlateIdResponse {
      public:
        /// Optional element 'tempuri:GetSamplePlateIdResult' of XML schema type 'xsd:string'
        std::string *GetSamplePlateIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetSamplePlateIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetSamplePlateIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetSamplePlateIdResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetSamplePlateIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetSamplePlateIdResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetSamplePlateIdResponse() : GetSamplePlateIdResult(), soap() { }
        virtual ~_tempuri__GetSamplePlateIdResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetSamplePlateIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetSamplePlateIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:235 */
#ifndef SOAP_TYPE__tempuri__GetCurrentSamplePlateId
#define SOAP_TYPE__tempuri__GetCurrentSamplePlateId (44)
/* complex XML schema type 'tempuri:GetCurrentSamplePlateId': */
class SOAP_CMAC _tempuri__GetCurrentSamplePlateId {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetCurrentSamplePlateId
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetCurrentSamplePlateId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetCurrentSamplePlateId, default initialized and not managed by a soap context
        virtual _tempuri__GetCurrentSamplePlateId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetCurrentSamplePlateId); }
      public:
        /// Constructor with default initializations
        _tempuri__GetCurrentSamplePlateId() : soap() { }
        virtual ~_tempuri__GetCurrentSamplePlateId() { }
        /// Friend allocator used by soap_new__tempuri__GetCurrentSamplePlateId(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate__tempuri__GetCurrentSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:237 */
#ifndef SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse
#define SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse (45)
/* complex XML schema type 'tempuri:GetCurrentSamplePlateIdResponse': */
class SOAP_CMAC _tempuri__GetCurrentSamplePlateIdResponse {
      public:
        /// Optional element 'tempuri:GetCurrentSamplePlateIdResult' of XML schema type 'xsd:string'
        std::string *GetCurrentSamplePlateIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetCurrentSamplePlateIdResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetCurrentSamplePlateIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetCurrentSamplePlateIdResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetCurrentSamplePlateIdResponse() : GetCurrentSamplePlateIdResult(), soap() { }
        virtual ~_tempuri__GetCurrentSamplePlateIdResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetCurrentSamplePlateIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetCurrentSamplePlateIdResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetCurrentSamplePlateIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:239 */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayOut
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayOut (46)
/* complex XML schema type 'tempuri:MoveSamplePlateTrayOut': */
class SOAP_CMAC _tempuri__MoveSamplePlateTrayOut {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__MoveSamplePlateTrayOut
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__MoveSamplePlateTrayOut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__MoveSamplePlateTrayOut, default initialized and not managed by a soap context
        virtual _tempuri__MoveSamplePlateTrayOut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__MoveSamplePlateTrayOut); }
      public:
        /// Constructor with default initializations
        _tempuri__MoveSamplePlateTrayOut() : soap() { }
        virtual ~_tempuri__MoveSamplePlateTrayOut() { }
        /// Friend allocator used by soap_new__tempuri__MoveSamplePlateTrayOut(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:241 */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse (47)
/* complex XML schema type 'tempuri:MoveSamplePlateTrayOutResponse': */
class SOAP_CMAC _tempuri__MoveSamplePlateTrayOutResponse {
      public:
        /// Optional element 'tempuri:MoveSamplePlateTrayOutResult' of XML schema type 'xsd:boolean'
        bool *MoveSamplePlateTrayOutResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__MoveSamplePlateTrayOutResponse, default initialized and not managed by a soap context
        virtual _tempuri__MoveSamplePlateTrayOutResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__MoveSamplePlateTrayOutResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__MoveSamplePlateTrayOutResponse() : MoveSamplePlateTrayOutResult(), soap() { }
        virtual ~_tempuri__MoveSamplePlateTrayOutResponse() { }
        /// Friend allocator used by soap_new__tempuri__MoveSamplePlateTrayOutResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__MoveSamplePlateTrayOutResponse * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayOutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:243 */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayIn
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayIn (48)
/* complex XML schema type 'tempuri:MoveSamplePlateTrayIn': */
class SOAP_CMAC _tempuri__MoveSamplePlateTrayIn {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__MoveSamplePlateTrayIn
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__MoveSamplePlateTrayIn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__MoveSamplePlateTrayIn, default initialized and not managed by a soap context
        virtual _tempuri__MoveSamplePlateTrayIn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__MoveSamplePlateTrayIn); }
      public:
        /// Constructor with default initializations
        _tempuri__MoveSamplePlateTrayIn() : soap() { }
        virtual ~_tempuri__MoveSamplePlateTrayIn() { }
        /// Friend allocator used by soap_new__tempuri__MoveSamplePlateTrayIn(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:245 */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse (49)
/* complex XML schema type 'tempuri:MoveSamplePlateTrayInResponse': */
class SOAP_CMAC _tempuri__MoveSamplePlateTrayInResponse {
      public:
        /// Optional element 'tempuri:MoveSamplePlateTrayInResult' of XML schema type 'xsd:boolean'
        bool *MoveSamplePlateTrayInResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__MoveSamplePlateTrayInResponse, default initialized and not managed by a soap context
        virtual _tempuri__MoveSamplePlateTrayInResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__MoveSamplePlateTrayInResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__MoveSamplePlateTrayInResponse() : MoveSamplePlateTrayInResult(), soap() { }
        virtual ~_tempuri__MoveSamplePlateTrayInResponse() { }
        /// Friend allocator used by soap_new__tempuri__MoveSamplePlateTrayInResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__MoveSamplePlateTrayInResponse * SOAP_FMAC2 soap_instantiate__tempuri__MoveSamplePlateTrayInResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:247 */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunset
#define SOAP_TYPE__tempuri__StartSelectedRunset (50)
/* complex XML schema type 'tempuri:StartSelectedRunset': */
class SOAP_CMAC _tempuri__StartSelectedRunset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__StartSelectedRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__StartSelectedRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__StartSelectedRunset, default initialized and not managed by a soap context
        virtual _tempuri__StartSelectedRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__StartSelectedRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__StartSelectedRunset() : soap() { }
        virtual ~_tempuri__StartSelectedRunset() { }
        /// Friend allocator used by soap_new__tempuri__StartSelectedRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__StartSelectedRunset * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:249 */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetResponse
#define SOAP_TYPE__tempuri__StartSelectedRunsetResponse (51)
/* complex XML schema type 'tempuri:StartSelectedRunsetResponse': */
class SOAP_CMAC _tempuri__StartSelectedRunsetResponse {
      public:
        /// Optional element 'tempuri:StartSelectedRunsetResult' of XML schema type 'xsd:boolean'
        bool *StartSelectedRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__StartSelectedRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__StartSelectedRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__StartSelectedRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__StartSelectedRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__StartSelectedRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__StartSelectedRunsetResponse() : StartSelectedRunsetResult(), soap() { }
        virtual ~_tempuri__StartSelectedRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__StartSelectedRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__StartSelectedRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:251 */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetFrom
#define SOAP_TYPE__tempuri__StartSelectedRunsetFrom (52)
/* complex XML schema type 'tempuri:StartSelectedRunsetFrom': */
class SOAP_CMAC _tempuri__StartSelectedRunsetFrom {
      public:
        /// Optional element 'tempuri:methodIndex' of XML schema type 'xsd:int'
        int *methodIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__StartSelectedRunsetFrom
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__StartSelectedRunsetFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__StartSelectedRunsetFrom, default initialized and not managed by a soap context
        virtual _tempuri__StartSelectedRunsetFrom *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__StartSelectedRunsetFrom); }
      public:
        /// Constructor with default initializations
        _tempuri__StartSelectedRunsetFrom() : methodIndex(), soap() { }
        virtual ~_tempuri__StartSelectedRunsetFrom() { }
        /// Friend allocator used by soap_new__tempuri__StartSelectedRunsetFrom(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:253 */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse
#define SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse (53)
/* complex XML schema type 'tempuri:StartSelectedRunsetFromResponse': */
class SOAP_CMAC _tempuri__StartSelectedRunsetFromResponse {
      public:
        /// Optional element 'tempuri:StartSelectedRunsetFromResult' of XML schema type 'xsd:boolean'
        bool *StartSelectedRunsetFromResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__StartSelectedRunsetFromResponse, default initialized and not managed by a soap context
        virtual _tempuri__StartSelectedRunsetFromResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__StartSelectedRunsetFromResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__StartSelectedRunsetFromResponse() : StartSelectedRunsetFromResult(), soap() { }
        virtual ~_tempuri__StartSelectedRunsetFromResponse() { }
        /// Friend allocator used by soap_new__tempuri__StartSelectedRunsetFromResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__StartSelectedRunsetFromResponse * SOAP_FMAC2 soap_instantiate__tempuri__StartSelectedRunsetFromResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:255 */
#ifndef SOAP_TYPE__tempuri__PauseRunsetAfter
#define SOAP_TYPE__tempuri__PauseRunsetAfter (54)
/* complex XML schema type 'tempuri:PauseRunsetAfter': */
class SOAP_CMAC _tempuri__PauseRunsetAfter {
      public:
        /// Optional element 'tempuri:pauseMode' of XML schema type 'xsd:int'
        int *pauseMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__PauseRunsetAfter
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__PauseRunsetAfter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__PauseRunsetAfter, default initialized and not managed by a soap context
        virtual _tempuri__PauseRunsetAfter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__PauseRunsetAfter); }
      public:
        /// Constructor with default initializations
        _tempuri__PauseRunsetAfter() : pauseMode(), soap() { }
        virtual ~_tempuri__PauseRunsetAfter() { }
        /// Friend allocator used by soap_new__tempuri__PauseRunsetAfter(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate__tempuri__PauseRunsetAfter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:257 */
#ifndef SOAP_TYPE__tempuri__PauseRunsetAfterResponse
#define SOAP_TYPE__tempuri__PauseRunsetAfterResponse (55)
/* complex XML schema type 'tempuri:PauseRunsetAfterResponse': */
class SOAP_CMAC _tempuri__PauseRunsetAfterResponse {
      public:
        /// Optional element 'tempuri:PauseRunsetAfterResult' of XML schema type 'xsd:boolean'
        bool *PauseRunsetAfterResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__PauseRunsetAfterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__PauseRunsetAfterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__PauseRunsetAfterResponse, default initialized and not managed by a soap context
        virtual _tempuri__PauseRunsetAfterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__PauseRunsetAfterResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__PauseRunsetAfterResponse() : PauseRunsetAfterResult(), soap() { }
        virtual ~_tempuri__PauseRunsetAfterResponse() { }
        /// Friend allocator used by soap_new__tempuri__PauseRunsetAfterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__PauseRunsetAfterResponse * SOAP_FMAC2 soap_instantiate__tempuri__PauseRunsetAfterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:259 */
#ifndef SOAP_TYPE__tempuri__ResumeRunset
#define SOAP_TYPE__tempuri__ResumeRunset (56)
/* complex XML schema type 'tempuri:ResumeRunset': */
class SOAP_CMAC _tempuri__ResumeRunset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ResumeRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__ResumeRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ResumeRunset, default initialized and not managed by a soap context
        virtual _tempuri__ResumeRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__ResumeRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__ResumeRunset() : soap() { }
        virtual ~_tempuri__ResumeRunset() { }
        /// Friend allocator used by soap_new__tempuri__ResumeRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ResumeRunset * SOAP_FMAC2 soap_instantiate__tempuri__ResumeRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:261 */
#ifndef SOAP_TYPE__tempuri__ResumeRunsetResponse
#define SOAP_TYPE__tempuri__ResumeRunsetResponse (57)
/* complex XML schema type 'tempuri:ResumeRunsetResponse': */
class SOAP_CMAC _tempuri__ResumeRunsetResponse {
      public:
        /// Optional element 'tempuri:ResumeRunsetResult' of XML schema type 'xsd:boolean'
        bool *ResumeRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ResumeRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__ResumeRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ResumeRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__ResumeRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__ResumeRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__ResumeRunsetResponse() : ResumeRunsetResult(), soap() { }
        virtual ~_tempuri__ResumeRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__ResumeRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ResumeRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__ResumeRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:263 */
#ifndef SOAP_TYPE__tempuri__ResetRunset
#define SOAP_TYPE__tempuri__ResetRunset (58)
/* complex XML schema type 'tempuri:ResetRunset': */
class SOAP_CMAC _tempuri__ResetRunset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ResetRunset
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__ResetRunset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ResetRunset, default initialized and not managed by a soap context
        virtual _tempuri__ResetRunset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__ResetRunset); }
      public:
        /// Constructor with default initializations
        _tempuri__ResetRunset() : soap() { }
        virtual ~_tempuri__ResetRunset() { }
        /// Friend allocator used by soap_new__tempuri__ResetRunset(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ResetRunset * SOAP_FMAC2 soap_instantiate__tempuri__ResetRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:265 */
#ifndef SOAP_TYPE__tempuri__ResetRunsetResponse
#define SOAP_TYPE__tempuri__ResetRunsetResponse (59)
/* complex XML schema type 'tempuri:ResetRunsetResponse': */
class SOAP_CMAC _tempuri__ResetRunsetResponse {
      public:
        /// Optional element 'tempuri:ResetRunsetResult' of XML schema type 'xsd:boolean'
        bool *ResetRunsetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ResetRunsetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__ResetRunsetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ResetRunsetResponse, default initialized and not managed by a soap context
        virtual _tempuri__ResetRunsetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__ResetRunsetResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__ResetRunsetResponse() : ResetRunsetResult(), soap() { }
        virtual ~_tempuri__ResetRunsetResponse() { }
        /// Friend allocator used by soap_new__tempuri__ResetRunsetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ResetRunsetResponse * SOAP_FMAC2 soap_instantiate__tempuri__ResetRunsetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:267 */
#ifndef SOAP_TYPE__tempuri__AbortScript
#define SOAP_TYPE__tempuri__AbortScript (60)
/* complex XML schema type 'tempuri:AbortScript': */
class SOAP_CMAC _tempuri__AbortScript {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AbortScript
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__AbortScript; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AbortScript, default initialized and not managed by a soap context
        virtual _tempuri__AbortScript *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__AbortScript); }
      public:
        /// Constructor with default initializations
        _tempuri__AbortScript() : soap() { }
        virtual ~_tempuri__AbortScript() { }
        /// Friend allocator used by soap_new__tempuri__AbortScript(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AbortScript * SOAP_FMAC2 soap_instantiate__tempuri__AbortScript(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:269 */
#ifndef SOAP_TYPE__tempuri__AbortScriptResponse
#define SOAP_TYPE__tempuri__AbortScriptResponse (61)
/* complex XML schema type 'tempuri:AbortScriptResponse': */
class SOAP_CMAC _tempuri__AbortScriptResponse {
      public:
        /// Optional element 'tempuri:AbortScriptResult' of XML schema type 'xsd:boolean'
        bool *AbortScriptResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AbortScriptResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__AbortScriptResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AbortScriptResponse, default initialized and not managed by a soap context
        virtual _tempuri__AbortScriptResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__AbortScriptResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__AbortScriptResponse() : AbortScriptResult(), soap() { }
        virtual ~_tempuri__AbortScriptResponse() { }
        /// Friend allocator used by soap_new__tempuri__AbortScriptResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AbortScriptResponse * SOAP_FMAC2 soap_instantiate__tempuri__AbortScriptResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:271 */
#ifndef SOAP_TYPE__tempuri__LeaveStandby
#define SOAP_TYPE__tempuri__LeaveStandby (62)
/* complex XML schema type 'tempuri:LeaveStandby': */
class SOAP_CMAC _tempuri__LeaveStandby {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LeaveStandby
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__LeaveStandby; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LeaveStandby, default initialized and not managed by a soap context
        virtual _tempuri__LeaveStandby *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__LeaveStandby); }
      public:
        /// Constructor with default initializations
        _tempuri__LeaveStandby() : soap() { }
        virtual ~_tempuri__LeaveStandby() { }
        /// Friend allocator used by soap_new__tempuri__LeaveStandby(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LeaveStandby * SOAP_FMAC2 soap_instantiate__tempuri__LeaveStandby(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:273 */
#ifndef SOAP_TYPE__tempuri__LeaveStandbyResponse
#define SOAP_TYPE__tempuri__LeaveStandbyResponse (63)
/* complex XML schema type 'tempuri:LeaveStandbyResponse': */
class SOAP_CMAC _tempuri__LeaveStandbyResponse {
      public:
        /// Optional element 'tempuri:LeaveStandbyResult' of XML schema type 'xsd:boolean'
        bool *LeaveStandbyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LeaveStandbyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__LeaveStandbyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LeaveStandbyResponse, default initialized and not managed by a soap context
        virtual _tempuri__LeaveStandbyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__LeaveStandbyResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__LeaveStandbyResponse() : LeaveStandbyResult(), soap() { }
        virtual ~_tempuri__LeaveStandbyResponse() { }
        /// Friend allocator used by soap_new__tempuri__LeaveStandbyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LeaveStandbyResponse * SOAP_FMAC2 soap_instantiate__tempuri__LeaveStandbyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:275 */
#ifndef SOAP_TYPE__tempuri__SetStandbyAfterFinish
#define SOAP_TYPE__tempuri__SetStandbyAfterFinish (64)
/* complex XML schema type 'tempuri:SetStandbyAfterFinish': */
class SOAP_CMAC _tempuri__SetStandbyAfterFinish {
      public:
        /// Optional element 'tempuri:goToStandby' of XML schema type 'xsd:boolean'
        bool *goToStandby;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetStandbyAfterFinish
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SetStandbyAfterFinish; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetStandbyAfterFinish, default initialized and not managed by a soap context
        virtual _tempuri__SetStandbyAfterFinish *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SetStandbyAfterFinish); }
      public:
        /// Constructor with default initializations
        _tempuri__SetStandbyAfterFinish() : goToStandby(), soap() { }
        virtual ~_tempuri__SetStandbyAfterFinish() { }
        /// Friend allocator used by soap_new__tempuri__SetStandbyAfterFinish(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate__tempuri__SetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:277 */
#ifndef SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse
#define SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse (65)
/* complex XML schema type 'tempuri:SetStandbyAfterFinishResponse': */
class SOAP_CMAC _tempuri__SetStandbyAfterFinishResponse {
      public:
        /// Optional element 'tempuri:SetStandbyAfterFinishResult' of XML schema type 'xsd:boolean'
        bool *SetStandbyAfterFinishResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetStandbyAfterFinishResponse, default initialized and not managed by a soap context
        virtual _tempuri__SetStandbyAfterFinishResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__SetStandbyAfterFinishResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__SetStandbyAfterFinishResponse() : SetStandbyAfterFinishResult(), soap() { }
        virtual ~_tempuri__SetStandbyAfterFinishResponse() { }
        /// Friend allocator used by soap_new__tempuri__SetStandbyAfterFinishResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetStandbyAfterFinishResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetStandbyAfterFinishResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:279 */
#ifndef SOAP_TYPE__tempuri__GetStandbyAfterFinish
#define SOAP_TYPE__tempuri__GetStandbyAfterFinish (66)
/* complex XML schema type 'tempuri:GetStandbyAfterFinish': */
class SOAP_CMAC _tempuri__GetStandbyAfterFinish {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetStandbyAfterFinish
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetStandbyAfterFinish; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetStandbyAfterFinish, default initialized and not managed by a soap context
        virtual _tempuri__GetStandbyAfterFinish *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetStandbyAfterFinish); }
      public:
        /// Constructor with default initializations
        _tempuri__GetStandbyAfterFinish() : soap() { }
        virtual ~_tempuri__GetStandbyAfterFinish() { }
        /// Friend allocator used by soap_new__tempuri__GetStandbyAfterFinish(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate__tempuri__GetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:281 */
#ifndef SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse
#define SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse (67)
/* complex XML schema type 'tempuri:GetStandbyAfterFinishResponse': */
class SOAP_CMAC _tempuri__GetStandbyAfterFinishResponse {
      public:
        /// Optional element 'tempuri:GetStandbyAfterFinishResult' of XML schema type 'xsd:boolean'
        bool *GetStandbyAfterFinishResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetStandbyAfterFinishResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetStandbyAfterFinishResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetStandbyAfterFinishResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetStandbyAfterFinishResponse() : GetStandbyAfterFinishResult(), soap() { }
        virtual ~_tempuri__GetStandbyAfterFinishResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetStandbyAfterFinishResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetStandbyAfterFinishResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetStandbyAfterFinishResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:283 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures
#define SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures (68)
/* complex XML schema type 'tempuri:GetNamesOfMaintenanceProcedures': */
class SOAP_CMAC _tempuri__GetNamesOfMaintenanceProcedures {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMaintenanceProcedures, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMaintenanceProcedures *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMaintenanceProcedures); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMaintenanceProcedures() : soap() { }
        virtual ~_tempuri__GetNamesOfMaintenanceProcedures() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMaintenanceProcedures(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMaintenanceProcedures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:285 */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse
#define SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse (69)
/* complex XML schema type 'tempuri:GetNamesOfMaintenanceProceduresResponse': */
class SOAP_CMAC _tempuri__GetNamesOfMaintenanceProceduresResponse {
      public:
        /// Optional element 'tempuri:GetNamesOfMaintenanceProceduresResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetNamesOfMaintenanceProceduresResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetNamesOfMaintenanceProceduresResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetNamesOfMaintenanceProceduresResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetNamesOfMaintenanceProceduresResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetNamesOfMaintenanceProceduresResponse() : GetNamesOfMaintenanceProceduresResult(), soap() { }
        virtual ~_tempuri__GetNamesOfMaintenanceProceduresResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetNamesOfMaintenanceProceduresResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetNamesOfMaintenanceProceduresResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:287 */
#ifndef SOAP_TYPE__tempuri__RunMaintenanceProcedure
#define SOAP_TYPE__tempuri__RunMaintenanceProcedure (70)
/* complex XML schema type 'tempuri:RunMaintenanceProcedure': */
class SOAP_CMAC _tempuri__RunMaintenanceProcedure {
      public:
        /// Optional element 'tempuri:procedureName' of XML schema type 'xsd:string'
        std::string *procedureName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__RunMaintenanceProcedure
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__RunMaintenanceProcedure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__RunMaintenanceProcedure, default initialized and not managed by a soap context
        virtual _tempuri__RunMaintenanceProcedure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__RunMaintenanceProcedure); }
      public:
        /// Constructor with default initializations
        _tempuri__RunMaintenanceProcedure() : procedureName(), soap() { }
        virtual ~_tempuri__RunMaintenanceProcedure() { }
        /// Friend allocator used by soap_new__tempuri__RunMaintenanceProcedure(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate__tempuri__RunMaintenanceProcedure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:289 */
#ifndef SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse
#define SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse (71)
/* complex XML schema type 'tempuri:RunMaintenanceProcedureResponse': */
class SOAP_CMAC _tempuri__RunMaintenanceProcedureResponse {
      public:
        /// Optional element 'tempuri:RunMaintenanceProcedureResult' of XML schema type 'xsd:boolean'
        bool *RunMaintenanceProcedureResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__RunMaintenanceProcedureResponse, default initialized and not managed by a soap context
        virtual _tempuri__RunMaintenanceProcedureResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__RunMaintenanceProcedureResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__RunMaintenanceProcedureResponse() : RunMaintenanceProcedureResult(), soap() { }
        virtual ~_tempuri__RunMaintenanceProcedureResponse() { }
        /// Friend allocator used by soap_new__tempuri__RunMaintenanceProcedureResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__RunMaintenanceProcedureResponse * SOAP_FMAC2 soap_instantiate__tempuri__RunMaintenanceProcedureResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:291 */
#ifndef SOAP_TYPE__tempuri__GetOperationMode
#define SOAP_TYPE__tempuri__GetOperationMode (72)
/* complex XML schema type 'tempuri:GetOperationMode': */
class SOAP_CMAC _tempuri__GetOperationMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetOperationMode
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetOperationMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetOperationMode, default initialized and not managed by a soap context
        virtual _tempuri__GetOperationMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetOperationMode); }
      public:
        /// Constructor with default initializations
        _tempuri__GetOperationMode() : soap() { }
        virtual ~_tempuri__GetOperationMode() { }
        /// Friend allocator used by soap_new__tempuri__GetOperationMode(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetOperationMode * SOAP_FMAC2 soap_instantiate__tempuri__GetOperationMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:293 */
#ifndef SOAP_TYPE__tempuri__GetOperationModeResponse
#define SOAP_TYPE__tempuri__GetOperationModeResponse (73)
/* complex XML schema type 'tempuri:GetOperationModeResponse': */
class SOAP_CMAC _tempuri__GetOperationModeResponse {
      public:
        /// Optional element 'tempuri:GetOperationModeResult' of XML schema type 'xsd:int'
        int *GetOperationModeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetOperationModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetOperationModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetOperationModeResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetOperationModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetOperationModeResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetOperationModeResponse() : GetOperationModeResult(), soap() { }
        virtual ~_tempuri__GetOperationModeResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetOperationModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetOperationModeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetOperationModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:295 */
#ifndef SOAP_TYPE__tempuri__IsChipDocked
#define SOAP_TYPE__tempuri__IsChipDocked (74)
/* complex XML schema type 'tempuri:IsChipDocked': */
class SOAP_CMAC _tempuri__IsChipDocked {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__IsChipDocked
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__IsChipDocked; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__IsChipDocked, default initialized and not managed by a soap context
        virtual _tempuri__IsChipDocked *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__IsChipDocked); }
      public:
        /// Constructor with default initializations
        _tempuri__IsChipDocked() : soap() { }
        virtual ~_tempuri__IsChipDocked() { }
        /// Friend allocator used by soap_new__tempuri__IsChipDocked(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__IsChipDocked * SOAP_FMAC2 soap_instantiate__tempuri__IsChipDocked(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:297 */
#ifndef SOAP_TYPE__tempuri__IsChipDockedResponse
#define SOAP_TYPE__tempuri__IsChipDockedResponse (75)
/* complex XML schema type 'tempuri:IsChipDockedResponse': */
class SOAP_CMAC _tempuri__IsChipDockedResponse {
      public:
        /// Optional element 'tempuri:IsChipDockedResult' of XML schema type 'xsd:int'
        int *IsChipDockedResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__IsChipDockedResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__IsChipDockedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__IsChipDockedResponse, default initialized and not managed by a soap context
        virtual _tempuri__IsChipDockedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__IsChipDockedResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__IsChipDockedResponse() : IsChipDockedResult(), soap() { }
        virtual ~_tempuri__IsChipDockedResponse() { }
        /// Friend allocator used by soap_new__tempuri__IsChipDockedResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__IsChipDockedResponse * SOAP_FMAC2 soap_instantiate__tempuri__IsChipDockedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:299 */
#ifndef SOAP_TYPE__tempuri__IsSamplePlateTrayIn
#define SOAP_TYPE__tempuri__IsSamplePlateTrayIn (76)
/* complex XML schema type 'tempuri:IsSamplePlateTrayIn': */
class SOAP_CMAC _tempuri__IsSamplePlateTrayIn {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__IsSamplePlateTrayIn
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__IsSamplePlateTrayIn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__IsSamplePlateTrayIn, default initialized and not managed by a soap context
        virtual _tempuri__IsSamplePlateTrayIn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__IsSamplePlateTrayIn); }
      public:
        /// Constructor with default initializations
        _tempuri__IsSamplePlateTrayIn() : soap() { }
        virtual ~_tempuri__IsSamplePlateTrayIn() { }
        /// Friend allocator used by soap_new__tempuri__IsSamplePlateTrayIn(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate__tempuri__IsSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:301 */
#ifndef SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse
#define SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse (77)
/* complex XML schema type 'tempuri:IsSamplePlateTrayInResponse': */
class SOAP_CMAC _tempuri__IsSamplePlateTrayInResponse {
      public:
        /// Optional element 'tempuri:IsSamplePlateTrayInResult' of XML schema type 'xsd:int'
        int *IsSamplePlateTrayInResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__IsSamplePlateTrayInResponse, default initialized and not managed by a soap context
        virtual _tempuri__IsSamplePlateTrayInResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__IsSamplePlateTrayInResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__IsSamplePlateTrayInResponse() : IsSamplePlateTrayInResult(), soap() { }
        virtual ~_tempuri__IsSamplePlateTrayInResponse() { }
        /// Friend allocator used by soap_new__tempuri__IsSamplePlateTrayInResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__IsSamplePlateTrayInResponse * SOAP_FMAC2 soap_instantiate__tempuri__IsSamplePlateTrayInResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:303 */
#ifndef SOAP_TYPE__tempuri__HasMessage
#define SOAP_TYPE__tempuri__HasMessage (78)
/* complex XML schema type 'tempuri:HasMessage': */
class SOAP_CMAC _tempuri__HasMessage {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasMessage
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasMessage, default initialized and not managed by a soap context
        virtual _tempuri__HasMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasMessage); }
      public:
        /// Constructor with default initializations
        _tempuri__HasMessage() : soap() { }
        virtual ~_tempuri__HasMessage() { }
        /// Friend allocator used by soap_new__tempuri__HasMessage(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasMessage * SOAP_FMAC2 soap_instantiate__tempuri__HasMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:305 */
#ifndef SOAP_TYPE__tempuri__HasMessageResponse
#define SOAP_TYPE__tempuri__HasMessageResponse (79)
/* complex XML schema type 'tempuri:HasMessageResponse': */
class SOAP_CMAC _tempuri__HasMessageResponse {
      public:
        /// Optional element 'tempuri:HasMessageResult' of XML schema type 'xsd:boolean'
        bool *HasMessageResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasMessageResponse, default initialized and not managed by a soap context
        virtual _tempuri__HasMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasMessageResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__HasMessageResponse() : HasMessageResult(), soap() { }
        virtual ~_tempuri__HasMessageResponse() { }
        /// Friend allocator used by soap_new__tempuri__HasMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasMessageResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:307 */
#ifndef SOAP_TYPE__tempuri__GetMessage
#define SOAP_TYPE__tempuri__GetMessage (80)
/* complex XML schema type 'tempuri:GetMessage': */
class SOAP_CMAC _tempuri__GetMessage {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetMessage
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetMessage, default initialized and not managed by a soap context
        virtual _tempuri__GetMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetMessage); }
      public:
        /// Constructor with default initializations
        _tempuri__GetMessage() : soap() { }
        virtual ~_tempuri__GetMessage() { }
        /// Friend allocator used by soap_new__tempuri__GetMessage(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetMessage * SOAP_FMAC2 soap_instantiate__tempuri__GetMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:309 */
#ifndef SOAP_TYPE__tempuri__GetMessageResponse
#define SOAP_TYPE__tempuri__GetMessageResponse (81)
/* complex XML schema type 'tempuri:GetMessageResponse': */
class SOAP_CMAC _tempuri__GetMessageResponse {
      public:
        /// Optional element 'tempuri:GetMessageResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetMessageResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetMessageResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetMessageResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetMessageResponse() : GetMessageResult(), soap() { }
        virtual ~_tempuri__GetMessageResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetMessageResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:311 */
#ifndef SOAP_TYPE__tempuri__HasErrors
#define SOAP_TYPE__tempuri__HasErrors (82)
/* complex XML schema type 'tempuri:HasErrors': */
class SOAP_CMAC _tempuri__HasErrors {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasErrors
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasErrors; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasErrors, default initialized and not managed by a soap context
        virtual _tempuri__HasErrors *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasErrors); }
      public:
        /// Constructor with default initializations
        _tempuri__HasErrors() : soap() { }
        virtual ~_tempuri__HasErrors() { }
        /// Friend allocator used by soap_new__tempuri__HasErrors(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasErrors * SOAP_FMAC2 soap_instantiate__tempuri__HasErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:313 */
#ifndef SOAP_TYPE__tempuri__HasErrorsResponse
#define SOAP_TYPE__tempuri__HasErrorsResponse (83)
/* complex XML schema type 'tempuri:HasErrorsResponse': */
class SOAP_CMAC _tempuri__HasErrorsResponse {
      public:
        /// Optional element 'tempuri:HasErrorsResult' of XML schema type 'xsd:boolean'
        bool *HasErrorsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasErrorsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasErrorsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasErrorsResponse, default initialized and not managed by a soap context
        virtual _tempuri__HasErrorsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasErrorsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__HasErrorsResponse() : HasErrorsResult(), soap() { }
        virtual ~_tempuri__HasErrorsResponse() { }
        /// Friend allocator used by soap_new__tempuri__HasErrorsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasErrorsResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasErrorsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:315 */
#ifndef SOAP_TYPE__tempuri__GetErrors
#define SOAP_TYPE__tempuri__GetErrors (84)
/* complex XML schema type 'tempuri:GetErrors': */
class SOAP_CMAC _tempuri__GetErrors {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetErrors
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetErrors; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetErrors, default initialized and not managed by a soap context
        virtual _tempuri__GetErrors *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetErrors); }
      public:
        /// Constructor with default initializations
        _tempuri__GetErrors() : soap() { }
        virtual ~_tempuri__GetErrors() { }
        /// Friend allocator used by soap_new__tempuri__GetErrors(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetErrors * SOAP_FMAC2 soap_instantiate__tempuri__GetErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:317 */
#ifndef SOAP_TYPE__tempuri__GetErrorsResponse
#define SOAP_TYPE__tempuri__GetErrorsResponse (85)
/* complex XML schema type 'tempuri:GetErrorsResponse': */
class SOAP_CMAC _tempuri__GetErrorsResponse {
      public:
        /// Optional element 'tempuri:GetErrorsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetErrorsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetErrorsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetErrorsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetErrorsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetErrorsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetErrorsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetErrorsResponse() : GetErrorsResult(), soap() { }
        virtual ~_tempuri__GetErrorsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetErrorsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetErrorsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetErrorsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:319 */
#ifndef SOAP_TYPE__tempuri__HasWarnings
#define SOAP_TYPE__tempuri__HasWarnings (86)
/* complex XML schema type 'tempuri:HasWarnings': */
class SOAP_CMAC _tempuri__HasWarnings {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasWarnings
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasWarnings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasWarnings, default initialized and not managed by a soap context
        virtual _tempuri__HasWarnings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasWarnings); }
      public:
        /// Constructor with default initializations
        _tempuri__HasWarnings() : soap() { }
        virtual ~_tempuri__HasWarnings() { }
        /// Friend allocator used by soap_new__tempuri__HasWarnings(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasWarnings * SOAP_FMAC2 soap_instantiate__tempuri__HasWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:321 */
#ifndef SOAP_TYPE__tempuri__HasWarningsResponse
#define SOAP_TYPE__tempuri__HasWarningsResponse (87)
/* complex XML schema type 'tempuri:HasWarningsResponse': */
class SOAP_CMAC _tempuri__HasWarningsResponse {
      public:
        /// Optional element 'tempuri:HasWarningsResult' of XML schema type 'xsd:boolean'
        bool *HasWarningsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__HasWarningsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__HasWarningsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__HasWarningsResponse, default initialized and not managed by a soap context
        virtual _tempuri__HasWarningsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__HasWarningsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__HasWarningsResponse() : HasWarningsResult(), soap() { }
        virtual ~_tempuri__HasWarningsResponse() { }
        /// Friend allocator used by soap_new__tempuri__HasWarningsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__HasWarningsResponse * SOAP_FMAC2 soap_instantiate__tempuri__HasWarningsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:323 */
#ifndef SOAP_TYPE__tempuri__GetWarnings
#define SOAP_TYPE__tempuri__GetWarnings (88)
/* complex XML schema type 'tempuri:GetWarnings': */
class SOAP_CMAC _tempuri__GetWarnings {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetWarnings
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetWarnings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetWarnings, default initialized and not managed by a soap context
        virtual _tempuri__GetWarnings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetWarnings); }
      public:
        /// Constructor with default initializations
        _tempuri__GetWarnings() : soap() { }
        virtual ~_tempuri__GetWarnings() { }
        /// Friend allocator used by soap_new__tempuri__GetWarnings(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetWarnings * SOAP_FMAC2 soap_instantiate__tempuri__GetWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:325 */
#ifndef SOAP_TYPE__tempuri__GetWarningsResponse
#define SOAP_TYPE__tempuri__GetWarningsResponse (89)
/* complex XML schema type 'tempuri:GetWarningsResponse': */
class SOAP_CMAC _tempuri__GetWarningsResponse {
      public:
        /// Optional element 'tempuri:GetWarningsResult' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *GetWarningsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetWarningsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tempuri__GetWarningsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetWarningsResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetWarningsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tempuri__GetWarningsResponse); }
      public:
        /// Constructor with default initializations
        _tempuri__GetWarningsResponse() : GetWarningsResult(), soap() { }
        virtual ~_tempuri__GetWarningsResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetWarningsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetWarningsResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetWarningsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:327 */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (90)
/* complex XML schema type 'arr:ArrayOfstring': */
class SOAP_CMAC arr__ArrayOfstring {
      public:
        /// Optional element 'arr:string' of XML schema type 'xsd:string'
        std::vector<std::string> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_arr__ArrayOfstring
        virtual long soap_type(void) const { return SOAP_TYPE_arr__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type arr__ArrayOfstring, default initialized and not managed by a soap context
        virtual arr__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(arr__ArrayOfstring); }
      public:
        /// Constructor with default initializations
        arr__ArrayOfstring() : string(), soap() { }
        virtual ~arr__ArrayOfstring() { }
        /// Friend allocator used by soap_new_arr__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 arr__ArrayOfstring * SOAP_FMAC2 soap_instantiate_arr__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2612 */
#ifndef SOAP_TYPE___name__GetNamesOfMethods
#define SOAP_TYPE___name__GetNamesOfMethods (102)
/* Wrapper: */
struct SOAP_CMAC __name__GetNamesOfMethods {
      public:
        /** Optional element 'tempuri:GetNamesOfMethods' of XML schema type 'tempuri:GetNamesOfMethods' */
        _tempuri__GetNamesOfMethods *tempuri__GetNamesOfMethods;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNamesOfMethods */
        long soap_type() const { return SOAP_TYPE___name__GetNamesOfMethods; }
        /** Constructor with member initializations */
        __name__GetNamesOfMethods() : tempuri__GetNamesOfMethods() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2682 */
#ifndef SOAP_TYPE___name__GetNamesOfMethodsOfAssayType
#define SOAP_TYPE___name__GetNamesOfMethodsOfAssayType (106)
/* Wrapper: */
struct SOAP_CMAC __name__GetNamesOfMethodsOfAssayType {
      public:
        /** Optional element 'tempuri:GetNamesOfMethodsOfAssayType' of XML schema type 'tempuri:GetNamesOfMethodsOfAssayType' */
        _tempuri__GetNamesOfMethodsOfAssayType *tempuri__GetNamesOfMethodsOfAssayType;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNamesOfMethodsOfAssayType */
        long soap_type() const { return SOAP_TYPE___name__GetNamesOfMethodsOfAssayType; }
        /** Constructor with member initializations */
        __name__GetNamesOfMethodsOfAssayType() : tempuri__GetNamesOfMethodsOfAssayType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMethodsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2752 */
#ifndef SOAP_TYPE___name__GetAssayTypesOfAllMethods
#define SOAP_TYPE___name__GetAssayTypesOfAllMethods (110)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypesOfAllMethods {
      public:
        /** Optional element 'tempuri:GetAssayTypesOfAllMethods' of XML schema type 'tempuri:GetAssayTypesOfAllMethods' */
        _tempuri__GetAssayTypesOfAllMethods *tempuri__GetAssayTypesOfAllMethods;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypesOfAllMethods */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypesOfAllMethods; }
        /** Constructor with member initializations */
        __name__GetAssayTypesOfAllMethods() : tempuri__GetAssayTypesOfAllMethods() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate___name__GetAssayTypesOfAllMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2822 */
#ifndef SOAP_TYPE___name__GetNameOfCurrentMethod
#define SOAP_TYPE___name__GetNameOfCurrentMethod (114)
/* Wrapper: */
struct SOAP_CMAC __name__GetNameOfCurrentMethod {
      public:
        /** Optional element 'tempuri:GetNameOfCurrentMethod' of XML schema type 'tempuri:GetNameOfCurrentMethod' */
        _tempuri__GetNameOfCurrentMethod *tempuri__GetNameOfCurrentMethod;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNameOfCurrentMethod */
        long soap_type() const { return SOAP_TYPE___name__GetNameOfCurrentMethod; }
        /** Constructor with member initializations */
        __name__GetNameOfCurrentMethod() : tempuri__GetNameOfCurrentMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name__GetNameOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2892 */
#ifndef SOAP_TYPE___name__GetAssayTypeOfCurrentMethod
#define SOAP_TYPE___name__GetAssayTypeOfCurrentMethod (118)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypeOfCurrentMethod {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfCurrentMethod' of XML schema type 'tempuri:GetAssayTypeOfCurrentMethod' */
        _tempuri__GetAssayTypeOfCurrentMethod *tempuri__GetAssayTypeOfCurrentMethod;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypeOfCurrentMethod */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypeOfCurrentMethod; }
        /** Constructor with member initializations */
        __name__GetAssayTypeOfCurrentMethod() : tempuri__GetAssayTypeOfCurrentMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:2962 */
#ifndef SOAP_TYPE___name__GetAssayTypeOfMethod
#define SOAP_TYPE___name__GetAssayTypeOfMethod (122)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypeOfMethod {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfMethod' of XML schema type 'tempuri:GetAssayTypeOfMethod' */
        _tempuri__GetAssayTypeOfMethod *tempuri__GetAssayTypeOfMethod;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypeOfMethod */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypeOfMethod; }
        /** Constructor with member initializations */
        __name__GetAssayTypeOfMethod() : tempuri__GetAssayTypeOfMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3032 */
#ifndef SOAP_TYPE___name__GetNamesOfRunsets
#define SOAP_TYPE___name__GetNamesOfRunsets (126)
/* Wrapper: */
struct SOAP_CMAC __name__GetNamesOfRunsets {
      public:
        /** Optional element 'tempuri:GetNamesOfRunsets' of XML schema type 'tempuri:GetNamesOfRunsets' */
        _tempuri__GetNamesOfRunsets *tempuri__GetNamesOfRunsets;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNamesOfRunsets */
        long soap_type() const { return SOAP_TYPE___name__GetNamesOfRunsets; }
        /** Constructor with member initializations */
        __name__GetNamesOfRunsets() : tempuri__GetNamesOfRunsets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate___name__GetNamesOfRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3102 */
#ifndef SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType
#define SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType (130)
/* Wrapper: */
struct SOAP_CMAC __name__GetNamesOfRunsetsOfAssayType {
      public:
        /** Optional element 'tempuri:GetNamesOfRunsetsOfAssayType' of XML schema type 'tempuri:GetNamesOfRunsetsOfAssayType' */
        _tempuri__GetNamesOfRunsetsOfAssayType *tempuri__GetNamesOfRunsetsOfAssayType;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType */
        long soap_type() const { return SOAP_TYPE___name__GetNamesOfRunsetsOfAssayType; }
        /** Constructor with member initializations */
        __name__GetNamesOfRunsetsOfAssayType() : tempuri__GetNamesOfRunsetsOfAssayType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate___name__GetNamesOfRunsetsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3172 */
#ifndef SOAP_TYPE___name__GetAssayTypesOfAllRunsets
#define SOAP_TYPE___name__GetAssayTypesOfAllRunsets (134)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypesOfAllRunsets {
      public:
        /** Optional element 'tempuri:GetAssayTypesOfAllRunsets' of XML schema type 'tempuri:GetAssayTypesOfAllRunsets' */
        _tempuri__GetAssayTypesOfAllRunsets *tempuri__GetAssayTypesOfAllRunsets;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypesOfAllRunsets */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypesOfAllRunsets; }
        /** Constructor with member initializations */
        __name__GetAssayTypesOfAllRunsets() : tempuri__GetAssayTypesOfAllRunsets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate___name__GetAssayTypesOfAllRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3242 */
#ifndef SOAP_TYPE___name__GetNameOfCurrentRunset
#define SOAP_TYPE___name__GetNameOfCurrentRunset (138)
/* Wrapper: */
struct SOAP_CMAC __name__GetNameOfCurrentRunset {
      public:
        /** Optional element 'tempuri:GetNameOfCurrentRunset' of XML schema type 'tempuri:GetNameOfCurrentRunset' */
        _tempuri__GetNameOfCurrentRunset *tempuri__GetNameOfCurrentRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNameOfCurrentRunset */
        long soap_type() const { return SOAP_TYPE___name__GetNameOfCurrentRunset; }
        /** Constructor with member initializations */
        __name__GetNameOfCurrentRunset() : tempuri__GetNameOfCurrentRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name__GetNameOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3312 */
#ifndef SOAP_TYPE___name__GetAssayTypeOfCurrentRunset
#define SOAP_TYPE___name__GetAssayTypeOfCurrentRunset (142)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypeOfCurrentRunset {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfCurrentRunset' of XML schema type 'tempuri:GetAssayTypeOfCurrentRunset' */
        _tempuri__GetAssayTypeOfCurrentRunset *tempuri__GetAssayTypeOfCurrentRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypeOfCurrentRunset */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypeOfCurrentRunset; }
        /** Constructor with member initializations */
        __name__GetAssayTypeOfCurrentRunset() : tempuri__GetAssayTypeOfCurrentRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3382 */
#ifndef SOAP_TYPE___name__GetAssayTypeOfRunset
#define SOAP_TYPE___name__GetAssayTypeOfRunset (146)
/* Wrapper: */
struct SOAP_CMAC __name__GetAssayTypeOfRunset {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfRunset' of XML schema type 'tempuri:GetAssayTypeOfRunset' */
        _tempuri__GetAssayTypeOfRunset *tempuri__GetAssayTypeOfRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__GetAssayTypeOfRunset */
        long soap_type() const { return SOAP_TYPE___name__GetAssayTypeOfRunset; }
        /** Constructor with member initializations */
        __name__GetAssayTypeOfRunset() : tempuri__GetAssayTypeOfRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate___name__GetAssayTypeOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3452 */
#ifndef SOAP_TYPE___name__GetMethodNamesOfRunset
#define SOAP_TYPE___name__GetMethodNamesOfRunset (150)
/* Wrapper: */
struct SOAP_CMAC __name__GetMethodNamesOfRunset {
      public:
        /** Optional element 'tempuri:GetMethodNamesOfRunset' of XML schema type 'tempuri:GetMethodNamesOfRunset' */
        _tempuri__GetMethodNamesOfRunset *tempuri__GetMethodNamesOfRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__GetMethodNamesOfRunset */
        long soap_type() const { return SOAP_TYPE___name__GetMethodNamesOfRunset; }
        /** Constructor with member initializations */
        __name__GetMethodNamesOfRunset() : tempuri__GetMethodNamesOfRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate___name__GetMethodNamesOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3522 */
#ifndef SOAP_TYPE___name__SelectMethod
#define SOAP_TYPE___name__SelectMethod (154)
/* Wrapper: */
struct SOAP_CMAC __name__SelectMethod {
      public:
        /** Optional element 'tempuri:SelectMethod' of XML schema type 'tempuri:SelectMethod' */
        _tempuri__SelectMethod *tempuri__SelectMethod;
      public:
        /** Return unique type id SOAP_TYPE___name__SelectMethod */
        long soap_type() const { return SOAP_TYPE___name__SelectMethod; }
        /** Constructor with member initializations */
        __name__SelectMethod() : tempuri__SelectMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__SelectMethod * SOAP_FMAC2 soap_instantiate___name__SelectMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3592 */
#ifndef SOAP_TYPE___name__SelectRunset
#define SOAP_TYPE___name__SelectRunset (158)
/* Wrapper: */
struct SOAP_CMAC __name__SelectRunset {
      public:
        /** Optional element 'tempuri:SelectRunset' of XML schema type 'tempuri:SelectRunset' */
        _tempuri__SelectRunset *tempuri__SelectRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__SelectRunset */
        long soap_type() const { return SOAP_TYPE___name__SelectRunset; }
        /** Constructor with member initializations */
        __name__SelectRunset() : tempuri__SelectRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__SelectRunset * SOAP_FMAC2 soap_instantiate___name__SelectRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3662 */
#ifndef SOAP_TYPE___name__CreateRunset
#define SOAP_TYPE___name__CreateRunset (162)
/* Wrapper: */
struct SOAP_CMAC __name__CreateRunset {
      public:
        /** Optional element 'tempuri:CreateRunset' of XML schema type 'tempuri:CreateRunset' */
        _tempuri__CreateRunset *tempuri__CreateRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__CreateRunset */
        long soap_type() const { return SOAP_TYPE___name__CreateRunset; }
        /** Constructor with member initializations */
        __name__CreateRunset() : tempuri__CreateRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__CreateRunset * SOAP_FMAC2 soap_instantiate___name__CreateRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3732 */
#ifndef SOAP_TYPE___name__SetSamplePlateId
#define SOAP_TYPE___name__SetSamplePlateId (166)
/* Wrapper: */
struct SOAP_CMAC __name__SetSamplePlateId {
      public:
        /** Optional element 'tempuri:SetSamplePlateId' of XML schema type 'tempuri:SetSamplePlateId' */
        _tempuri__SetSamplePlateId *tempuri__SetSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name__SetSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name__SetSamplePlateId; }
        /** Constructor with member initializations */
        __name__SetSamplePlateId() : tempuri__SetSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__SetSamplePlateId * SOAP_FMAC2 soap_instantiate___name__SetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3802 */
#ifndef SOAP_TYPE___name__GetSamplePlateId
#define SOAP_TYPE___name__GetSamplePlateId (170)
/* Wrapper: */
struct SOAP_CMAC __name__GetSamplePlateId {
      public:
        /** Optional element 'tempuri:GetSamplePlateId' of XML schema type 'tempuri:GetSamplePlateId' */
        _tempuri__GetSamplePlateId *tempuri__GetSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name__GetSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name__GetSamplePlateId; }
        /** Constructor with member initializations */
        __name__GetSamplePlateId() : tempuri__GetSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetSamplePlateId * SOAP_FMAC2 soap_instantiate___name__GetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3872 */
#ifndef SOAP_TYPE___name__GetCurrentSamplePlateId
#define SOAP_TYPE___name__GetCurrentSamplePlateId (174)
/* Wrapper: */
struct SOAP_CMAC __name__GetCurrentSamplePlateId {
      public:
        /** Optional element 'tempuri:GetCurrentSamplePlateId' of XML schema type 'tempuri:GetCurrentSamplePlateId' */
        _tempuri__GetCurrentSamplePlateId *tempuri__GetCurrentSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name__GetCurrentSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name__GetCurrentSamplePlateId; }
        /** Constructor with member initializations */
        __name__GetCurrentSamplePlateId() : tempuri__GetCurrentSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate___name__GetCurrentSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:3942 */
#ifndef SOAP_TYPE___name__MoveSamplePlateTrayOut
#define SOAP_TYPE___name__MoveSamplePlateTrayOut (178)
/* Wrapper: */
struct SOAP_CMAC __name__MoveSamplePlateTrayOut {
      public:
        /** Optional element 'tempuri:MoveSamplePlateTrayOut' of XML schema type 'tempuri:MoveSamplePlateTrayOut' */
        _tempuri__MoveSamplePlateTrayOut *tempuri__MoveSamplePlateTrayOut;
      public:
        /** Return unique type id SOAP_TYPE___name__MoveSamplePlateTrayOut */
        long soap_type() const { return SOAP_TYPE___name__MoveSamplePlateTrayOut; }
        /** Constructor with member initializations */
        __name__MoveSamplePlateTrayOut() : tempuri__MoveSamplePlateTrayOut() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate___name__MoveSamplePlateTrayOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4012 */
#ifndef SOAP_TYPE___name__MoveSamplePlateTrayIn
#define SOAP_TYPE___name__MoveSamplePlateTrayIn (182)
/* Wrapper: */
struct SOAP_CMAC __name__MoveSamplePlateTrayIn {
      public:
        /** Optional element 'tempuri:MoveSamplePlateTrayIn' of XML schema type 'tempuri:MoveSamplePlateTrayIn' */
        _tempuri__MoveSamplePlateTrayIn *tempuri__MoveSamplePlateTrayIn;
      public:
        /** Return unique type id SOAP_TYPE___name__MoveSamplePlateTrayIn */
        long soap_type() const { return SOAP_TYPE___name__MoveSamplePlateTrayIn; }
        /** Constructor with member initializations */
        __name__MoveSamplePlateTrayIn() : tempuri__MoveSamplePlateTrayIn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name__MoveSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4082 */
#ifndef SOAP_TYPE___name__StartSelectedRunset
#define SOAP_TYPE___name__StartSelectedRunset (186)
/* Wrapper: */
struct SOAP_CMAC __name__StartSelectedRunset {
      public:
        /** Optional element 'tempuri:StartSelectedRunset' of XML schema type 'tempuri:StartSelectedRunset' */
        _tempuri__StartSelectedRunset *tempuri__StartSelectedRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__StartSelectedRunset */
        long soap_type() const { return SOAP_TYPE___name__StartSelectedRunset; }
        /** Constructor with member initializations */
        __name__StartSelectedRunset() : tempuri__StartSelectedRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__StartSelectedRunset * SOAP_FMAC2 soap_instantiate___name__StartSelectedRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4152 */
#ifndef SOAP_TYPE___name__StartSelectedRunsetFrom
#define SOAP_TYPE___name__StartSelectedRunsetFrom (190)
/* Wrapper: */
struct SOAP_CMAC __name__StartSelectedRunsetFrom {
      public:
        /** Optional element 'tempuri:StartSelectedRunsetFrom' of XML schema type 'tempuri:StartSelectedRunsetFrom' */
        _tempuri__StartSelectedRunsetFrom *tempuri__StartSelectedRunsetFrom;
      public:
        /** Return unique type id SOAP_TYPE___name__StartSelectedRunsetFrom */
        long soap_type() const { return SOAP_TYPE___name__StartSelectedRunsetFrom; }
        /** Constructor with member initializations */
        __name__StartSelectedRunsetFrom() : tempuri__StartSelectedRunsetFrom() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate___name__StartSelectedRunsetFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4222 */
#ifndef SOAP_TYPE___name__PauseRunsetAfter
#define SOAP_TYPE___name__PauseRunsetAfter (194)
/* Wrapper: */
struct SOAP_CMAC __name__PauseRunsetAfter {
      public:
        /** Optional element 'tempuri:PauseRunsetAfter' of XML schema type 'tempuri:PauseRunsetAfter' */
        _tempuri__PauseRunsetAfter *tempuri__PauseRunsetAfter;
      public:
        /** Return unique type id SOAP_TYPE___name__PauseRunsetAfter */
        long soap_type() const { return SOAP_TYPE___name__PauseRunsetAfter; }
        /** Constructor with member initializations */
        __name__PauseRunsetAfter() : tempuri__PauseRunsetAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate___name__PauseRunsetAfter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4292 */
#ifndef SOAP_TYPE___name__ResumeRunset
#define SOAP_TYPE___name__ResumeRunset (198)
/* Wrapper: */
struct SOAP_CMAC __name__ResumeRunset {
      public:
        /** Optional element 'tempuri:ResumeRunset' of XML schema type 'tempuri:ResumeRunset' */
        _tempuri__ResumeRunset *tempuri__ResumeRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__ResumeRunset */
        long soap_type() const { return SOAP_TYPE___name__ResumeRunset; }
        /** Constructor with member initializations */
        __name__ResumeRunset() : tempuri__ResumeRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__ResumeRunset * SOAP_FMAC2 soap_instantiate___name__ResumeRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4362 */
#ifndef SOAP_TYPE___name__ResetRunset
#define SOAP_TYPE___name__ResetRunset (202)
/* Wrapper: */
struct SOAP_CMAC __name__ResetRunset {
      public:
        /** Optional element 'tempuri:ResetRunset' of XML schema type 'tempuri:ResetRunset' */
        _tempuri__ResetRunset *tempuri__ResetRunset;
      public:
        /** Return unique type id SOAP_TYPE___name__ResetRunset */
        long soap_type() const { return SOAP_TYPE___name__ResetRunset; }
        /** Constructor with member initializations */
        __name__ResetRunset() : tempuri__ResetRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__ResetRunset * SOAP_FMAC2 soap_instantiate___name__ResetRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4432 */
#ifndef SOAP_TYPE___name__AbortScript
#define SOAP_TYPE___name__AbortScript (206)
/* Wrapper: */
struct SOAP_CMAC __name__AbortScript {
      public:
        /** Optional element 'tempuri:AbortScript' of XML schema type 'tempuri:AbortScript' */
        _tempuri__AbortScript *tempuri__AbortScript;
      public:
        /** Return unique type id SOAP_TYPE___name__AbortScript */
        long soap_type() const { return SOAP_TYPE___name__AbortScript; }
        /** Constructor with member initializations */
        __name__AbortScript() : tempuri__AbortScript() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__AbortScript * SOAP_FMAC2 soap_instantiate___name__AbortScript(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4502 */
#ifndef SOAP_TYPE___name__LeaveStandby
#define SOAP_TYPE___name__LeaveStandby (210)
/* Wrapper: */
struct SOAP_CMAC __name__LeaveStandby {
      public:
        /** Optional element 'tempuri:LeaveStandby' of XML schema type 'tempuri:LeaveStandby' */
        _tempuri__LeaveStandby *tempuri__LeaveStandby;
      public:
        /** Return unique type id SOAP_TYPE___name__LeaveStandby */
        long soap_type() const { return SOAP_TYPE___name__LeaveStandby; }
        /** Constructor with member initializations */
        __name__LeaveStandby() : tempuri__LeaveStandby() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__LeaveStandby * SOAP_FMAC2 soap_instantiate___name__LeaveStandby(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4572 */
#ifndef SOAP_TYPE___name__SetStandbyAfterFinish
#define SOAP_TYPE___name__SetStandbyAfterFinish (214)
/* Wrapper: */
struct SOAP_CMAC __name__SetStandbyAfterFinish {
      public:
        /** Optional element 'tempuri:SetStandbyAfterFinish' of XML schema type 'tempuri:SetStandbyAfterFinish' */
        _tempuri__SetStandbyAfterFinish *tempuri__SetStandbyAfterFinish;
      public:
        /** Return unique type id SOAP_TYPE___name__SetStandbyAfterFinish */
        long soap_type() const { return SOAP_TYPE___name__SetStandbyAfterFinish; }
        /** Constructor with member initializations */
        __name__SetStandbyAfterFinish() : tempuri__SetStandbyAfterFinish() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name__SetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4642 */
#ifndef SOAP_TYPE___name__GetStandbyAfterFinish
#define SOAP_TYPE___name__GetStandbyAfterFinish (218)
/* Wrapper: */
struct SOAP_CMAC __name__GetStandbyAfterFinish {
      public:
        /** Optional element 'tempuri:GetStandbyAfterFinish' of XML schema type 'tempuri:GetStandbyAfterFinish' */
        _tempuri__GetStandbyAfterFinish *tempuri__GetStandbyAfterFinish;
      public:
        /** Return unique type id SOAP_TYPE___name__GetStandbyAfterFinish */
        long soap_type() const { return SOAP_TYPE___name__GetStandbyAfterFinish; }
        /** Constructor with member initializations */
        __name__GetStandbyAfterFinish() : tempuri__GetStandbyAfterFinish() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name__GetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4712 */
#ifndef SOAP_TYPE___name__GetNamesOfMaintenanceProcedures
#define SOAP_TYPE___name__GetNamesOfMaintenanceProcedures (222)
/* Wrapper: */
struct SOAP_CMAC __name__GetNamesOfMaintenanceProcedures {
      public:
        /** Optional element 'tempuri:GetNamesOfMaintenanceProcedures' of XML schema type 'tempuri:GetNamesOfMaintenanceProcedures' */
        _tempuri__GetNamesOfMaintenanceProcedures *tempuri__GetNamesOfMaintenanceProcedures;
      public:
        /** Return unique type id SOAP_TYPE___name__GetNamesOfMaintenanceProcedures */
        long soap_type() const { return SOAP_TYPE___name__GetNamesOfMaintenanceProcedures; }
        /** Constructor with member initializations */
        __name__GetNamesOfMaintenanceProcedures() : tempuri__GetNamesOfMaintenanceProcedures() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate___name__GetNamesOfMaintenanceProcedures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4782 */
#ifndef SOAP_TYPE___name__RunMaintenanceProcedure
#define SOAP_TYPE___name__RunMaintenanceProcedure (226)
/* Wrapper: */
struct SOAP_CMAC __name__RunMaintenanceProcedure {
      public:
        /** Optional element 'tempuri:RunMaintenanceProcedure' of XML schema type 'tempuri:RunMaintenanceProcedure' */
        _tempuri__RunMaintenanceProcedure *tempuri__RunMaintenanceProcedure;
      public:
        /** Return unique type id SOAP_TYPE___name__RunMaintenanceProcedure */
        long soap_type() const { return SOAP_TYPE___name__RunMaintenanceProcedure; }
        /** Constructor with member initializations */
        __name__RunMaintenanceProcedure() : tempuri__RunMaintenanceProcedure() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate___name__RunMaintenanceProcedure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4852 */
#ifndef SOAP_TYPE___name__GetOperationMode
#define SOAP_TYPE___name__GetOperationMode (230)
/* Wrapper: */
struct SOAP_CMAC __name__GetOperationMode {
      public:
        /** Optional element 'tempuri:GetOperationMode' of XML schema type 'tempuri:GetOperationMode' */
        _tempuri__GetOperationMode *tempuri__GetOperationMode;
      public:
        /** Return unique type id SOAP_TYPE___name__GetOperationMode */
        long soap_type() const { return SOAP_TYPE___name__GetOperationMode; }
        /** Constructor with member initializations */
        __name__GetOperationMode() : tempuri__GetOperationMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetOperationMode * SOAP_FMAC2 soap_instantiate___name__GetOperationMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4922 */
#ifndef SOAP_TYPE___name__IsChipDocked
#define SOAP_TYPE___name__IsChipDocked (234)
/* Wrapper: */
struct SOAP_CMAC __name__IsChipDocked {
      public:
        /** Optional element 'tempuri:IsChipDocked' of XML schema type 'tempuri:IsChipDocked' */
        _tempuri__IsChipDocked *tempuri__IsChipDocked;
      public:
        /** Return unique type id SOAP_TYPE___name__IsChipDocked */
        long soap_type() const { return SOAP_TYPE___name__IsChipDocked; }
        /** Constructor with member initializations */
        __name__IsChipDocked() : tempuri__IsChipDocked() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__IsChipDocked * SOAP_FMAC2 soap_instantiate___name__IsChipDocked(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:4992 */
#ifndef SOAP_TYPE___name__IsSamplePlateTrayIn
#define SOAP_TYPE___name__IsSamplePlateTrayIn (238)
/* Wrapper: */
struct SOAP_CMAC __name__IsSamplePlateTrayIn {
      public:
        /** Optional element 'tempuri:IsSamplePlateTrayIn' of XML schema type 'tempuri:IsSamplePlateTrayIn' */
        _tempuri__IsSamplePlateTrayIn *tempuri__IsSamplePlateTrayIn;
      public:
        /** Return unique type id SOAP_TYPE___name__IsSamplePlateTrayIn */
        long soap_type() const { return SOAP_TYPE___name__IsSamplePlateTrayIn; }
        /** Constructor with member initializations */
        __name__IsSamplePlateTrayIn() : tempuri__IsSamplePlateTrayIn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name__IsSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5062 */
#ifndef SOAP_TYPE___name__HasMessage
#define SOAP_TYPE___name__HasMessage (242)
/* Wrapper: */
struct SOAP_CMAC __name__HasMessage {
      public:
        /** Optional element 'tempuri:HasMessage' of XML schema type 'tempuri:HasMessage' */
        _tempuri__HasMessage *tempuri__HasMessage;
      public:
        /** Return unique type id SOAP_TYPE___name__HasMessage */
        long soap_type() const { return SOAP_TYPE___name__HasMessage; }
        /** Constructor with member initializations */
        __name__HasMessage() : tempuri__HasMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__HasMessage * SOAP_FMAC2 soap_instantiate___name__HasMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5132 */
#ifndef SOAP_TYPE___name__GetMessage
#define SOAP_TYPE___name__GetMessage (246)
/* Wrapper: */
struct SOAP_CMAC __name__GetMessage {
      public:
        /** Optional element 'tempuri:GetMessage' of XML schema type 'tempuri:GetMessage' */
        _tempuri__GetMessage *tempuri__GetMessage;
      public:
        /** Return unique type id SOAP_TYPE___name__GetMessage */
        long soap_type() const { return SOAP_TYPE___name__GetMessage; }
        /** Constructor with member initializations */
        __name__GetMessage() : tempuri__GetMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetMessage * SOAP_FMAC2 soap_instantiate___name__GetMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5202 */
#ifndef SOAP_TYPE___name__HasErrors
#define SOAP_TYPE___name__HasErrors (250)
/* Wrapper: */
struct SOAP_CMAC __name__HasErrors {
      public:
        /** Optional element 'tempuri:HasErrors' of XML schema type 'tempuri:HasErrors' */
        _tempuri__HasErrors *tempuri__HasErrors;
      public:
        /** Return unique type id SOAP_TYPE___name__HasErrors */
        long soap_type() const { return SOAP_TYPE___name__HasErrors; }
        /** Constructor with member initializations */
        __name__HasErrors() : tempuri__HasErrors() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__HasErrors * SOAP_FMAC2 soap_instantiate___name__HasErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5272 */
#ifndef SOAP_TYPE___name__GetErrors
#define SOAP_TYPE___name__GetErrors (254)
/* Wrapper: */
struct SOAP_CMAC __name__GetErrors {
      public:
        /** Optional element 'tempuri:GetErrors' of XML schema type 'tempuri:GetErrors' */
        _tempuri__GetErrors *tempuri__GetErrors;
      public:
        /** Return unique type id SOAP_TYPE___name__GetErrors */
        long soap_type() const { return SOAP_TYPE___name__GetErrors; }
        /** Constructor with member initializations */
        __name__GetErrors() : tempuri__GetErrors() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetErrors * SOAP_FMAC2 soap_instantiate___name__GetErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5342 */
#ifndef SOAP_TYPE___name__HasWarnings
#define SOAP_TYPE___name__HasWarnings (258)
/* Wrapper: */
struct SOAP_CMAC __name__HasWarnings {
      public:
        /** Optional element 'tempuri:HasWarnings' of XML schema type 'tempuri:HasWarnings' */
        _tempuri__HasWarnings *tempuri__HasWarnings;
      public:
        /** Return unique type id SOAP_TYPE___name__HasWarnings */
        long soap_type() const { return SOAP_TYPE___name__HasWarnings; }
        /** Constructor with member initializations */
        __name__HasWarnings() : tempuri__HasWarnings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__HasWarnings * SOAP_FMAC2 soap_instantiate___name__HasWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5412 */
#ifndef SOAP_TYPE___name__GetWarnings
#define SOAP_TYPE___name__GetWarnings (262)
/* Wrapper: */
struct SOAP_CMAC __name__GetWarnings {
      public:
        /** Optional element 'tempuri:GetWarnings' of XML schema type 'tempuri:GetWarnings' */
        _tempuri__GetWarnings *tempuri__GetWarnings;
      public:
        /** Return unique type id SOAP_TYPE___name__GetWarnings */
        long soap_type() const { return SOAP_TYPE___name__GetWarnings; }
        /** Constructor with member initializations */
        __name__GetWarnings() : tempuri__GetWarnings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name__GetWarnings * SOAP_FMAC2 soap_instantiate___name__GetWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5540 */
#ifndef SOAP_TYPE___name2__GetNamesOfMethods
#define SOAP_TYPE___name2__GetNamesOfMethods (264)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNamesOfMethods {
      public:
        /** Optional element 'tempuri:GetNamesOfMethods' of XML schema type 'tempuri:GetNamesOfMethods' */
        _tempuri__GetNamesOfMethods *tempuri__GetNamesOfMethods;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNamesOfMethods */
        long soap_type() const { return SOAP_TYPE___name2__GetNamesOfMethods; }
        /** Constructor with member initializations */
        __name2__GetNamesOfMethods() : tempuri__GetNamesOfMethods() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNamesOfMethods * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5652 */
#ifndef SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType
#define SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType (266)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNamesOfMethodsOfAssayType {
      public:
        /** Optional element 'tempuri:GetNamesOfMethodsOfAssayType' of XML schema type 'tempuri:GetNamesOfMethodsOfAssayType' */
        _tempuri__GetNamesOfMethodsOfAssayType *tempuri__GetNamesOfMethodsOfAssayType;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType */
        long soap_type() const { return SOAP_TYPE___name2__GetNamesOfMethodsOfAssayType; }
        /** Constructor with member initializations */
        __name2__GetNamesOfMethodsOfAssayType() : tempuri__GetNamesOfMethodsOfAssayType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNamesOfMethodsOfAssayType * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMethodsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5764 */
#ifndef SOAP_TYPE___name2__GetAssayTypesOfAllMethods
#define SOAP_TYPE___name2__GetAssayTypesOfAllMethods (268)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypesOfAllMethods {
      public:
        /** Optional element 'tempuri:GetAssayTypesOfAllMethods' of XML schema type 'tempuri:GetAssayTypesOfAllMethods' */
        _tempuri__GetAssayTypesOfAllMethods *tempuri__GetAssayTypesOfAllMethods;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypesOfAllMethods */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypesOfAllMethods; }
        /** Constructor with member initializations */
        __name2__GetAssayTypesOfAllMethods() : tempuri__GetAssayTypesOfAllMethods() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypesOfAllMethods * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypesOfAllMethods(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5876 */
#ifndef SOAP_TYPE___name2__GetNameOfCurrentMethod
#define SOAP_TYPE___name2__GetNameOfCurrentMethod (270)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNameOfCurrentMethod {
      public:
        /** Optional element 'tempuri:GetNameOfCurrentMethod' of XML schema type 'tempuri:GetNameOfCurrentMethod' */
        _tempuri__GetNameOfCurrentMethod *tempuri__GetNameOfCurrentMethod;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNameOfCurrentMethod */
        long soap_type() const { return SOAP_TYPE___name2__GetNameOfCurrentMethod; }
        /** Constructor with member initializations */
        __name2__GetNameOfCurrentMethod() : tempuri__GetNameOfCurrentMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNameOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name2__GetNameOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:5988 */
#ifndef SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod
#define SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod (272)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypeOfCurrentMethod {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfCurrentMethod' of XML schema type 'tempuri:GetAssayTypeOfCurrentMethod' */
        _tempuri__GetAssayTypeOfCurrentMethod *tempuri__GetAssayTypeOfCurrentMethod;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypeOfCurrentMethod; }
        /** Constructor with member initializations */
        __name2__GetAssayTypeOfCurrentMethod() : tempuri__GetAssayTypeOfCurrentMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypeOfCurrentMethod * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfCurrentMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6100 */
#ifndef SOAP_TYPE___name2__GetAssayTypeOfMethod
#define SOAP_TYPE___name2__GetAssayTypeOfMethod (274)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypeOfMethod {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfMethod' of XML schema type 'tempuri:GetAssayTypeOfMethod' */
        _tempuri__GetAssayTypeOfMethod *tempuri__GetAssayTypeOfMethod;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypeOfMethod */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypeOfMethod; }
        /** Constructor with member initializations */
        __name2__GetAssayTypeOfMethod() : tempuri__GetAssayTypeOfMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypeOfMethod * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6212 */
#ifndef SOAP_TYPE___name2__GetNamesOfRunsets
#define SOAP_TYPE___name2__GetNamesOfRunsets (276)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNamesOfRunsets {
      public:
        /** Optional element 'tempuri:GetNamesOfRunsets' of XML schema type 'tempuri:GetNamesOfRunsets' */
        _tempuri__GetNamesOfRunsets *tempuri__GetNamesOfRunsets;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNamesOfRunsets */
        long soap_type() const { return SOAP_TYPE___name2__GetNamesOfRunsets; }
        /** Constructor with member initializations */
        __name2__GetNamesOfRunsets() : tempuri__GetNamesOfRunsets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNamesOfRunsets * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6324 */
#ifndef SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType
#define SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType (278)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNamesOfRunsetsOfAssayType {
      public:
        /** Optional element 'tempuri:GetNamesOfRunsetsOfAssayType' of XML schema type 'tempuri:GetNamesOfRunsetsOfAssayType' */
        _tempuri__GetNamesOfRunsetsOfAssayType *tempuri__GetNamesOfRunsetsOfAssayType;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType */
        long soap_type() const { return SOAP_TYPE___name2__GetNamesOfRunsetsOfAssayType; }
        /** Constructor with member initializations */
        __name2__GetNamesOfRunsetsOfAssayType() : tempuri__GetNamesOfRunsetsOfAssayType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNamesOfRunsetsOfAssayType * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfRunsetsOfAssayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6436 */
#ifndef SOAP_TYPE___name2__GetAssayTypesOfAllRunsets
#define SOAP_TYPE___name2__GetAssayTypesOfAllRunsets (280)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypesOfAllRunsets {
      public:
        /** Optional element 'tempuri:GetAssayTypesOfAllRunsets' of XML schema type 'tempuri:GetAssayTypesOfAllRunsets' */
        _tempuri__GetAssayTypesOfAllRunsets *tempuri__GetAssayTypesOfAllRunsets;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypesOfAllRunsets */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypesOfAllRunsets; }
        /** Constructor with member initializations */
        __name2__GetAssayTypesOfAllRunsets() : tempuri__GetAssayTypesOfAllRunsets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypesOfAllRunsets * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypesOfAllRunsets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6548 */
#ifndef SOAP_TYPE___name2__GetNameOfCurrentRunset
#define SOAP_TYPE___name2__GetNameOfCurrentRunset (282)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNameOfCurrentRunset {
      public:
        /** Optional element 'tempuri:GetNameOfCurrentRunset' of XML schema type 'tempuri:GetNameOfCurrentRunset' */
        _tempuri__GetNameOfCurrentRunset *tempuri__GetNameOfCurrentRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNameOfCurrentRunset */
        long soap_type() const { return SOAP_TYPE___name2__GetNameOfCurrentRunset; }
        /** Constructor with member initializations */
        __name2__GetNameOfCurrentRunset() : tempuri__GetNameOfCurrentRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNameOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name2__GetNameOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6660 */
#ifndef SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset
#define SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset (284)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypeOfCurrentRunset {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfCurrentRunset' of XML schema type 'tempuri:GetAssayTypeOfCurrentRunset' */
        _tempuri__GetAssayTypeOfCurrentRunset *tempuri__GetAssayTypeOfCurrentRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypeOfCurrentRunset; }
        /** Constructor with member initializations */
        __name2__GetAssayTypeOfCurrentRunset() : tempuri__GetAssayTypeOfCurrentRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypeOfCurrentRunset * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfCurrentRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6772 */
#ifndef SOAP_TYPE___name2__GetAssayTypeOfRunset
#define SOAP_TYPE___name2__GetAssayTypeOfRunset (286)
/* Wrapper: */
struct SOAP_CMAC __name2__GetAssayTypeOfRunset {
      public:
        /** Optional element 'tempuri:GetAssayTypeOfRunset' of XML schema type 'tempuri:GetAssayTypeOfRunset' */
        _tempuri__GetAssayTypeOfRunset *tempuri__GetAssayTypeOfRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetAssayTypeOfRunset */
        long soap_type() const { return SOAP_TYPE___name2__GetAssayTypeOfRunset; }
        /** Constructor with member initializations */
        __name2__GetAssayTypeOfRunset() : tempuri__GetAssayTypeOfRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetAssayTypeOfRunset * SOAP_FMAC2 soap_instantiate___name2__GetAssayTypeOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6884 */
#ifndef SOAP_TYPE___name2__GetMethodNamesOfRunset
#define SOAP_TYPE___name2__GetMethodNamesOfRunset (288)
/* Wrapper: */
struct SOAP_CMAC __name2__GetMethodNamesOfRunset {
      public:
        /** Optional element 'tempuri:GetMethodNamesOfRunset' of XML schema type 'tempuri:GetMethodNamesOfRunset' */
        _tempuri__GetMethodNamesOfRunset *tempuri__GetMethodNamesOfRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetMethodNamesOfRunset */
        long soap_type() const { return SOAP_TYPE___name2__GetMethodNamesOfRunset; }
        /** Constructor with member initializations */
        __name2__GetMethodNamesOfRunset() : tempuri__GetMethodNamesOfRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetMethodNamesOfRunset * SOAP_FMAC2 soap_instantiate___name2__GetMethodNamesOfRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:6996 */
#ifndef SOAP_TYPE___name2__SelectMethod
#define SOAP_TYPE___name2__SelectMethod (290)
/* Wrapper: */
struct SOAP_CMAC __name2__SelectMethod {
      public:
        /** Optional element 'tempuri:SelectMethod' of XML schema type 'tempuri:SelectMethod' */
        _tempuri__SelectMethod *tempuri__SelectMethod;
      public:
        /** Return unique type id SOAP_TYPE___name2__SelectMethod */
        long soap_type() const { return SOAP_TYPE___name2__SelectMethod; }
        /** Constructor with member initializations */
        __name2__SelectMethod() : tempuri__SelectMethod() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__SelectMethod * SOAP_FMAC2 soap_instantiate___name2__SelectMethod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7108 */
#ifndef SOAP_TYPE___name2__SelectRunset
#define SOAP_TYPE___name2__SelectRunset (292)
/* Wrapper: */
struct SOAP_CMAC __name2__SelectRunset {
      public:
        /** Optional element 'tempuri:SelectRunset' of XML schema type 'tempuri:SelectRunset' */
        _tempuri__SelectRunset *tempuri__SelectRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__SelectRunset */
        long soap_type() const { return SOAP_TYPE___name2__SelectRunset; }
        /** Constructor with member initializations */
        __name2__SelectRunset() : tempuri__SelectRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__SelectRunset * SOAP_FMAC2 soap_instantiate___name2__SelectRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7220 */
#ifndef SOAP_TYPE___name2__CreateRunset
#define SOAP_TYPE___name2__CreateRunset (294)
/* Wrapper: */
struct SOAP_CMAC __name2__CreateRunset {
      public:
        /** Optional element 'tempuri:CreateRunset' of XML schema type 'tempuri:CreateRunset' */
        _tempuri__CreateRunset *tempuri__CreateRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__CreateRunset */
        long soap_type() const { return SOAP_TYPE___name2__CreateRunset; }
        /** Constructor with member initializations */
        __name2__CreateRunset() : tempuri__CreateRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__CreateRunset * SOAP_FMAC2 soap_instantiate___name2__CreateRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7332 */
#ifndef SOAP_TYPE___name2__SetSamplePlateId
#define SOAP_TYPE___name2__SetSamplePlateId (296)
/* Wrapper: */
struct SOAP_CMAC __name2__SetSamplePlateId {
      public:
        /** Optional element 'tempuri:SetSamplePlateId' of XML schema type 'tempuri:SetSamplePlateId' */
        _tempuri__SetSamplePlateId *tempuri__SetSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name2__SetSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name2__SetSamplePlateId; }
        /** Constructor with member initializations */
        __name2__SetSamplePlateId() : tempuri__SetSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__SetSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__SetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7444 */
#ifndef SOAP_TYPE___name2__GetSamplePlateId
#define SOAP_TYPE___name2__GetSamplePlateId (298)
/* Wrapper: */
struct SOAP_CMAC __name2__GetSamplePlateId {
      public:
        /** Optional element 'tempuri:GetSamplePlateId' of XML schema type 'tempuri:GetSamplePlateId' */
        _tempuri__GetSamplePlateId *tempuri__GetSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name2__GetSamplePlateId; }
        /** Constructor with member initializations */
        __name2__GetSamplePlateId() : tempuri__GetSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__GetSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7556 */
#ifndef SOAP_TYPE___name2__GetCurrentSamplePlateId
#define SOAP_TYPE___name2__GetCurrentSamplePlateId (300)
/* Wrapper: */
struct SOAP_CMAC __name2__GetCurrentSamplePlateId {
      public:
        /** Optional element 'tempuri:GetCurrentSamplePlateId' of XML schema type 'tempuri:GetCurrentSamplePlateId' */
        _tempuri__GetCurrentSamplePlateId *tempuri__GetCurrentSamplePlateId;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetCurrentSamplePlateId */
        long soap_type() const { return SOAP_TYPE___name2__GetCurrentSamplePlateId; }
        /** Constructor with member initializations */
        __name2__GetCurrentSamplePlateId() : tempuri__GetCurrentSamplePlateId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetCurrentSamplePlateId * SOAP_FMAC2 soap_instantiate___name2__GetCurrentSamplePlateId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7668 */
#ifndef SOAP_TYPE___name2__MoveSamplePlateTrayOut
#define SOAP_TYPE___name2__MoveSamplePlateTrayOut (302)
/* Wrapper: */
struct SOAP_CMAC __name2__MoveSamplePlateTrayOut {
      public:
        /** Optional element 'tempuri:MoveSamplePlateTrayOut' of XML schema type 'tempuri:MoveSamplePlateTrayOut' */
        _tempuri__MoveSamplePlateTrayOut *tempuri__MoveSamplePlateTrayOut;
      public:
        /** Return unique type id SOAP_TYPE___name2__MoveSamplePlateTrayOut */
        long soap_type() const { return SOAP_TYPE___name2__MoveSamplePlateTrayOut; }
        /** Constructor with member initializations */
        __name2__MoveSamplePlateTrayOut() : tempuri__MoveSamplePlateTrayOut() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__MoveSamplePlateTrayOut * SOAP_FMAC2 soap_instantiate___name2__MoveSamplePlateTrayOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7780 */
#ifndef SOAP_TYPE___name2__MoveSamplePlateTrayIn
#define SOAP_TYPE___name2__MoveSamplePlateTrayIn (304)
/* Wrapper: */
struct SOAP_CMAC __name2__MoveSamplePlateTrayIn {
      public:
        /** Optional element 'tempuri:MoveSamplePlateTrayIn' of XML schema type 'tempuri:MoveSamplePlateTrayIn' */
        _tempuri__MoveSamplePlateTrayIn *tempuri__MoveSamplePlateTrayIn;
      public:
        /** Return unique type id SOAP_TYPE___name2__MoveSamplePlateTrayIn */
        long soap_type() const { return SOAP_TYPE___name2__MoveSamplePlateTrayIn; }
        /** Constructor with member initializations */
        __name2__MoveSamplePlateTrayIn() : tempuri__MoveSamplePlateTrayIn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__MoveSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name2__MoveSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:7892 */
#ifndef SOAP_TYPE___name2__StartSelectedRunset
#define SOAP_TYPE___name2__StartSelectedRunset (306)
/* Wrapper: */
struct SOAP_CMAC __name2__StartSelectedRunset {
      public:
        /** Optional element 'tempuri:StartSelectedRunset' of XML schema type 'tempuri:StartSelectedRunset' */
        _tempuri__StartSelectedRunset *tempuri__StartSelectedRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__StartSelectedRunset */
        long soap_type() const { return SOAP_TYPE___name2__StartSelectedRunset; }
        /** Constructor with member initializations */
        __name2__StartSelectedRunset() : tempuri__StartSelectedRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__StartSelectedRunset * SOAP_FMAC2 soap_instantiate___name2__StartSelectedRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8004 */
#ifndef SOAP_TYPE___name2__StartSelectedRunsetFrom
#define SOAP_TYPE___name2__StartSelectedRunsetFrom (308)
/* Wrapper: */
struct SOAP_CMAC __name2__StartSelectedRunsetFrom {
      public:
        /** Optional element 'tempuri:StartSelectedRunsetFrom' of XML schema type 'tempuri:StartSelectedRunsetFrom' */
        _tempuri__StartSelectedRunsetFrom *tempuri__StartSelectedRunsetFrom;
      public:
        /** Return unique type id SOAP_TYPE___name2__StartSelectedRunsetFrom */
        long soap_type() const { return SOAP_TYPE___name2__StartSelectedRunsetFrom; }
        /** Constructor with member initializations */
        __name2__StartSelectedRunsetFrom() : tempuri__StartSelectedRunsetFrom() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__StartSelectedRunsetFrom * SOAP_FMAC2 soap_instantiate___name2__StartSelectedRunsetFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8116 */
#ifndef SOAP_TYPE___name2__PauseRunsetAfter
#define SOAP_TYPE___name2__PauseRunsetAfter (310)
/* Wrapper: */
struct SOAP_CMAC __name2__PauseRunsetAfter {
      public:
        /** Optional element 'tempuri:PauseRunsetAfter' of XML schema type 'tempuri:PauseRunsetAfter' */
        _tempuri__PauseRunsetAfter *tempuri__PauseRunsetAfter;
      public:
        /** Return unique type id SOAP_TYPE___name2__PauseRunsetAfter */
        long soap_type() const { return SOAP_TYPE___name2__PauseRunsetAfter; }
        /** Constructor with member initializations */
        __name2__PauseRunsetAfter() : tempuri__PauseRunsetAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__PauseRunsetAfter * SOAP_FMAC2 soap_instantiate___name2__PauseRunsetAfter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8228 */
#ifndef SOAP_TYPE___name2__ResumeRunset
#define SOAP_TYPE___name2__ResumeRunset (312)
/* Wrapper: */
struct SOAP_CMAC __name2__ResumeRunset {
      public:
        /** Optional element 'tempuri:ResumeRunset' of XML schema type 'tempuri:ResumeRunset' */
        _tempuri__ResumeRunset *tempuri__ResumeRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__ResumeRunset */
        long soap_type() const { return SOAP_TYPE___name2__ResumeRunset; }
        /** Constructor with member initializations */
        __name2__ResumeRunset() : tempuri__ResumeRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__ResumeRunset * SOAP_FMAC2 soap_instantiate___name2__ResumeRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8340 */
#ifndef SOAP_TYPE___name2__ResetRunset
#define SOAP_TYPE___name2__ResetRunset (314)
/* Wrapper: */
struct SOAP_CMAC __name2__ResetRunset {
      public:
        /** Optional element 'tempuri:ResetRunset' of XML schema type 'tempuri:ResetRunset' */
        _tempuri__ResetRunset *tempuri__ResetRunset;
      public:
        /** Return unique type id SOAP_TYPE___name2__ResetRunset */
        long soap_type() const { return SOAP_TYPE___name2__ResetRunset; }
        /** Constructor with member initializations */
        __name2__ResetRunset() : tempuri__ResetRunset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__ResetRunset * SOAP_FMAC2 soap_instantiate___name2__ResetRunset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8452 */
#ifndef SOAP_TYPE___name2__AbortScript
#define SOAP_TYPE___name2__AbortScript (316)
/* Wrapper: */
struct SOAP_CMAC __name2__AbortScript {
      public:
        /** Optional element 'tempuri:AbortScript' of XML schema type 'tempuri:AbortScript' */
        _tempuri__AbortScript *tempuri__AbortScript;
      public:
        /** Return unique type id SOAP_TYPE___name2__AbortScript */
        long soap_type() const { return SOAP_TYPE___name2__AbortScript; }
        /** Constructor with member initializations */
        __name2__AbortScript() : tempuri__AbortScript() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__AbortScript * SOAP_FMAC2 soap_instantiate___name2__AbortScript(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8564 */
#ifndef SOAP_TYPE___name2__LeaveStandby
#define SOAP_TYPE___name2__LeaveStandby (318)
/* Wrapper: */
struct SOAP_CMAC __name2__LeaveStandby {
      public:
        /** Optional element 'tempuri:LeaveStandby' of XML schema type 'tempuri:LeaveStandby' */
        _tempuri__LeaveStandby *tempuri__LeaveStandby;
      public:
        /** Return unique type id SOAP_TYPE___name2__LeaveStandby */
        long soap_type() const { return SOAP_TYPE___name2__LeaveStandby; }
        /** Constructor with member initializations */
        __name2__LeaveStandby() : tempuri__LeaveStandby() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__LeaveStandby * SOAP_FMAC2 soap_instantiate___name2__LeaveStandby(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8676 */
#ifndef SOAP_TYPE___name2__SetStandbyAfterFinish
#define SOAP_TYPE___name2__SetStandbyAfterFinish (320)
/* Wrapper: */
struct SOAP_CMAC __name2__SetStandbyAfterFinish {
      public:
        /** Optional element 'tempuri:SetStandbyAfterFinish' of XML schema type 'tempuri:SetStandbyAfterFinish' */
        _tempuri__SetStandbyAfterFinish *tempuri__SetStandbyAfterFinish;
      public:
        /** Return unique type id SOAP_TYPE___name2__SetStandbyAfterFinish */
        long soap_type() const { return SOAP_TYPE___name2__SetStandbyAfterFinish; }
        /** Constructor with member initializations */
        __name2__SetStandbyAfterFinish() : tempuri__SetStandbyAfterFinish() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__SetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name2__SetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8788 */
#ifndef SOAP_TYPE___name2__GetStandbyAfterFinish
#define SOAP_TYPE___name2__GetStandbyAfterFinish (322)
/* Wrapper: */
struct SOAP_CMAC __name2__GetStandbyAfterFinish {
      public:
        /** Optional element 'tempuri:GetStandbyAfterFinish' of XML schema type 'tempuri:GetStandbyAfterFinish' */
        _tempuri__GetStandbyAfterFinish *tempuri__GetStandbyAfterFinish;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetStandbyAfterFinish */
        long soap_type() const { return SOAP_TYPE___name2__GetStandbyAfterFinish; }
        /** Constructor with member initializations */
        __name2__GetStandbyAfterFinish() : tempuri__GetStandbyAfterFinish() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetStandbyAfterFinish * SOAP_FMAC2 soap_instantiate___name2__GetStandbyAfterFinish(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:8900 */
#ifndef SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures
#define SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures (324)
/* Wrapper: */
struct SOAP_CMAC __name2__GetNamesOfMaintenanceProcedures {
      public:
        /** Optional element 'tempuri:GetNamesOfMaintenanceProcedures' of XML schema type 'tempuri:GetNamesOfMaintenanceProcedures' */
        _tempuri__GetNamesOfMaintenanceProcedures *tempuri__GetNamesOfMaintenanceProcedures;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures */
        long soap_type() const { return SOAP_TYPE___name2__GetNamesOfMaintenanceProcedures; }
        /** Constructor with member initializations */
        __name2__GetNamesOfMaintenanceProcedures() : tempuri__GetNamesOfMaintenanceProcedures() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetNamesOfMaintenanceProcedures * SOAP_FMAC2 soap_instantiate___name2__GetNamesOfMaintenanceProcedures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9012 */
#ifndef SOAP_TYPE___name2__RunMaintenanceProcedure
#define SOAP_TYPE___name2__RunMaintenanceProcedure (326)
/* Wrapper: */
struct SOAP_CMAC __name2__RunMaintenanceProcedure {
      public:
        /** Optional element 'tempuri:RunMaintenanceProcedure' of XML schema type 'tempuri:RunMaintenanceProcedure' */
        _tempuri__RunMaintenanceProcedure *tempuri__RunMaintenanceProcedure;
      public:
        /** Return unique type id SOAP_TYPE___name2__RunMaintenanceProcedure */
        long soap_type() const { return SOAP_TYPE___name2__RunMaintenanceProcedure; }
        /** Constructor with member initializations */
        __name2__RunMaintenanceProcedure() : tempuri__RunMaintenanceProcedure() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__RunMaintenanceProcedure * SOAP_FMAC2 soap_instantiate___name2__RunMaintenanceProcedure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9124 */
#ifndef SOAP_TYPE___name2__GetOperationMode
#define SOAP_TYPE___name2__GetOperationMode (328)
/* Wrapper: */
struct SOAP_CMAC __name2__GetOperationMode {
      public:
        /** Optional element 'tempuri:GetOperationMode' of XML schema type 'tempuri:GetOperationMode' */
        _tempuri__GetOperationMode *tempuri__GetOperationMode;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetOperationMode */
        long soap_type() const { return SOAP_TYPE___name2__GetOperationMode; }
        /** Constructor with member initializations */
        __name2__GetOperationMode() : tempuri__GetOperationMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetOperationMode * SOAP_FMAC2 soap_instantiate___name2__GetOperationMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9236 */
#ifndef SOAP_TYPE___name2__IsChipDocked
#define SOAP_TYPE___name2__IsChipDocked (330)
/* Wrapper: */
struct SOAP_CMAC __name2__IsChipDocked {
      public:
        /** Optional element 'tempuri:IsChipDocked' of XML schema type 'tempuri:IsChipDocked' */
        _tempuri__IsChipDocked *tempuri__IsChipDocked;
      public:
        /** Return unique type id SOAP_TYPE___name2__IsChipDocked */
        long soap_type() const { return SOAP_TYPE___name2__IsChipDocked; }
        /** Constructor with member initializations */
        __name2__IsChipDocked() : tempuri__IsChipDocked() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__IsChipDocked * SOAP_FMAC2 soap_instantiate___name2__IsChipDocked(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9348 */
#ifndef SOAP_TYPE___name2__IsSamplePlateTrayIn
#define SOAP_TYPE___name2__IsSamplePlateTrayIn (332)
/* Wrapper: */
struct SOAP_CMAC __name2__IsSamplePlateTrayIn {
      public:
        /** Optional element 'tempuri:IsSamplePlateTrayIn' of XML schema type 'tempuri:IsSamplePlateTrayIn' */
        _tempuri__IsSamplePlateTrayIn *tempuri__IsSamplePlateTrayIn;
      public:
        /** Return unique type id SOAP_TYPE___name2__IsSamplePlateTrayIn */
        long soap_type() const { return SOAP_TYPE___name2__IsSamplePlateTrayIn; }
        /** Constructor with member initializations */
        __name2__IsSamplePlateTrayIn() : tempuri__IsSamplePlateTrayIn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__IsSamplePlateTrayIn * SOAP_FMAC2 soap_instantiate___name2__IsSamplePlateTrayIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9460 */
#ifndef SOAP_TYPE___name2__HasMessage
#define SOAP_TYPE___name2__HasMessage (334)
/* Wrapper: */
struct SOAP_CMAC __name2__HasMessage {
      public:
        /** Optional element 'tempuri:HasMessage' of XML schema type 'tempuri:HasMessage' */
        _tempuri__HasMessage *tempuri__HasMessage;
      public:
        /** Return unique type id SOAP_TYPE___name2__HasMessage */
        long soap_type() const { return SOAP_TYPE___name2__HasMessage; }
        /** Constructor with member initializations */
        __name2__HasMessage() : tempuri__HasMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__HasMessage * SOAP_FMAC2 soap_instantiate___name2__HasMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9572 */
#ifndef SOAP_TYPE___name2__GetMessage
#define SOAP_TYPE___name2__GetMessage (336)
/* Wrapper: */
struct SOAP_CMAC __name2__GetMessage {
      public:
        /** Optional element 'tempuri:GetMessage' of XML schema type 'tempuri:GetMessage' */
        _tempuri__GetMessage *tempuri__GetMessage;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetMessage */
        long soap_type() const { return SOAP_TYPE___name2__GetMessage; }
        /** Constructor with member initializations */
        __name2__GetMessage() : tempuri__GetMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetMessage * SOAP_FMAC2 soap_instantiate___name2__GetMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9684 */
#ifndef SOAP_TYPE___name2__HasErrors
#define SOAP_TYPE___name2__HasErrors (338)
/* Wrapper: */
struct SOAP_CMAC __name2__HasErrors {
      public:
        /** Optional element 'tempuri:HasErrors' of XML schema type 'tempuri:HasErrors' */
        _tempuri__HasErrors *tempuri__HasErrors;
      public:
        /** Return unique type id SOAP_TYPE___name2__HasErrors */
        long soap_type() const { return SOAP_TYPE___name2__HasErrors; }
        /** Constructor with member initializations */
        __name2__HasErrors() : tempuri__HasErrors() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__HasErrors * SOAP_FMAC2 soap_instantiate___name2__HasErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9796 */
#ifndef SOAP_TYPE___name2__GetErrors
#define SOAP_TYPE___name2__GetErrors (340)
/* Wrapper: */
struct SOAP_CMAC __name2__GetErrors {
      public:
        /** Optional element 'tempuri:GetErrors' of XML schema type 'tempuri:GetErrors' */
        _tempuri__GetErrors *tempuri__GetErrors;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetErrors */
        long soap_type() const { return SOAP_TYPE___name2__GetErrors; }
        /** Constructor with member initializations */
        __name2__GetErrors() : tempuri__GetErrors() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetErrors * SOAP_FMAC2 soap_instantiate___name2__GetErrors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:9908 */
#ifndef SOAP_TYPE___name2__HasWarnings
#define SOAP_TYPE___name2__HasWarnings (342)
/* Wrapper: */
struct SOAP_CMAC __name2__HasWarnings {
      public:
        /** Optional element 'tempuri:HasWarnings' of XML schema type 'tempuri:HasWarnings' */
        _tempuri__HasWarnings *tempuri__HasWarnings;
      public:
        /** Return unique type id SOAP_TYPE___name2__HasWarnings */
        long soap_type() const { return SOAP_TYPE___name2__HasWarnings; }
        /** Constructor with member initializations */
        __name2__HasWarnings() : tempuri__HasWarnings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__HasWarnings * SOAP_FMAC2 soap_instantiate___name2__HasWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* spr.h:10020 */
#ifndef SOAP_TYPE___name2__GetWarnings
#define SOAP_TYPE___name2__GetWarnings (344)
/* Wrapper: */
struct SOAP_CMAC __name2__GetWarnings {
      public:
        /** Optional element 'tempuri:GetWarnings' of XML schema type 'tempuri:GetWarnings' */
        _tempuri__GetWarnings *tempuri__GetWarnings;
      public:
        /** Return unique type id SOAP_TYPE___name2__GetWarnings */
        long soap_type() const { return SOAP_TYPE___name2__GetWarnings; }
        /** Constructor with member initializations */
        __name2__GetWarnings() : tempuri__GetWarnings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __name2__GetWarnings * SOAP_FMAC2 soap_instantiate___name2__GetWarnings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsu.h:77 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (346)
/* complex XML schema type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XML schema type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        long soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp() : wsu__Id(), Created(), Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:58 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (347)
/* simple XML schema type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        long soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString() : __item(), EncodingType(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:129 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (349)
/* complex XML schema type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XML schema type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XML schema type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XML schema type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        long soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken() : Username(), Password(), Nonce(), wsu__Created(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:140 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (353)
/* simple XML schema type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        long soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:150 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (354)
/* complex XML schema type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        long soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference() : URI(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:158 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (355)
/* complex XML schema type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        long soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded() : wsu__Id(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:167 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (356)
/* simple XML schema type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        long soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:177 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (357)
/* complex XML schema type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XML schema type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XML schema type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XML schema type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XML schema type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XML schema type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        long soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference() : Reference(), KeyIdentifier(), Embedded(), ds__X509Data(), wsu__Id(), wsc__Instance(), Usage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (364)
/* complex XML schema type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XML schema type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XML schema type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType() : SignedInfo(), SignatureValue(), KeyInfo(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (374)
/* complex XML schema type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XML schema type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        long soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces() : PrefixList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:73 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (375)
/* complex XML schema type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        long soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType() : c14n__InclusiveNamespaces(), __any(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (367)
/* complex XML schema type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'ds:KeyName' of XML schema type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XML schema type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XML schema type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        long soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType() : KeyName(), KeyValue(), RetrievalMethod(), X509Data(), wsse__SecurityTokenReference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (365)
/* complex XML schema type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XML schema type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XML schema type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XML schema type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        long soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType() : CanonicalizationMethod(), SignatureMethod(), __sizeReference(), Reference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:59 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (370)
/* complex XML schema type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        long soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType() : Algorithm(), c14n__InclusiveNamespaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:62 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (371)
/* complex XML schema type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XML schema type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType() : HMACOutputLength(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:65 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (372)
/* complex XML schema type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XML schema type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        long soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType() : Transforms(), DigestMethod(), DigestValue(), Id(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:68 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (373)
/* complex XML schema type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XML schema type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        long soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType() : __sizeTransform(), Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:79 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (378)
/* complex XML schema type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        long soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType() : Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:84 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (379)
/* complex XML schema type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XML schema type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XML schema type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType() : DSAKeyValue(), RSAKeyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:85 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (381)
/* complex XML schema type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        long soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType() : Transforms(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:180 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (361)
/* complex XML schema type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XML schema type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XML schema type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XML schema type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XML schema type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XML schema type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        long soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType() : X509IssuerSerial(), X509SKI(), X509SubjectName(), X509Certificate(), X509CRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:102 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (385)
/* complex XML schema type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XML schema type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XML schema type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        long soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType() : X509IssuerName(), X509SerialNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:123 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (386)
/* complex XML schema type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XML schema type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XML schema type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XML schema type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XML schema type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XML schema type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XML schema type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XML schema type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType() : G(), Y(), J(), P(), Q(), Seed(), PgenCounter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:126 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (387)
/* complex XML schema type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XML schema type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XML schema type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType() : Modulus(), Exponent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (408)
/* complex XML schema type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XML schema type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType() : Target(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (398)
/* complex XML schema type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (399)
/* complex XML schema type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XML schema type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XML schema type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType() : KeySize(), OAEPparams(), Algorithm(), ds__DigestMethod(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (400)
/* complex XML schema type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XML schema type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XML schema type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType() : CipherValue(), CipherReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (401)
/* complex XML schema type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XML schema type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType() : Transforms(), URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (402)
/* complex XML schema type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XML schema type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        long soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType() : ds__Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (405)
/* complex XML schema type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XML schema type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType() : KA_Nonce(), OriginatorKeyInfo(), RecipientKeyInfo(), Algorithm(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (406)
/* complex XML schema type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType() : URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (407)
/* complex XML schema type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XML schema type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType() : __sizeEncryptionProperty(), EncryptionProperty(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:236 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (417)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        long soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList() : DataReference(), KeyReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (409)
/* complex XML schema type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XML schema type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        long soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList() : __size_ReferenceList(), __union_ReferenceList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (403)
/* complex XML schema type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (404)
/* complex XML schema type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XML schema type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding(), ReferenceList(), CarriedKeyName(), Recipient() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:89 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (423)
/* complex XML schema type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XML schema type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType() : wsu__Id(), Identifier(), Instance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:122 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (428)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:118 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (427)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XML schema type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        long soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence() : __union_DerivedKeyTokenType(), Length() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:111 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (424)
/* complex XML schema type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XML schema type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XML schema type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XML schema type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType() : wsse__SecurityTokenReference(), Properties(), __DerivedKeyTokenType_sequence(), Label(), Nonce(), wsu__Id(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:115 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (425)
/* complex XML schema type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        long soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:147 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (455)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XML schema type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XML schema type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XML schema type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XML schema type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XML schema type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType() : saml1__Statement(), saml1__SubjectStatement(), saml1__AuthenticationStatement(), saml1__AuthorizationDecisionStatement(), saml1__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:62 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (432)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XML schema type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XML schema type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XML schema type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XML schema type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XML schema type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XML schema type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType() : saml1__Conditions(), saml1__Advice(), __size_AssertionType(), __union_AssertionType(), ds__Signature(), MajorVersion(), MinorVersion(), AssertionID(), Issuer(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:190 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (464)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XML schema type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XML schema type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XML schema type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType() : saml1__AudienceRestrictionCondition(), saml1__DoNotCacheCondition(), saml1__Condition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:64 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (433)
/* complex XML schema type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:66 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (434)
/* complex XML schema type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:232 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (470)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:72 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (437)
/* complex XML schema type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:74 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (438)
/* complex XML schema type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:78 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (440)
/* complex XML schema type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XML schema type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType() : saml1__NameIdentifier(), saml1__SubjectConfirmation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:82 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (442)
/* complex XML schema type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XML schema type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XML schema type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType() : __sizeConfirmationMethod(), saml1__ConfirmationMethod(), saml1__SubjectConfirmationData(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:86 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (444)
/* complex XML schema type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XML schema type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XML schema type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType() : IPAddress(), DNSAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:88 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (445)
/* complex XML schema type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XML schema type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XML schema type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XML schema type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType() : AuthorityKind(), Location(), Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:354 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (476)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:94 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (448)
/* complex XML schema type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:98 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (450)
/* complex XML schema type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType() : AttributeName(), AttributeNamespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:68 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (435)
/* complex XML schema type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XML schema type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType() : __sizeAudience(), saml1__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:70 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (436)
/* complex XML schema type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:76 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (439)
/* complex XML schema type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType() : saml1__Subject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:80 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (441)
/* simple XML schema type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        long soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType() : __item(), NameQualifier(), Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:92 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (447)
/* simple XML schema type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        long soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:100 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (451)
/* complex XML schema type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType() : AttributeName(), AttributeNamespace(), __sizeAttributeValue(), saml1__AttributeValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:84 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (443)
/* complex XML schema type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XML schema type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XML schema type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XML schema type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XML schema type 'xsd:dateTime' */
        time_t AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType() : saml1__Subject(), saml1__SubjectLocality(), __sizeAuthorityBinding(), saml1__AuthorityBinding(), AuthenticationMethod(), AuthenticationInstant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:90 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (446)
/* complex XML schema type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XML schema type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XML schema type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType() : saml1__Subject(), __sizeAction(), saml1__Action(), saml1__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:96 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (449)
/* complex XML schema type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XML schema type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType() : saml1__Subject(), __sizeAttribute(), saml1__Attribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:62 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (510)
/* complex XML schema type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType() : NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:66 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (512)
/* complex XML schema type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XML schema type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        long soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType() : xenc__EncryptedData(), __sizexenc__EncryptedKey(), xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:197 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (540)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XML schema type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XML schema type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XML schema type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XML schema type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType() : saml2__Statement(), saml2__AuthnStatement(), saml2__AuthzDecisionStatement(), saml2__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:68 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (513)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XML schema type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XML schema type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XML schema type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XML schema type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XML schema type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType() : saml2__Issuer(), ds__Signature(), saml2__Subject(), saml2__Conditions(), saml2__Advice(), __size_AssertionType(), __union_AssertionType(), Version(), ID(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:70 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (514)
/* complex XML schema type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), __sizeSubjectConfirmation(), saml2__SubjectConfirmation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:72 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (515)
/* complex XML schema type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XML schema type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XML schema type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), saml2__SubjectConfirmationData(), Method() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:290 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (550)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XML schema type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XML schema type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XML schema type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XML schema type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType() : saml2__Condition(), saml2__AudienceRestriction(), saml2__OneTimeUse(), saml2__ProxyRestriction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:78 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (518)
/* complex XML schema type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:80 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (519)
/* complex XML schema type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:334 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (556)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:88 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (523)
/* complex XML schema type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:90 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (524)
/* complex XML schema type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:94 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (526)
/* complex XML schema type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XML schema type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType() : Address(), DNSName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:96 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (527)
/* complex XML schema type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XML schema type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType() : saml2__AuthnContextClassRef(), saml2__AuthnContextDecl(), saml2__AuthnContextDeclRef(), __sizeAuthenticatingAuthority(), saml2__AuthenticatingAuthority() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:432 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (559)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:102 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (530)
/* complex XML schema type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:106 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (532)
/* complex XML schema type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XML schema type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XML schema type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XML schema type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType() : __sizeAttributeValue(), saml2__AttributeValue(), Name(), NameFormat(), FriendlyName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:64 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (511)
/* simple XML schema type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XML schema type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        long soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType() : __item(), Format(), SPProvidedID(), NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:74 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (516)
/* complex XML schema type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XML schema type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType() : NotBefore(), NotOnOrAfter(), Recipient(), InResponseTo(), Address(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:82 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (520)
/* complex XML schema type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType() : __sizeAudience(), saml2__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:84 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (521)
/* complex XML schema type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        long soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:86 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (522)
/* complex XML schema type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XML schema type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType() : __sizeAudience(), saml2__Audience(), Count() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:92 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (525)
/* complex XML schema type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XML schema type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XML schema type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XML schema type 'xsd:dateTime' */
        time_t AuthnInstant;
        /** Optional attribute 'SessionIndex' of XML schema type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XML schema type 'xsd:dateTime' */
        time_t *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType() : saml2__SubjectLocality(), saml2__AuthnContext(), AuthnInstant(), SessionIndex(), SessionNotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:98 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (528)
/* complex XML schema type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XML schema type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XML schema type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType() : __sizeAction(), saml2__Action(), saml2__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:100 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (529)
/* simple XML schema type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        long soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:674 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (565)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XML schema type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType() : saml2__Attribute(), saml2__EncryptedAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:104 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (531)
/* complex XML schema type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XML schema type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType() : __size_AttributeStatementType(), __union_AttributeStatementType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:76 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (517)
/* complex XML schema type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType() : __sizeds__KeyInfo(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:194 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (602)
/* complex XML schema type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XML schema type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XML schema type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XML schema type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XML schema type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XML schema type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XML schema type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        long soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security() : wsu__Timestamp(), UsernameToken(), BinarySecurityToken(), xenc__EncryptedKey(), xenc__ReferenceList(), wsc__SecurityContextToken(), ds__Signature(), saml1__Assertion(), saml2__Assertion(), SOAP_ENV__actor(), SOAP_ENV__role() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:130 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (350)
/* simple XML schema type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        long soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:226 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (608)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
        /** Optional element 'wsa5:MessageID' of XML schema type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XML schema type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XML schema type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XML schema type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
        /** Sequence of elements 'wst:IssuedTokens' of XML schema type 'wst:RequestSecurityTokenResponseCollectionType' stored in dynamic array wst__IssuedTokens of length __sizeIssuedTokens */
        int __sizeIssuedTokens;
        struct wst__RequestSecurityTokenResponseCollectionType *wst__IssuedTokens;
        /** Optional element 'wst:RequestType' of XML schema type 'xsd:string' */
        char *wst__RequestType;
        /** Optional element 'wsrm:Sequence' of XML schema type 'wsrm:SequenceType' */
        struct wsrm__SequenceType *wsrm__Sequence;
        /** Sequence of elements 'wsrm:AckRequested' of XML schema type 'wsrm:AckRequestedType' stored in dynamic array wsrm__AckRequested of length __sizeAckRequested */
        int __sizeAckRequested;
        struct wsrm__AckRequestedType *wsrm__AckRequested;
        /** Sequence of elements 'wsrm:SequenceAcknowledgement' of XML schema type 'wsrm:SequenceAcknowledgement' stored in dynamic array wsrm__SequenceAcknowledgement of length __sizeSequenceAcknowledgement */
        int __sizeSequenceAcknowledgement;
        struct _wsrm__SequenceAcknowledgement *wsrm__SequenceAcknowledgement;
        /** Optional element 'wsrm:SequenceFault' of XML schema type 'wsrm:SequenceFaultType' */
        struct wsrm__SequenceFaultType *wsrm__SequenceFault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsse__Security(), wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance(), __sizeIssuedTokens(), wst__IssuedTokens(), wst__RequestType(), wsrm__Sequence(), __sizeAckRequested(), wsrm__AckRequested(), __sizeSequenceAcknowledgement(), wsrm__SequenceAcknowledgement(), wsrm__SequenceFault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:64 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (610)
/* complex XML schema type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XML schema type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XML schema type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:67 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (611)
/* complex XML schema type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XML schema type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:70 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (612)
/* complex XML schema type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:85 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (614)
/* complex XML schema type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XML schema type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XML schema type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:73 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (613)
/* simple XML schema type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XML schema type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:259 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (636)
/* simple XML schema type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XML schema type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XML schema type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:282 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (642)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (644)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (646)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:289 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (650)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsp_appliesto.h:6 */
#ifndef SOAP_TYPE__wsp__AppliesTo_
#define SOAP_TYPE__wsp__AppliesTo_ (651)
/* complex XML schema type 'wsp:AppliesTo': */
struct SOAP_CMAC _wsp__AppliesTo_ {
      public:
        /** Optional element 'wsa5:EndpointReference' of XML schema type 'wsa5:EndpointReferenceType' */
        struct wsa5__EndpointReferenceType *wsa5__EndpointReference;
      public:
        /** Return unique type id SOAP_TYPE__wsp__AppliesTo_ */
        long soap_type() const { return SOAP_TYPE__wsp__AppliesTo_; }
        /** Constructor with member initializations */
        _wsp__AppliesTo_() : wsa5__EndpointReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsp__AppliesTo_ * SOAP_FMAC2 soap_instantiate__wsp__AppliesTo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:65 */
#ifndef SOAP_TYPE_wst__RequestedSecurityTokenType
#define SOAP_TYPE_wst__RequestedSecurityTokenType (655)
/* complex XML schema type 'wst:RequestedSecurityTokenType': */
struct SOAP_CMAC wst__RequestedSecurityTokenType {
      public:
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:SecurityContextToken' of XML schema type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestedSecurityTokenType */
        long soap_type() const { return SOAP_TYPE_wst__RequestedSecurityTokenType; }
        /** Constructor with member initializations */
        wst__RequestedSecurityTokenType() : saml1__Assertion(), saml2__Assertion(), wsse__SecurityTokenReference(), wsc__SecurityContextToken() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestedSecurityTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestedSecurityTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:77 */
#ifndef SOAP_TYPE_wst__EntropyType
#define SOAP_TYPE_wst__EntropyType (658)
/* complex XML schema type 'wst:EntropyType': */
struct SOAP_CMAC wst__EntropyType {
      public:
        /** Optional element 'wst:BinarySecret' of XML schema type 'wst:BinarySecretType' */
        struct wst__BinarySecretType *BinarySecret;
      public:
        /** Return unique type id SOAP_TYPE_wst__EntropyType */
        long soap_type() const { return SOAP_TYPE_wst__EntropyType; }
        /** Constructor with member initializations */
        wst__EntropyType() : BinarySecret() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__EntropyType * SOAP_FMAC2 soap_instantiate_wst__EntropyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:114 */
#ifndef SOAP_TYPE_wst__AuthenticatorType
#define SOAP_TYPE_wst__AuthenticatorType (676)
/* complex XML schema type 'wst:AuthenticatorType': */
struct SOAP_CMAC wst__AuthenticatorType {
      public:
        /** Optional element 'wst:CombinedHash' of XML schema type 'xsd:string' */
        char *CombinedHash;
      public:
        /** Return unique type id SOAP_TYPE_wst__AuthenticatorType */
        long soap_type() const { return SOAP_TYPE_wst__AuthenticatorType; }
        /** Constructor with member initializations */
        wst__AuthenticatorType() : CombinedHash() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__AuthenticatorType * SOAP_FMAC2 soap_instantiate_wst__AuthenticatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:58 */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenType
#define SOAP_TYPE_wst__RequestSecurityTokenType (653)
/* complex XML schema type 'wst:RequestSecurityTokenType': */
struct SOAP_CMAC wst__RequestSecurityTokenType {
      public:
        /** Optional attribute 'Context' of XML schema type 'xsd:string' */
        char *Context;
        /** Optional element 'wsp:AppliesTo' of XML schema type 'wsp:AppliesTo' */
        struct _wsp__AppliesTo_ *wsp__AppliesTo;
        /** Optional element 'wst:KeyType' of XML schema type 'xsd:string' */
        char *KeyType;
        /** Optional element 'wst:RequestType' of XML schema type 'xsd:string' */
        char *RequestType;
        /** Optional element 'wst:TokenType' of XML schema type 'xsd:string' */
        char *TokenType;
        /** Optional element 'wst:Entropy' of XML schema type 'wst:EntropyType' */
        struct wst__EntropyType *Entropy;
        /** Optional element 'wst:ComputedKeyAlgorithm' of XML schema type 'xsd:string' */
        char *ComputedKeyAlgorithm;
        /** Optional element 'wst:KeySize' of XML schema type 'xsd:unsignedInt' */
        unsigned int *KeySize;
        /** Optional element 'wst:BinaryExchange' of XML schema type 'wst:BinaryExchangeType' */
        struct wst__BinaryExchangeType *BinaryExchange;
        /** Optional element 'wst:Authenticator' of XML schema type 'wst:AuthenticatorType' */
        struct wst__AuthenticatorType *Authenticator;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestSecurityTokenType */
        long soap_type() const { return SOAP_TYPE_wst__RequestSecurityTokenType; }
        /** Constructor with member initializations */
        wst__RequestSecurityTokenType() : Context(), wsp__AppliesTo(), KeyType(), RequestType(), TokenType(), Entropy(), ComputedKeyAlgorithm(), KeySize(), BinaryExchange(), Authenticator() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestSecurityTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:60 */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenResponseType
#define SOAP_TYPE_wst__RequestSecurityTokenResponseType (654)
/* complex XML schema type 'wst:RequestSecurityTokenResponseType': */
struct SOAP_CMAC wst__RequestSecurityTokenResponseType {
      public:
        /** Optional attribute 'Context' of XML schema type 'xsd:string' */
        char *Context;
        /** Optional element 'wst:RequestedSecurityToken' of XML schema type 'wst:RequestedSecurityTokenType' */
        struct wst__RequestedSecurityTokenType *RequestedSecurityToken;
        /** Optional element 'wst:RequestedAttachedReference' of XML schema type 'wst:RequestedReferenceType' */
        struct wst__RequestedReferenceType *RequestedAttachedReference;
        /** Optional element 'wst:RequestedUnattachedReference' of XML schema type 'wst:RequestedReferenceType' */
        struct wst__RequestedReferenceType *RequestedUnattachedReference;
        /** Optional element 'wst:RequestedProofToken' of XML schema type 'wst:RequestedProofTokenType' */
        struct wst__RequestedProofTokenType *RequestedProofToken;
        /** Optional element 'wst:KeyType' of XML schema type 'xsd:string' */
        char *KeyType;
        /** Optional element 'wst:RequestType' of XML schema type 'xsd:string' */
        char *RequestType;
        /** Optional element 'wst:TokenType' of XML schema type 'xsd:string' */
        char *TokenType;
        /** Optional element 'wst:Entropy' of XML schema type 'wst:EntropyType' */
        struct wst__EntropyType *Entropy;
        /** Optional element 'wst:Lifetime' of XML schema type 'wst:LifetimeType' */
        struct wst__LifetimeType *Lifetime;
        /** Optional element 'wst:KeySize' of XML schema type 'xsd:unsignedInt' */
        unsigned int *KeySize;
        /** Optional element 'wst:BinaryExchange' of XML schema type 'wst:BinaryExchangeType' */
        struct wst__BinaryExchangeType *BinaryExchange;
        /** Optional element 'wst:Authenticator' of XML schema type 'wst:AuthenticatorType' */
        struct wst__AuthenticatorType *Authenticator;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestSecurityTokenResponseType */
        long soap_type() const { return SOAP_TYPE_wst__RequestSecurityTokenResponseType; }
        /** Constructor with member initializations */
        wst__RequestSecurityTokenResponseType() : Context(), RequestedSecurityToken(), RequestedAttachedReference(), RequestedUnattachedReference(), RequestedProofToken(), KeyType(), RequestType(), TokenType(), Entropy(), Lifetime(), KeySize(), BinaryExchange(), Authenticator() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestSecurityTokenResponseType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:74 */
#ifndef SOAP_TYPE_wst__ClaimsType
#define SOAP_TYPE_wst__ClaimsType (657)
/* complex XML schema type 'wst:ClaimsType': */
struct SOAP_CMAC wst__ClaimsType {
      public:
        /** Optional attribute 'Dialect' of XML schema type 'xsd:string' */
        char *Dialect;
      public:
        /** Return unique type id SOAP_TYPE_wst__ClaimsType */
        long soap_type() const { return SOAP_TYPE_wst__ClaimsType; }
        /** Constructor with member initializations */
        wst__ClaimsType() : Dialect() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__ClaimsType * SOAP_FMAC2 soap_instantiate_wst__ClaimsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:81 */
#ifndef SOAP_TYPE_wst__LifetimeType
#define SOAP_TYPE_wst__LifetimeType (660)
/* complex XML schema type 'wst:LifetimeType': */
struct SOAP_CMAC wst__LifetimeType {
      public:
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *wsu__Created;
        /** Optional element 'wsu:Expires' of XML schema type 'xsd:string' */
        char *wsu__Expires;
      public:
        /** Return unique type id SOAP_TYPE_wst__LifetimeType */
        long soap_type() const { return SOAP_TYPE_wst__LifetimeType; }
        /** Constructor with member initializations */
        wst__LifetimeType() : wsu__Created(), wsu__Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__LifetimeType * SOAP_FMAC2 soap_instantiate_wst__LifetimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:83 */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenCollectionType
#define SOAP_TYPE_wst__RequestSecurityTokenCollectionType (661)
/* complex XML schema type 'wst:RequestSecurityTokenCollectionType': */
struct SOAP_CMAC wst__RequestSecurityTokenCollectionType {
      public:
        /** Sequence of at least 2 elements 'wst:RequestSecurityToken' of XML schema type 'wst:RequestSecurityTokenType' stored in dynamic array RequestSecurityToken of length __sizeRequestSecurityToken */
        int __sizeRequestSecurityToken;
        struct wst__RequestSecurityTokenType *RequestSecurityToken;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestSecurityTokenCollectionType */
        long soap_type() const { return SOAP_TYPE_wst__RequestSecurityTokenCollectionType; }
        /** Constructor with member initializations */
        wst__RequestSecurityTokenCollectionType() : __sizeRequestSecurityToken(), RequestSecurityToken() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestSecurityTokenCollectionType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:85 */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType
#define SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType (662)
/* complex XML schema type 'wst:RequestSecurityTokenResponseCollectionType': */
struct SOAP_CMAC wst__RequestSecurityTokenResponseCollectionType {
      public:
        /** Sequence of at least 1 elements 'wst:RequestSecurityTokenResponse' of XML schema type 'wst:RequestSecurityTokenResponseType' stored in dynamic array RequestSecurityTokenResponse of length __sizeRequestSecurityTokenResponse */
        int __sizeRequestSecurityTokenResponse;
        struct wst__RequestSecurityTokenResponseType *RequestSecurityTokenResponse;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType */
        long soap_type() const { return SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType; }
        /** Constructor with member initializations */
        wst__RequestSecurityTokenResponseCollectionType() : __sizeRequestSecurityTokenResponse(), RequestSecurityTokenResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestSecurityTokenResponseCollectionType * SOAP_FMAC2 soap_instantiate_wst__RequestSecurityTokenResponseCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:87 */
#ifndef SOAP_TYPE_wst__RequestedReferenceType
#define SOAP_TYPE_wst__RequestedReferenceType (663)
/* complex XML schema type 'wst:RequestedReferenceType': */
struct SOAP_CMAC wst__RequestedReferenceType {
      public:
        /** Required element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference wsse__SecurityTokenReference;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestedReferenceType */
        long soap_type() const { return SOAP_TYPE_wst__RequestedReferenceType; }
        /** Constructor with member initializations */
        wst__RequestedReferenceType() : wsse__SecurityTokenReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestedReferenceType * SOAP_FMAC2 soap_instantiate_wst__RequestedReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:89 */
#ifndef SOAP_TYPE_wst__RequestedProofTokenType
#define SOAP_TYPE_wst__RequestedProofTokenType (664)
/* complex XML schema type 'wst:RequestedProofTokenType': */
struct SOAP_CMAC wst__RequestedProofTokenType {
      public:
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestedProofTokenType */
        long soap_type() const { return SOAP_TYPE_wst__RequestedProofTokenType; }
        /** Constructor with member initializations */
        wst__RequestedProofTokenType() : xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestedProofTokenType * SOAP_FMAC2 soap_instantiate_wst__RequestedProofTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:91 */
#ifndef SOAP_TYPE_wst__RenewTargetType
#define SOAP_TYPE_wst__RenewTargetType (665)
/* complex XML schema type 'wst:RenewTargetType': */
struct SOAP_CMAC wst__RenewTargetType {
      public:
        /** Return unique type id SOAP_TYPE_wst__RenewTargetType */
        long soap_type() const { return SOAP_TYPE_wst__RenewTargetType; }
        /** Constructor with member initializations */
        wst__RenewTargetType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RenewTargetType * SOAP_FMAC2 soap_instantiate_wst__RenewTargetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:93 */
#ifndef SOAP_TYPE_wst__AllowPostdatingType
#define SOAP_TYPE_wst__AllowPostdatingType (666)
/* complex XML schema type 'wst:AllowPostdatingType': */
struct SOAP_CMAC wst__AllowPostdatingType {
      public:
        /** Return unique type id SOAP_TYPE_wst__AllowPostdatingType */
        long soap_type() const { return SOAP_TYPE_wst__AllowPostdatingType; }
        /** Constructor with member initializations */
        wst__AllowPostdatingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__AllowPostdatingType * SOAP_FMAC2 soap_instantiate_wst__AllowPostdatingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:95 */
#ifndef SOAP_TYPE_wst__RenewingType
#define SOAP_TYPE_wst__RenewingType (667)
/* complex XML schema type 'wst:RenewingType': */
struct SOAP_CMAC wst__RenewingType {
      public:
        /** Optional attribute 'Allow' of XML schema type 'xsd:string' */
        char *Allow;
        /** Optional attribute 'OK' of XML schema type 'xsd:string' */
        char *OK;
      public:
        /** Return unique type id SOAP_TYPE_wst__RenewingType */
        long soap_type() const { return SOAP_TYPE_wst__RenewingType; }
        /** Constructor with member initializations */
        wst__RenewingType() : Allow(), OK() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RenewingType * SOAP_FMAC2 soap_instantiate_wst__RenewingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:97 */
#ifndef SOAP_TYPE_wst__CancelTargetType
#define SOAP_TYPE_wst__CancelTargetType (668)
/* complex XML schema type 'wst:CancelTargetType': */
struct SOAP_CMAC wst__CancelTargetType {
      public:
        /** Return unique type id SOAP_TYPE_wst__CancelTargetType */
        long soap_type() const { return SOAP_TYPE_wst__CancelTargetType; }
        /** Constructor with member initializations */
        wst__CancelTargetType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__CancelTargetType * SOAP_FMAC2 soap_instantiate_wst__CancelTargetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:99 */
#ifndef SOAP_TYPE_wst__RequestedTokenCancelledType
#define SOAP_TYPE_wst__RequestedTokenCancelledType (669)
/* complex XML schema type 'wst:RequestedTokenCancelledType': */
struct SOAP_CMAC wst__RequestedTokenCancelledType {
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestedTokenCancelledType */
        long soap_type() const { return SOAP_TYPE_wst__RequestedTokenCancelledType; }
        /** Constructor with member initializations */
        wst__RequestedTokenCancelledType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestedTokenCancelledType * SOAP_FMAC2 soap_instantiate_wst__RequestedTokenCancelledType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:101 */
#ifndef SOAP_TYPE_wst__ValidateTargetType
#define SOAP_TYPE_wst__ValidateTargetType (670)
/* complex XML schema type 'wst:ValidateTargetType': */
struct SOAP_CMAC wst__ValidateTargetType {
      public:
        /** Return unique type id SOAP_TYPE_wst__ValidateTargetType */
        long soap_type() const { return SOAP_TYPE_wst__ValidateTargetType; }
        /** Constructor with member initializations */
        wst__ValidateTargetType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__ValidateTargetType * SOAP_FMAC2 soap_instantiate_wst__ValidateTargetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:103 */
#ifndef SOAP_TYPE_wst__StatusType
#define SOAP_TYPE_wst__StatusType (671)
/* complex XML schema type 'wst:StatusType': */
struct SOAP_CMAC wst__StatusType {
      public:
        /** Required element 'wst:Code' of XML schema type 'xsd:string' */
        char *Code;
        /** Optional element 'wst:Reason' of XML schema type 'xsd:string' */
        char *Reason;
      public:
        /** Return unique type id SOAP_TYPE_wst__StatusType */
        long soap_type() const { return SOAP_TYPE_wst__StatusType; }
        /** Constructor with member initializations */
        wst__StatusType() : Code(), Reason() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__StatusType * SOAP_FMAC2 soap_instantiate_wst__StatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:105 */
#ifndef SOAP_TYPE_wst__SignChallengeType
#define SOAP_TYPE_wst__SignChallengeType (672)
/* complex XML schema type 'wst:SignChallengeType': */
struct SOAP_CMAC wst__SignChallengeType {
      public:
        /** Required element 'wst:Challenge' of XML schema type 'xsd:string' */
        char *Challenge;
      public:
        /** Return unique type id SOAP_TYPE_wst__SignChallengeType */
        long soap_type() const { return SOAP_TYPE_wst__SignChallengeType; }
        /** Constructor with member initializations */
        wst__SignChallengeType() : Challenge() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__SignChallengeType * SOAP_FMAC2 soap_instantiate_wst__SignChallengeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:109 */
#ifndef SOAP_TYPE_wst__RequestKETType
#define SOAP_TYPE_wst__RequestKETType (674)
/* complex XML schema type 'wst:RequestKETType': */
struct SOAP_CMAC wst__RequestKETType {
      public:
        /** Return unique type id SOAP_TYPE_wst__RequestKETType */
        long soap_type() const { return SOAP_TYPE_wst__RequestKETType; }
        /** Constructor with member initializations */
        wst__RequestKETType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__RequestKETType * SOAP_FMAC2 soap_instantiate_wst__RequestKETType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:111 */
#ifndef SOAP_TYPE_wst__KeyExchangeTokenType
#define SOAP_TYPE_wst__KeyExchangeTokenType (675)
/* complex XML schema type 'wst:KeyExchangeTokenType': */
struct SOAP_CMAC wst__KeyExchangeTokenType {
      public:
        /** Return unique type id SOAP_TYPE_wst__KeyExchangeTokenType */
        long soap_type() const { return SOAP_TYPE_wst__KeyExchangeTokenType; }
        /** Constructor with member initializations */
        wst__KeyExchangeTokenType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__KeyExchangeTokenType * SOAP_FMAC2 soap_instantiate_wst__KeyExchangeTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:118 */
#ifndef SOAP_TYPE_wst__OnBehalfOfType
#define SOAP_TYPE_wst__OnBehalfOfType (677)
/* complex XML schema type 'wst:OnBehalfOfType': */
struct SOAP_CMAC wst__OnBehalfOfType {
      public:
        /** Return unique type id SOAP_TYPE_wst__OnBehalfOfType */
        long soap_type() const { return SOAP_TYPE_wst__OnBehalfOfType; }
        /** Constructor with member initializations */
        wst__OnBehalfOfType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__OnBehalfOfType * SOAP_FMAC2 soap_instantiate_wst__OnBehalfOfType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:120 */
#ifndef SOAP_TYPE_wst__EncryptionType
#define SOAP_TYPE_wst__EncryptionType (678)
/* complex XML schema type 'wst:EncryptionType': */
struct SOAP_CMAC wst__EncryptionType {
      public:
        /** Return unique type id SOAP_TYPE_wst__EncryptionType */
        long soap_type() const { return SOAP_TYPE_wst__EncryptionType; }
        /** Constructor with member initializations */
        wst__EncryptionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__EncryptionType * SOAP_FMAC2 soap_instantiate_wst__EncryptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:122 */
#ifndef SOAP_TYPE_wst__ProofEncryptionType
#define SOAP_TYPE_wst__ProofEncryptionType (679)
/* complex XML schema type 'wst:ProofEncryptionType': */
struct SOAP_CMAC wst__ProofEncryptionType {
      public:
        /** Return unique type id SOAP_TYPE_wst__ProofEncryptionType */
        long soap_type() const { return SOAP_TYPE_wst__ProofEncryptionType; }
        /** Constructor with member initializations */
        wst__ProofEncryptionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__ProofEncryptionType * SOAP_FMAC2 soap_instantiate_wst__ProofEncryptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:124 */
#ifndef SOAP_TYPE_wst__UseKeyType
#define SOAP_TYPE_wst__UseKeyType (680)
/* complex XML schema type 'wst:UseKeyType': */
struct SOAP_CMAC wst__UseKeyType {
      public:
        /** Optional attribute 'Sig' of XML schema type 'xsd:string' */
        char *Sig;
      public:
        /** Return unique type id SOAP_TYPE_wst__UseKeyType */
        long soap_type() const { return SOAP_TYPE_wst__UseKeyType; }
        /** Constructor with member initializations */
        wst__UseKeyType() : Sig() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__UseKeyType * SOAP_FMAC2 soap_instantiate_wst__UseKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:126 */
#ifndef SOAP_TYPE_wst__DelegateToType
#define SOAP_TYPE_wst__DelegateToType (681)
/* complex XML schema type 'wst:DelegateToType': */
struct SOAP_CMAC wst__DelegateToType {
      public:
        /** Return unique type id SOAP_TYPE_wst__DelegateToType */
        long soap_type() const { return SOAP_TYPE_wst__DelegateToType; }
        /** Constructor with member initializations */
        wst__DelegateToType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__DelegateToType * SOAP_FMAC2 soap_instantiate_wst__DelegateToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:128 */
#ifndef SOAP_TYPE_wst__ParticipantsType
#define SOAP_TYPE_wst__ParticipantsType (682)
/* complex XML schema type 'wst:ParticipantsType': */
struct SOAP_CMAC wst__ParticipantsType {
      public:
        /** Optional element 'wst:Primary' of XML schema type 'wst:ParticipantType' */
        struct wst__ParticipantType *Primary;
        /** Sequence of elements 'wst:Participant' of XML schema type 'wst:ParticipantType' stored in dynamic array Participant of length __sizeParticipant */
        int __sizeParticipant;
        struct wst__ParticipantType *Participant;
      public:
        /** Return unique type id SOAP_TYPE_wst__ParticipantsType */
        long soap_type() const { return SOAP_TYPE_wst__ParticipantsType; }
        /** Constructor with member initializations */
        wst__ParticipantsType() : Primary(), __sizeParticipant(), Participant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__ParticipantsType * SOAP_FMAC2 soap_instantiate_wst__ParticipantsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:130 */
#ifndef SOAP_TYPE_wst__ParticipantType
#define SOAP_TYPE_wst__ParticipantType (683)
/* complex XML schema type 'wst:ParticipantType': */
struct SOAP_CMAC wst__ParticipantType {
      public:
        /** Return unique type id SOAP_TYPE_wst__ParticipantType */
        long soap_type() const { return SOAP_TYPE_wst__ParticipantType; }
        /** Constructor with member initializations */
        wst__ParticipantType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__ParticipantType * SOAP_FMAC2 soap_instantiate_wst__ParticipantType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:72 */
#ifndef SOAP_TYPE_wst__BinarySecretType
#define SOAP_TYPE_wst__BinarySecretType (656)
/* simple XML schema type 'wst:BinarySecretType': */
struct SOAP_CMAC wst__BinarySecretType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_wst__BinarySecretType */
        long soap_type() const { return SOAP_TYPE_wst__BinarySecretType; }
        /** Constructor with member initializations */
        wst__BinarySecretType() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__BinarySecretType * SOAP_FMAC2 soap_instantiate_wst__BinarySecretType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:107 */
#ifndef SOAP_TYPE_wst__BinaryExchangeType
#define SOAP_TYPE_wst__BinaryExchangeType (673)
/* simple XML schema type 'wst:BinaryExchangeType': */
struct SOAP_CMAC wst__BinaryExchangeType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Required attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE_wst__BinaryExchangeType */
        long soap_type() const { return SOAP_TYPE_wst__BinaryExchangeType; }
        /** Constructor with member initializations */
        wst__BinaryExchangeType() : __item(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wst__BinaryExchangeType * SOAP_FMAC2 soap_instantiate_wst__BinaryExchangeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wstx.h:74 */
#ifndef SOAP_TYPE___wst__RequestSecurityToken
#define SOAP_TYPE___wst__RequestSecurityToken (749)
/* Wrapper: */
struct SOAP_CMAC __wst__RequestSecurityToken {
      public:
        /** Optional element 'wst:RequestSecurityToken' of XML schema type 'wst:RequestSecurityTokenType' */
        struct wst__RequestSecurityTokenType *wst__RequestSecurityToken;
      public:
        /** Return unique type id SOAP_TYPE___wst__RequestSecurityToken */
        long soap_type() const { return SOAP_TYPE___wst__RequestSecurityToken; }
        /** Constructor with member initializations */
        __wst__RequestSecurityToken() : wst__RequestSecurityToken() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wst__RequestSecurityToken * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wstx.h:89 */
#ifndef SOAP_TYPE___wst__RequestSecurityTokenResponse
#define SOAP_TYPE___wst__RequestSecurityTokenResponse (751)
/* Wrapper: */
struct SOAP_CMAC __wst__RequestSecurityTokenResponse {
      public:
        /** Optional element 'wst:RequestSecurityTokenResponse' of XML schema type 'wst:RequestSecurityTokenResponseType' */
        struct wst__RequestSecurityTokenResponseType *wst__RequestSecurityTokenResponse;
      public:
        /** Return unique type id SOAP_TYPE___wst__RequestSecurityTokenResponse */
        long soap_type() const { return SOAP_TYPE___wst__RequestSecurityTokenResponse; }
        /** Constructor with member initializations */
        __wst__RequestSecurityTokenResponse() : wst__RequestSecurityTokenResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wst__RequestSecurityTokenResponse * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityTokenResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wstx.h:104 */
#ifndef SOAP_TYPE___wst__RequestSecurityTokenCollection
#define SOAP_TYPE___wst__RequestSecurityTokenCollection (754)
/* Wrapper: */
struct SOAP_CMAC __wst__RequestSecurityTokenCollection {
      public:
        /** Optional element 'wst:RequestSecurityTokenCollection' of XML schema type 'wst:RequestSecurityTokenCollectionType' */
        struct wst__RequestSecurityTokenCollectionType *wst__RequestSecurityTokenCollection;
      public:
        /** Return unique type id SOAP_TYPE___wst__RequestSecurityTokenCollection */
        long soap_type() const { return SOAP_TYPE___wst__RequestSecurityTokenCollection; }
        /** Constructor with member initializations */
        __wst__RequestSecurityTokenCollection() : wst__RequestSecurityTokenCollection() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wst__RequestSecurityTokenCollection * SOAP_FMAC2 soap_instantiate___wst__RequestSecurityTokenCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:68 */
#ifndef SOAP_TYPE_wsrm__SequenceType
#define SOAP_TYPE_wsrm__SequenceType (755)
/* complex XML schema type 'wsrm:SequenceType': */
struct SOAP_CMAC wsrm__SequenceType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Required element 'wsrm:MessageNumber' of XML schema type 'xsd:unsignedLong' */
        ULONG64 MessageNumber;
        /** Optional element 'wsrm:LastMessage' of XML schema type 'wsrm:UsesSequenceSSL' */
        struct _wsrm__UsesSequenceSSL *LastMessage;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__SequenceType */
        long soap_type() const { return SOAP_TYPE_wsrm__SequenceType; }
        /** Constructor with member initializations */
        wsrm__SequenceType() : Identifier(), MessageNumber(), LastMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__SequenceType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:71 */
#ifndef SOAP_TYPE_wsrm__AckRequestedType
#define SOAP_TYPE_wsrm__AckRequestedType (756)
/* complex XML schema type 'wsrm:AckRequestedType': */
struct SOAP_CMAC wsrm__AckRequestedType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__AckRequestedType */
        long soap_type() const { return SOAP_TYPE_wsrm__AckRequestedType; }
        /** Constructor with member initializations */
        wsrm__AckRequestedType() : Identifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__AckRequestedType * SOAP_FMAC2 soap_instantiate_wsrm__AckRequestedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:74 */
#ifndef SOAP_TYPE_wsrm__SequenceFaultType
#define SOAP_TYPE_wsrm__SequenceFaultType (757)
/* complex XML schema type 'wsrm:SequenceFaultType': */
struct SOAP_CMAC wsrm__SequenceFaultType {
      public:
        /** Required element 'wsrm:FaultCode' of XML schema type 'wsrm:FaultCodes' */
        enum wsrm__FaultCodes FaultCode;
        /** Optional element 'wsrm:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *Detail;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__SequenceFaultType */
        long soap_type() const { return SOAP_TYPE_wsrm__SequenceFaultType; }
        /** Constructor with member initializations */
        wsrm__SequenceFaultType() : FaultCode(), Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__SequenceFaultType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:80 */
#ifndef SOAP_TYPE_wsrm__CreateSequenceType
#define SOAP_TYPE_wsrm__CreateSequenceType (758)
/* complex XML schema type 'wsrm:CreateSequenceType': */
struct SOAP_CMAC wsrm__CreateSequenceType {
      public:
        /** Required element 'wsrm:AcksTo' of XML schema type 'wsa5:EndpointReferenceType' */
        struct wsa5__EndpointReferenceType AcksTo;
        /** Optional element 'wsrm:Expires' of XML schema type 'xsd:duration' */
        LONG64 *Expires;
        /** Optional element 'wsrm:Offer' of XML schema type 'wsrm:OfferType' */
        struct wsrm__OfferType *Offer;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__CreateSequenceType */
        long soap_type() const { return SOAP_TYPE_wsrm__CreateSequenceType; }
        /** Constructor with member initializations */
        wsrm__CreateSequenceType() : AcksTo(), Expires(), Offer() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__CreateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:83 */
#ifndef SOAP_TYPE_wsrm__CreateSequenceResponseType
#define SOAP_TYPE_wsrm__CreateSequenceResponseType (759)
/* complex XML schema type 'wsrm:CreateSequenceResponseType': */
struct SOAP_CMAC wsrm__CreateSequenceResponseType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsrm:Expires' of XML schema type 'xsd:duration' */
        LONG64 *Expires;
        /** Optional element 'wsrm:IncompleteSequenceBehavior' of XML schema type 'wsrm:IncompleteSequenceBehaviorType' */
        enum wsrm__IncompleteSequenceBehaviorType *IncompleteSequenceBehavior;
        /** Optional element 'wsrm:Accept' of XML schema type 'wsrm:AcceptType' */
        struct wsrm__AcceptType *Accept;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__CreateSequenceResponseType */
        long soap_type() const { return SOAP_TYPE_wsrm__CreateSequenceResponseType; }
        /** Constructor with member initializations */
        wsrm__CreateSequenceResponseType() : Identifier(), Expires(), IncompleteSequenceBehavior(), Accept() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__CreateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:86 */
#ifndef SOAP_TYPE_wsrm__CloseSequenceType
#define SOAP_TYPE_wsrm__CloseSequenceType (760)
/* complex XML schema type 'wsrm:CloseSequenceType': */
struct SOAP_CMAC wsrm__CloseSequenceType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__CloseSequenceType */
        long soap_type() const { return SOAP_TYPE_wsrm__CloseSequenceType; }
        /** Constructor with member initializations */
        wsrm__CloseSequenceType() : Identifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__CloseSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:89 */
#ifndef SOAP_TYPE_wsrm__CloseSequenceResponseType
#define SOAP_TYPE_wsrm__CloseSequenceResponseType (761)
/* complex XML schema type 'wsrm:CloseSequenceResponseType': */
struct SOAP_CMAC wsrm__CloseSequenceResponseType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__CloseSequenceResponseType */
        long soap_type() const { return SOAP_TYPE_wsrm__CloseSequenceResponseType; }
        /** Constructor with member initializations */
        wsrm__CloseSequenceResponseType() : Identifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__CloseSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:92 */
#ifndef SOAP_TYPE_wsrm__TerminateSequenceType
#define SOAP_TYPE_wsrm__TerminateSequenceType (762)
/* complex XML schema type 'wsrm:TerminateSequenceType': */
struct SOAP_CMAC wsrm__TerminateSequenceType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__TerminateSequenceType */
        long soap_type() const { return SOAP_TYPE_wsrm__TerminateSequenceType; }
        /** Constructor with member initializations */
        wsrm__TerminateSequenceType() : Identifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__TerminateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:95 */
#ifndef SOAP_TYPE_wsrm__TerminateSequenceResponseType
#define SOAP_TYPE_wsrm__TerminateSequenceResponseType (763)
/* complex XML schema type 'wsrm:TerminateSequenceResponseType': */
struct SOAP_CMAC wsrm__TerminateSequenceResponseType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__TerminateSequenceResponseType */
        long soap_type() const { return SOAP_TYPE_wsrm__TerminateSequenceResponseType; }
        /** Constructor with member initializations */
        wsrm__TerminateSequenceResponseType() : Identifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__TerminateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:98 */
#ifndef SOAP_TYPE_wsrm__OfferType
#define SOAP_TYPE_wsrm__OfferType (764)
/* complex XML schema type 'wsrm:OfferType': */
struct SOAP_CMAC wsrm__OfferType {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Required element 'wsrm:Endpoint' of XML schema type 'wsa5:EndpointReferenceType' */
        struct wsa5__EndpointReferenceType Endpoint;
        /** Optional element 'wsrm:Expires' of XML schema type 'xsd:duration' */
        LONG64 *Expires;
        /** Optional element 'wsrm:IncompleteSequenceBehavior' of XML schema type 'wsrm:IncompleteSequenceBehaviorType' */
        enum wsrm__IncompleteSequenceBehaviorType *IncompleteSequenceBehavior;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__OfferType */
        long soap_type() const { return SOAP_TYPE_wsrm__OfferType; }
        /** Constructor with member initializations */
        wsrm__OfferType() : Identifier(), Endpoint(), Expires(), IncompleteSequenceBehavior() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__OfferType * SOAP_FMAC2 soap_instantiate_wsrm__OfferType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:101 */
#ifndef SOAP_TYPE_wsrm__AcceptType
#define SOAP_TYPE_wsrm__AcceptType (765)
/* complex XML schema type 'wsrm:AcceptType': */
struct SOAP_CMAC wsrm__AcceptType {
      public:
        /** Required element 'wsrm:AcksTo' of XML schema type 'wsa5:EndpointReferenceType' */
        struct wsa5__EndpointReferenceType AcksTo;
      public:
        /** Return unique type id SOAP_TYPE_wsrm__AcceptType */
        long soap_type() const { return SOAP_TYPE_wsrm__AcceptType; }
        /** Constructor with member initializations */
        wsrm__AcceptType() : AcksTo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsrm__AcceptType * SOAP_FMAC2 soap_instantiate_wsrm__AcceptType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:391 */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_Final
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_Final (780)
/* complex XML schema type 'wsrm:SequenceAcknowledgement-Final': */
struct SOAP_CMAC _wsrm__SequenceAcknowledgement_Final {
      public:
        /** Return unique type id SOAP_TYPE__wsrm__SequenceAcknowledgement_Final */
        long soap_type() const { return SOAP_TYPE__wsrm__SequenceAcknowledgement_Final; }
        /** Constructor with member initializations */
        _wsrm__SequenceAcknowledgement_Final() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_Final(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:400 */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange (782)
/* complex XML schema type 'wsrm:SequenceAcknowledgement-AcknowledgementRange': */
struct SOAP_CMAC _wsrm__SequenceAcknowledgement_AcknowledgementRange {
      public:
        /** Required attribute 'Upper' of XML schema type 'xsd:unsignedLong' */
        ULONG64 Upper;
        /** Required attribute 'Lower' of XML schema type 'xsd:unsignedLong' */
        ULONG64 Lower;
      public:
        /** Return unique type id SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange */
        long soap_type() const { return SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange; }
        /** Constructor with member initializations */
        _wsrm__SequenceAcknowledgement_AcknowledgementRange() : Upper(), Lower() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:414 */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_None
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_None (784)
/* complex XML schema type 'wsrm:SequenceAcknowledgement-None': */
struct SOAP_CMAC _wsrm__SequenceAcknowledgement_None {
      public:
        /** Return unique type id SOAP_TYPE__wsrm__SequenceAcknowledgement_None */
        long soap_type() const { return SOAP_TYPE__wsrm__SequenceAcknowledgement_None; }
        /** Constructor with member initializations */
        _wsrm__SequenceAcknowledgement_None() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__SequenceAcknowledgement_None * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_None(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:104 */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement
#define SOAP_TYPE__wsrm__SequenceAcknowledgement (766)
/* complex XML schema type 'wsrm:SequenceAcknowledgement': */
struct SOAP_CMAC _wsrm__SequenceAcknowledgement {
      public:
        /** Required element 'wsrm:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Sequence of elements 'wsrm:Nack' of XML schema type 'xsd:unsignedLong' stored in dynamic array Nack of length __sizeNack */
        int __sizeNack;
        ULONG64 *Nack;
        /** Optional element 'wsrm:Final' of XML schema type 'wsrm:SequenceAcknowledgement-Final' */
        struct _wsrm__SequenceAcknowledgement_Final *Final;
        /** Sequence of elements 'wsrm:AcknowledgementRange' of XML schema type 'wsrm:SequenceAcknowledgement-AcknowledgementRange' stored in dynamic array AcknowledgementRange of length __sizeAcknowledgementRange */
        int __sizeAcknowledgementRange;
        struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *AcknowledgementRange;
        /** Optional element 'wsrm:None' of XML schema type 'wsrm:SequenceAcknowledgement-None' */
        struct _wsrm__SequenceAcknowledgement_None *None;
        /** Optional element 'netrm:BufferRemaining' of XML schema type 'xsd:int' */
        int *netrm__BufferRemaining;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE__wsrm__SequenceAcknowledgement */
        long soap_type() const { return SOAP_TYPE__wsrm__SequenceAcknowledgement; }
        /** Constructor with member initializations */
        _wsrm__SequenceAcknowledgement() : Identifier(), __sizeNack(), Nack(), Final(), __sizeAcknowledgementRange(), AcknowledgementRange(), None(), netrm__BufferRemaining(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:117 */
#ifndef SOAP_TYPE__wsrm__UsesSequenceSTR
#define SOAP_TYPE__wsrm__UsesSequenceSTR (771)
/* complex XML schema type 'wsrm:UsesSequenceSTR': */
struct SOAP_CMAC _wsrm__UsesSequenceSTR {
      public:
        /** Return unique type id SOAP_TYPE__wsrm__UsesSequenceSTR */
        long soap_type() const { return SOAP_TYPE__wsrm__UsesSequenceSTR; }
        /** Constructor with member initializations */
        _wsrm__UsesSequenceSTR() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__UsesSequenceSTR * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSTR(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrm5.h:120 */
#ifndef SOAP_TYPE__wsrm__UsesSequenceSSL
#define SOAP_TYPE__wsrm__UsesSequenceSSL (772)
/* complex XML schema type 'wsrm:UsesSequenceSSL': */
struct SOAP_CMAC _wsrm__UsesSequenceSSL {
      public:
        /** Return unique type id SOAP_TYPE__wsrm__UsesSequenceSSL */
        long soap_type() const { return SOAP_TYPE__wsrm__UsesSequenceSSL; }
        /** Constructor with member initializations */
        _wsrm__UsesSequenceSSL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsrm__UsesSequenceSSL * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSSL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:78 */
#ifndef SOAP_TYPE___wsrm__CreateSequence
#define SOAP_TYPE___wsrm__CreateSequence (793)
/* Wrapper: */
struct SOAP_CMAC __wsrm__CreateSequence {
      public:
        /** Optional element 'wsrm:CreateSequence' of XML schema type 'wsrm:CreateSequenceType' */
        struct wsrm__CreateSequenceType *wsrm__CreateSequence;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__CreateSequence */
        long soap_type() const { return SOAP_TYPE___wsrm__CreateSequence; }
        /** Constructor with member initializations */
        __wsrm__CreateSequence() : wsrm__CreateSequence() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__CreateSequence * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:91 */
#ifndef SOAP_TYPE___wsrm__CloseSequence
#define SOAP_TYPE___wsrm__CloseSequence (797)
/* Wrapper: */
struct SOAP_CMAC __wsrm__CloseSequence {
      public:
        /** Optional element 'wsrm:CloseSequence' of XML schema type 'wsrm:CloseSequenceType' */
        struct wsrm__CloseSequenceType *wsrm__CloseSequence;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__CloseSequence */
        long soap_type() const { return SOAP_TYPE___wsrm__CloseSequence; }
        /** Constructor with member initializations */
        __wsrm__CloseSequence() : wsrm__CloseSequence() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__CloseSequence * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:104 */
#ifndef SOAP_TYPE___wsrm__TerminateSequence
#define SOAP_TYPE___wsrm__TerminateSequence (801)
/* Wrapper: */
struct SOAP_CMAC __wsrm__TerminateSequence {
      public:
        /** Optional element 'wsrm:TerminateSequence' of XML schema type 'wsrm:TerminateSequenceType' */
        struct wsrm__TerminateSequenceType *wsrm__TerminateSequence;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__TerminateSequence */
        long soap_type() const { return SOAP_TYPE___wsrm__TerminateSequence; }
        /** Constructor with member initializations */
        __wsrm__TerminateSequence() : wsrm__TerminateSequence() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__TerminateSequence * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:114 */
#ifndef SOAP_TYPE___wsrm__CreateSequenceResponse
#define SOAP_TYPE___wsrm__CreateSequenceResponse (803)
/* Wrapper: */
struct SOAP_CMAC __wsrm__CreateSequenceResponse {
      public:
        /** Optional element 'wsrm:CreateSequenceResponse' of XML schema type 'wsrm:CreateSequenceResponseType' */
        struct wsrm__CreateSequenceResponseType *wsrm__CreateSequenceResponse;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__CreateSequenceResponse */
        long soap_type() const { return SOAP_TYPE___wsrm__CreateSequenceResponse; }
        /** Constructor with member initializations */
        __wsrm__CreateSequenceResponse() : wsrm__CreateSequenceResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__CreateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:124 */
#ifndef SOAP_TYPE___wsrm__CloseSequenceResponse
#define SOAP_TYPE___wsrm__CloseSequenceResponse (805)
/* Wrapper: */
struct SOAP_CMAC __wsrm__CloseSequenceResponse {
      public:
        /** Optional element 'wsrm:CloseSequenceResponse' of XML schema type 'wsrm:CloseSequenceResponseType' */
        struct wsrm__CloseSequenceResponseType *wsrm__CloseSequenceResponse;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__CloseSequenceResponse */
        long soap_type() const { return SOAP_TYPE___wsrm__CloseSequenceResponse; }
        /** Constructor with member initializations */
        __wsrm__CloseSequenceResponse() : wsrm__CloseSequenceResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__CloseSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:134 */
#ifndef SOAP_TYPE___wsrm__TerminateSequenceResponse
#define SOAP_TYPE___wsrm__TerminateSequenceResponse (807)
/* Wrapper: */
struct SOAP_CMAC __wsrm__TerminateSequenceResponse {
      public:
        /** Optional element 'wsrm:TerminateSequenceResponse' of XML schema type 'wsrm:TerminateSequenceResponseType' */
        struct wsrm__TerminateSequenceResponseType *wsrm__TerminateSequenceResponse;
      public:
        /** Return unique type id SOAP_TYPE___wsrm__TerminateSequenceResponse */
        long soap_type() const { return SOAP_TYPE___wsrm__TerminateSequenceResponse; }
        /** Constructor with member initializations */
        __wsrm__TerminateSequenceResponse() : wsrm__TerminateSequenceResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__TerminateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:144 */
#ifndef SOAP_TYPE___wsrm__SequenceAcknowledgement
#define SOAP_TYPE___wsrm__SequenceAcknowledgement (809)
/* Wrapper: */
struct SOAP_CMAC __wsrm__SequenceAcknowledgement {
      public:
        /** Return unique type id SOAP_TYPE___wsrm__SequenceAcknowledgement */
        long soap_type() const { return SOAP_TYPE___wsrm__SequenceAcknowledgement; }
        /** Constructor with member initializations */
        __wsrm__SequenceAcknowledgement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate___wsrm__SequenceAcknowledgement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:154 */
#ifndef SOAP_TYPE___wsrm__AckRequested
#define SOAP_TYPE___wsrm__AckRequested (811)
/* Wrapper: */
struct SOAP_CMAC __wsrm__AckRequested {
      public:
        /** Return unique type id SOAP_TYPE___wsrm__AckRequested */
        long soap_type() const { return SOAP_TYPE___wsrm__AckRequested; }
        /** Constructor with member initializations */
        __wsrm__AckRequested() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__AckRequested * SOAP_FMAC2 soap_instantiate___wsrm__AckRequested(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrx5.h:164 */
#ifndef SOAP_TYPE___wsrm__LastMessage
#define SOAP_TYPE___wsrm__LastMessage (813)
/* Wrapper: */
struct SOAP_CMAC __wsrm__LastMessage {
      public:
        /** Return unique type id SOAP_TYPE___wsrm__LastMessage */
        long soap_type() const { return SOAP_TYPE___wsrm__LastMessage; }
        /** Constructor with member initializations */
        __wsrm__LastMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsrm__LastMessage * SOAP_FMAC2 soap_instantiate___wsrm__LastMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* ds.h:44 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (363)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (369)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:76 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (377)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (384)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:59 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (421)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* saml1.h:580 */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (485)
typedef char *_saml1__AssertionIDReference;
#endif

/* saml1.h:583 */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (486)
typedef struct saml1__AssertionType _saml1__Assertion;
#endif

/* saml1.h:586 */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (487)
typedef struct saml1__ConditionsType _saml1__Conditions;
#endif

/* saml1.h:589 */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (488)
typedef struct saml1__ConditionAbstractType _saml1__Condition;
#endif

/* saml1.h:592 */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (489)
typedef struct saml1__AudienceRestrictionConditionType _saml1__AudienceRestrictionCondition;
#endif

/* saml1.h:595 */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (490)
typedef char *_saml1__Audience;
#endif

/* saml1.h:598 */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (491)
typedef struct saml1__DoNotCacheConditionType _saml1__DoNotCacheCondition;
#endif

/* saml1.h:601 */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (492)
typedef struct saml1__AdviceType _saml1__Advice;
#endif

/* saml1.h:604 */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (493)
typedef struct saml1__StatementAbstractType _saml1__Statement;
#endif

/* saml1.h:607 */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (494)
typedef struct saml1__SubjectStatementAbstractType _saml1__SubjectStatement;
#endif

/* saml1.h:610 */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (495)
typedef struct saml1__SubjectType _saml1__Subject;
#endif

/* saml1.h:613 */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (496)
typedef struct saml1__NameIdentifierType _saml1__NameIdentifier;
#endif

/* saml1.h:616 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (497)
typedef struct saml1__SubjectConfirmationType _saml1__SubjectConfirmation;
#endif

/* saml1.h:619 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (498)
typedef _XML _saml1__SubjectConfirmationData;
#endif

/* saml1.h:622 */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (499)
typedef char *_saml1__ConfirmationMethod;
#endif

/* saml1.h:625 */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (500)
typedef struct saml1__AuthenticationStatementType _saml1__AuthenticationStatement;
#endif

/* saml1.h:628 */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (501)
typedef struct saml1__SubjectLocalityType _saml1__SubjectLocality;
#endif

/* saml1.h:631 */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (502)
typedef struct saml1__AuthorityBindingType _saml1__AuthorityBinding;
#endif

/* saml1.h:634 */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (503)
typedef struct saml1__AuthorizationDecisionStatementType _saml1__AuthorizationDecisionStatement;
#endif

/* saml1.h:637 */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (504)
typedef struct saml1__ActionType _saml1__Action;
#endif

/* saml1.h:640 */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (505)
typedef struct saml1__EvidenceType _saml1__Evidence;
#endif

/* saml1.h:643 */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (506)
typedef struct saml1__AttributeStatementType _saml1__AttributeStatement;
#endif

/* saml1.h:646 */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (507)
typedef struct saml1__AttributeDesignatorType _saml1__AttributeDesignator;
#endif

/* saml1.h:649 */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (508)
typedef struct saml1__AttributeType _saml1__Attribute;
#endif

/* saml1.h:652 */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (509)
typedef _XML _saml1__AttributeValue;
#endif

/* saml2.h:726 */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (569)
typedef struct saml2__BaseIDAbstractType _saml2__BaseID;
#endif

/* saml2.h:729 */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (570)
typedef struct saml2__NameIDType _saml2__NameID;
#endif

/* saml2.h:732 */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (571)
typedef struct saml2__EncryptedElementType _saml2__EncryptedID;
#endif

/* saml2.h:735 */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (572)
typedef struct saml2__NameIDType _saml2__Issuer;
#endif

/* saml2.h:738 */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (573)
typedef char *_saml2__AssertionIDRef;
#endif

/* saml2.h:741 */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (574)
typedef char *_saml2__AssertionURIRef;
#endif

/* saml2.h:744 */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (575)
typedef struct saml2__AssertionType _saml2__Assertion;
#endif

/* saml2.h:747 */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (576)
typedef struct saml2__SubjectType _saml2__Subject;
#endif

/* saml2.h:750 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (577)
typedef struct saml2__SubjectConfirmationType _saml2__SubjectConfirmation;
#endif

/* saml2.h:753 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (578)
typedef struct saml2__SubjectConfirmationDataType _saml2__SubjectConfirmationData;
#endif

/* saml2.h:756 */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (579)
typedef struct saml2__ConditionsType _saml2__Conditions;
#endif

/* saml2.h:759 */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (580)
typedef struct saml2__ConditionAbstractType _saml2__Condition;
#endif

/* saml2.h:762 */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (581)
typedef struct saml2__AudienceRestrictionType _saml2__AudienceRestriction;
#endif

/* saml2.h:765 */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (582)
typedef char *_saml2__Audience;
#endif

/* saml2.h:768 */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (583)
typedef struct saml2__OneTimeUseType _saml2__OneTimeUse;
#endif

/* saml2.h:771 */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (584)
typedef struct saml2__ProxyRestrictionType _saml2__ProxyRestriction;
#endif

/* saml2.h:774 */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (585)
typedef struct saml2__AdviceType _saml2__Advice;
#endif

/* saml2.h:777 */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (586)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAssertion;
#endif

/* saml2.h:780 */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (587)
typedef struct saml2__StatementAbstractType _saml2__Statement;
#endif

/* saml2.h:783 */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (588)
typedef struct saml2__AuthnStatementType _saml2__AuthnStatement;
#endif

/* saml2.h:786 */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (589)
typedef struct saml2__SubjectLocalityType _saml2__SubjectLocality;
#endif

/* saml2.h:789 */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (590)
typedef struct saml2__AuthnContextType _saml2__AuthnContext;
#endif

/* saml2.h:792 */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (591)
typedef char *_saml2__AuthnContextClassRef;
#endif

/* saml2.h:795 */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (592)
typedef char *_saml2__AuthnContextDeclRef;
#endif

/* saml2.h:798 */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (593)
typedef _XML _saml2__AuthnContextDecl;
#endif

/* saml2.h:801 */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (594)
typedef char *_saml2__AuthenticatingAuthority;
#endif

/* saml2.h:804 */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (595)
typedef struct saml2__AuthzDecisionStatementType _saml2__AuthzDecisionStatement;
#endif

/* saml2.h:807 */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (596)
typedef struct saml2__ActionType _saml2__Action;
#endif

/* saml2.h:810 */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (597)
typedef struct saml2__EvidenceType _saml2__Evidence;
#endif

/* saml2.h:813 */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (598)
typedef struct saml2__AttributeStatementType _saml2__AttributeStatement;
#endif

/* saml2.h:816 */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (599)
typedef struct saml2__AttributeType _saml2__Attribute;
#endif

/* saml2.h:819 */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (600)
typedef _XML _saml2__AttributeValue;
#endif

/* saml2.h:822 */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (601)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAttribute;
#endif

/* wsa5.h:88 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (615)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:91 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (616)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:210 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (621)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:213 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (622)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:216 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (623)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:219 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (624)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:222 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (625)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:225 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (626)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:228 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (627)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:231 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (628)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:234 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (629)
typedef char *_wsa5__To;
#endif

/* wsa5.h:237 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (630)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:240 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (631)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:243 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (632)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:246 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (633)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:249 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (634)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* wst.h:821 */
#ifndef SOAP_TYPE__wst__RequestSecurityToken
#define SOAP_TYPE__wst__RequestSecurityToken (697)
typedef struct wst__RequestSecurityTokenType _wst__RequestSecurityToken;
#endif

/* wst.h:824 */
#ifndef SOAP_TYPE__wst__TokenType
#define SOAP_TYPE__wst__TokenType (698)
typedef char *_wst__TokenType;
#endif

/* wst.h:827 */
#ifndef SOAP_TYPE__wst__RequestType
#define SOAP_TYPE__wst__RequestType (699)
typedef char *_wst__RequestType;
#endif

/* wst.h:830 */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenResponse
#define SOAP_TYPE__wst__RequestSecurityTokenResponse (700)
typedef struct wst__RequestSecurityTokenResponseType _wst__RequestSecurityTokenResponse;
#endif

/* wst.h:833 */
#ifndef SOAP_TYPE__wst__RequestedSecurityToken
#define SOAP_TYPE__wst__RequestedSecurityToken (701)
typedef struct wst__RequestedSecurityTokenType _wst__RequestedSecurityToken;
#endif

/* wst.h:836 */
#ifndef SOAP_TYPE__wst__BinarySecret
#define SOAP_TYPE__wst__BinarySecret (702)
typedef struct wst__BinarySecretType _wst__BinarySecret;
#endif

/* wst.h:839 */
#ifndef SOAP_TYPE__wst__Claims
#define SOAP_TYPE__wst__Claims (703)
typedef struct wst__ClaimsType _wst__Claims;
#endif

/* wst.h:842 */
#ifndef SOAP_TYPE__wst__Entropy
#define SOAP_TYPE__wst__Entropy (704)
typedef struct wst__EntropyType _wst__Entropy;
#endif

/* wst.h:845 */
#ifndef SOAP_TYPE__wst__Lifetime
#define SOAP_TYPE__wst__Lifetime (705)
typedef struct wst__LifetimeType _wst__Lifetime;
#endif

/* wst.h:848 */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenCollection
#define SOAP_TYPE__wst__RequestSecurityTokenCollection (706)
typedef struct wst__RequestSecurityTokenCollectionType _wst__RequestSecurityTokenCollection;
#endif

/* wst.h:851 */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenResponseCollection
#define SOAP_TYPE__wst__RequestSecurityTokenResponseCollection (707)
typedef struct wst__RequestSecurityTokenResponseCollectionType _wst__RequestSecurityTokenResponseCollection;
#endif

/* wst.h:854 */
#ifndef SOAP_TYPE__wst__ComputedKey
#define SOAP_TYPE__wst__ComputedKey (708)
typedef char *_wst__ComputedKey;
#endif

/* wst.h:857 */
#ifndef SOAP_TYPE__wst__RequestedAttachedReference
#define SOAP_TYPE__wst__RequestedAttachedReference (709)
typedef struct wst__RequestedReferenceType _wst__RequestedAttachedReference;
#endif

/* wst.h:860 */
#ifndef SOAP_TYPE__wst__RequestedUnattachedReference
#define SOAP_TYPE__wst__RequestedUnattachedReference (710)
typedef struct wst__RequestedReferenceType _wst__RequestedUnattachedReference;
#endif

/* wst.h:863 */
#ifndef SOAP_TYPE__wst__RequestedProofToken
#define SOAP_TYPE__wst__RequestedProofToken (711)
typedef struct wst__RequestedProofTokenType _wst__RequestedProofToken;
#endif

/* wst.h:866 */
#ifndef SOAP_TYPE__wst__IssuedTokens
#define SOAP_TYPE__wst__IssuedTokens (712)
typedef struct wst__RequestSecurityTokenResponseCollectionType _wst__IssuedTokens;
#endif

/* wst.h:869 */
#ifndef SOAP_TYPE__wst__RenewTarget
#define SOAP_TYPE__wst__RenewTarget (713)
typedef struct wst__RenewTargetType _wst__RenewTarget;
#endif

/* wst.h:872 */
#ifndef SOAP_TYPE__wst__AllowPostdating
#define SOAP_TYPE__wst__AllowPostdating (714)
typedef struct wst__AllowPostdatingType _wst__AllowPostdating;
#endif

/* wst.h:875 */
#ifndef SOAP_TYPE__wst__Renewing
#define SOAP_TYPE__wst__Renewing (715)
typedef struct wst__RenewingType _wst__Renewing;
#endif

/* wst.h:878 */
#ifndef SOAP_TYPE__wst__CancelTarget
#define SOAP_TYPE__wst__CancelTarget (716)
typedef struct wst__CancelTargetType _wst__CancelTarget;
#endif

/* wst.h:881 */
#ifndef SOAP_TYPE__wst__RequestedTokenCancelled
#define SOAP_TYPE__wst__RequestedTokenCancelled (717)
typedef struct wst__RequestedTokenCancelledType _wst__RequestedTokenCancelled;
#endif

/* wst.h:884 */
#ifndef SOAP_TYPE__wst__ValidateTarget
#define SOAP_TYPE__wst__ValidateTarget (718)
typedef struct wst__ValidateTargetType _wst__ValidateTarget;
#endif

/* wst.h:887 */
#ifndef SOAP_TYPE__wst__Status
#define SOAP_TYPE__wst__Status (719)
typedef struct wst__StatusType _wst__Status;
#endif

/* wst.h:890 */
#ifndef SOAP_TYPE__wst__SignChallenge
#define SOAP_TYPE__wst__SignChallenge (720)
typedef struct wst__SignChallengeType _wst__SignChallenge;
#endif

/* wst.h:893 */
#ifndef SOAP_TYPE__wst__SignChallengeResponse
#define SOAP_TYPE__wst__SignChallengeResponse (721)
typedef struct wst__SignChallengeType _wst__SignChallengeResponse;
#endif

/* wst.h:896 */
#ifndef SOAP_TYPE__wst__Challenge
#define SOAP_TYPE__wst__Challenge (722)
typedef char *_wst__Challenge;
#endif

/* wst.h:899 */
#ifndef SOAP_TYPE__wst__BinaryExchange
#define SOAP_TYPE__wst__BinaryExchange (723)
typedef struct wst__BinaryExchangeType _wst__BinaryExchange;
#endif

/* wst.h:902 */
#ifndef SOAP_TYPE__wst__RequestKET
#define SOAP_TYPE__wst__RequestKET (724)
typedef struct wst__RequestKETType _wst__RequestKET;
#endif

/* wst.h:905 */
#ifndef SOAP_TYPE__wst__KeyExchangeToken
#define SOAP_TYPE__wst__KeyExchangeToken (725)
typedef struct wst__KeyExchangeTokenType _wst__KeyExchangeToken;
#endif

/* wst.h:908 */
#ifndef SOAP_TYPE__wst__Authenticator
#define SOAP_TYPE__wst__Authenticator (726)
typedef struct wst__AuthenticatorType _wst__Authenticator;
#endif

/* wst.h:911 */
#ifndef SOAP_TYPE__wst__CombinedHash
#define SOAP_TYPE__wst__CombinedHash (727)
typedef char *_wst__CombinedHash;
#endif

/* wst.h:914 */
#ifndef SOAP_TYPE__wst__OnBehalfOf
#define SOAP_TYPE__wst__OnBehalfOf (728)
typedef struct wst__OnBehalfOfType _wst__OnBehalfOf;
#endif

/* wst.h:917 */
#ifndef SOAP_TYPE__wst__Issuer
#define SOAP_TYPE__wst__Issuer (729)
typedef struct wsa5__EndpointReferenceType _wst__Issuer;
#endif

/* wst.h:920 */
#ifndef SOAP_TYPE__wst__AuthenticationType
#define SOAP_TYPE__wst__AuthenticationType (730)
typedef char *_wst__AuthenticationType;
#endif

/* wst.h:923 */
#ifndef SOAP_TYPE__wst__KeyType
#define SOAP_TYPE__wst__KeyType (731)
typedef char *_wst__KeyType;
#endif

/* wst.h:926 */
#ifndef SOAP_TYPE__wst__KeySize
#define SOAP_TYPE__wst__KeySize (732)
typedef unsigned int _wst__KeySize;
#endif

/* wst.h:929 */
#ifndef SOAP_TYPE__wst__SignatureAlgorithm
#define SOAP_TYPE__wst__SignatureAlgorithm (733)
typedef char *_wst__SignatureAlgorithm;
#endif

/* wst.h:932 */
#ifndef SOAP_TYPE__wst__EncryptionAlgorithm
#define SOAP_TYPE__wst__EncryptionAlgorithm (734)
typedef char *_wst__EncryptionAlgorithm;
#endif

/* wst.h:935 */
#ifndef SOAP_TYPE__wst__CanonicalizationAlgorithm
#define SOAP_TYPE__wst__CanonicalizationAlgorithm (735)
typedef char *_wst__CanonicalizationAlgorithm;
#endif

/* wst.h:938 */
#ifndef SOAP_TYPE__wst__ComputedKeyAlgorithm
#define SOAP_TYPE__wst__ComputedKeyAlgorithm (736)
typedef char *_wst__ComputedKeyAlgorithm;
#endif

/* wst.h:941 */
#ifndef SOAP_TYPE__wst__Encryption
#define SOAP_TYPE__wst__Encryption (737)
typedef struct wst__EncryptionType _wst__Encryption;
#endif

/* wst.h:944 */
#ifndef SOAP_TYPE__wst__ProofEncryption
#define SOAP_TYPE__wst__ProofEncryption (738)
typedef struct wst__ProofEncryptionType _wst__ProofEncryption;
#endif

/* wst.h:947 */
#ifndef SOAP_TYPE__wst__UseKey
#define SOAP_TYPE__wst__UseKey (739)
typedef struct wst__UseKeyType _wst__UseKey;
#endif

/* wst.h:950 */
#ifndef SOAP_TYPE__wst__KeyWrapAlgorithm
#define SOAP_TYPE__wst__KeyWrapAlgorithm (740)
typedef char *_wst__KeyWrapAlgorithm;
#endif

/* wst.h:953 */
#ifndef SOAP_TYPE__wst__SignWith
#define SOAP_TYPE__wst__SignWith (741)
typedef char *_wst__SignWith;
#endif

/* wst.h:956 */
#ifndef SOAP_TYPE__wst__EncryptWith
#define SOAP_TYPE__wst__EncryptWith (742)
typedef char *_wst__EncryptWith;
#endif

/* wst.h:959 */
#ifndef SOAP_TYPE__wst__DelegateTo
#define SOAP_TYPE__wst__DelegateTo (743)
typedef struct wst__DelegateToType _wst__DelegateTo;
#endif

/* wst.h:962 */
#ifndef SOAP_TYPE__wst__Forwardable
#define SOAP_TYPE__wst__Forwardable (744)
typedef char *_wst__Forwardable;
#endif

/* wst.h:965 */
#ifndef SOAP_TYPE__wst__Delegatable
#define SOAP_TYPE__wst__Delegatable (745)
typedef char *_wst__Delegatable;
#endif

/* wst.h:968 */
#ifndef SOAP_TYPE__wst__Participants
#define SOAP_TYPE__wst__Participants (746)
typedef struct wst__ParticipantsType _wst__Participants;
#endif

/* wsrm5.h:108 */
#ifndef SOAP_TYPE__wsrm__Identifier
#define SOAP_TYPE__wsrm__Identifier (767)
typedef char *_wsrm__Identifier;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (770)
#endif

/* _wst__KeySize has binding name '_wst__KeySize' for type '' */
#ifndef SOAP_TYPE__wst__KeySize
#define SOAP_TYPE__wst__KeySize (732)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (686)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (631)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (429)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (463)
#endif

/* enum wsrm__IncompleteSequenceBehaviorType has binding name 'wsrm__IncompleteSequenceBehaviorType' for type 'wsrm:IncompleteSequenceBehaviorType' */
#ifndef SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType
#define SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType (774)
#endif

/* enum wsrm__FaultCodes has binding name 'wsrm__FaultCodes' for type 'wsrm:FaultCodes' */
#ifndef SOAP_TYPE_wsrm__FaultCodes
#define SOAP_TYPE_wsrm__FaultCodes (773)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (635)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (618)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (617)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (533)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (452)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (422)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (348)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (345)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (95)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (93)
#endif

/* arr__ArrayOfstring has binding name 'arr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (90)
#endif

/* _tempuri__GetWarningsResponse has binding name '_tempuri__GetWarningsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetWarningsResponse
#define SOAP_TYPE__tempuri__GetWarningsResponse (89)
#endif

/* _tempuri__GetWarnings has binding name '_tempuri__GetWarnings' for type '' */
#ifndef SOAP_TYPE__tempuri__GetWarnings
#define SOAP_TYPE__tempuri__GetWarnings (88)
#endif

/* _tempuri__HasWarningsResponse has binding name '_tempuri__HasWarningsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__HasWarningsResponse
#define SOAP_TYPE__tempuri__HasWarningsResponse (87)
#endif

/* _tempuri__HasWarnings has binding name '_tempuri__HasWarnings' for type '' */
#ifndef SOAP_TYPE__tempuri__HasWarnings
#define SOAP_TYPE__tempuri__HasWarnings (86)
#endif

/* _tempuri__GetErrorsResponse has binding name '_tempuri__GetErrorsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetErrorsResponse
#define SOAP_TYPE__tempuri__GetErrorsResponse (85)
#endif

/* _tempuri__GetErrors has binding name '_tempuri__GetErrors' for type '' */
#ifndef SOAP_TYPE__tempuri__GetErrors
#define SOAP_TYPE__tempuri__GetErrors (84)
#endif

/* _tempuri__HasErrorsResponse has binding name '_tempuri__HasErrorsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__HasErrorsResponse
#define SOAP_TYPE__tempuri__HasErrorsResponse (83)
#endif

/* _tempuri__HasErrors has binding name '_tempuri__HasErrors' for type '' */
#ifndef SOAP_TYPE__tempuri__HasErrors
#define SOAP_TYPE__tempuri__HasErrors (82)
#endif

/* _tempuri__GetMessageResponse has binding name '_tempuri__GetMessageResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetMessageResponse
#define SOAP_TYPE__tempuri__GetMessageResponse (81)
#endif

/* _tempuri__GetMessage has binding name '_tempuri__GetMessage' for type '' */
#ifndef SOAP_TYPE__tempuri__GetMessage
#define SOAP_TYPE__tempuri__GetMessage (80)
#endif

/* _tempuri__HasMessageResponse has binding name '_tempuri__HasMessageResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__HasMessageResponse
#define SOAP_TYPE__tempuri__HasMessageResponse (79)
#endif

/* _tempuri__HasMessage has binding name '_tempuri__HasMessage' for type '' */
#ifndef SOAP_TYPE__tempuri__HasMessage
#define SOAP_TYPE__tempuri__HasMessage (78)
#endif

/* _tempuri__IsSamplePlateTrayInResponse has binding name '_tempuri__IsSamplePlateTrayInResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse
#define SOAP_TYPE__tempuri__IsSamplePlateTrayInResponse (77)
#endif

/* _tempuri__IsSamplePlateTrayIn has binding name '_tempuri__IsSamplePlateTrayIn' for type '' */
#ifndef SOAP_TYPE__tempuri__IsSamplePlateTrayIn
#define SOAP_TYPE__tempuri__IsSamplePlateTrayIn (76)
#endif

/* _tempuri__IsChipDockedResponse has binding name '_tempuri__IsChipDockedResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__IsChipDockedResponse
#define SOAP_TYPE__tempuri__IsChipDockedResponse (75)
#endif

/* _tempuri__IsChipDocked has binding name '_tempuri__IsChipDocked' for type '' */
#ifndef SOAP_TYPE__tempuri__IsChipDocked
#define SOAP_TYPE__tempuri__IsChipDocked (74)
#endif

/* _tempuri__GetOperationModeResponse has binding name '_tempuri__GetOperationModeResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetOperationModeResponse
#define SOAP_TYPE__tempuri__GetOperationModeResponse (73)
#endif

/* _tempuri__GetOperationMode has binding name '_tempuri__GetOperationMode' for type '' */
#ifndef SOAP_TYPE__tempuri__GetOperationMode
#define SOAP_TYPE__tempuri__GetOperationMode (72)
#endif

/* _tempuri__RunMaintenanceProcedureResponse has binding name '_tempuri__RunMaintenanceProcedureResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse
#define SOAP_TYPE__tempuri__RunMaintenanceProcedureResponse (71)
#endif

/* _tempuri__RunMaintenanceProcedure has binding name '_tempuri__RunMaintenanceProcedure' for type '' */
#ifndef SOAP_TYPE__tempuri__RunMaintenanceProcedure
#define SOAP_TYPE__tempuri__RunMaintenanceProcedure (70)
#endif

/* _tempuri__GetNamesOfMaintenanceProceduresResponse has binding name '_tempuri__GetNamesOfMaintenanceProceduresResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse
#define SOAP_TYPE__tempuri__GetNamesOfMaintenanceProceduresResponse (69)
#endif

/* _tempuri__GetNamesOfMaintenanceProcedures has binding name '_tempuri__GetNamesOfMaintenanceProcedures' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures
#define SOAP_TYPE__tempuri__GetNamesOfMaintenanceProcedures (68)
#endif

/* _tempuri__GetStandbyAfterFinishResponse has binding name '_tempuri__GetStandbyAfterFinishResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse
#define SOAP_TYPE__tempuri__GetStandbyAfterFinishResponse (67)
#endif

/* _tempuri__GetStandbyAfterFinish has binding name '_tempuri__GetStandbyAfterFinish' for type '' */
#ifndef SOAP_TYPE__tempuri__GetStandbyAfterFinish
#define SOAP_TYPE__tempuri__GetStandbyAfterFinish (66)
#endif

/* _tempuri__SetStandbyAfterFinishResponse has binding name '_tempuri__SetStandbyAfterFinishResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse
#define SOAP_TYPE__tempuri__SetStandbyAfterFinishResponse (65)
#endif

/* _tempuri__SetStandbyAfterFinish has binding name '_tempuri__SetStandbyAfterFinish' for type '' */
#ifndef SOAP_TYPE__tempuri__SetStandbyAfterFinish
#define SOAP_TYPE__tempuri__SetStandbyAfterFinish (64)
#endif

/* _tempuri__LeaveStandbyResponse has binding name '_tempuri__LeaveStandbyResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LeaveStandbyResponse
#define SOAP_TYPE__tempuri__LeaveStandbyResponse (63)
#endif

/* _tempuri__LeaveStandby has binding name '_tempuri__LeaveStandby' for type '' */
#ifndef SOAP_TYPE__tempuri__LeaveStandby
#define SOAP_TYPE__tempuri__LeaveStandby (62)
#endif

/* _tempuri__AbortScriptResponse has binding name '_tempuri__AbortScriptResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AbortScriptResponse
#define SOAP_TYPE__tempuri__AbortScriptResponse (61)
#endif

/* _tempuri__AbortScript has binding name '_tempuri__AbortScript' for type '' */
#ifndef SOAP_TYPE__tempuri__AbortScript
#define SOAP_TYPE__tempuri__AbortScript (60)
#endif

/* _tempuri__ResetRunsetResponse has binding name '_tempuri__ResetRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__ResetRunsetResponse
#define SOAP_TYPE__tempuri__ResetRunsetResponse (59)
#endif

/* _tempuri__ResetRunset has binding name '_tempuri__ResetRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__ResetRunset
#define SOAP_TYPE__tempuri__ResetRunset (58)
#endif

/* _tempuri__ResumeRunsetResponse has binding name '_tempuri__ResumeRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__ResumeRunsetResponse
#define SOAP_TYPE__tempuri__ResumeRunsetResponse (57)
#endif

/* _tempuri__ResumeRunset has binding name '_tempuri__ResumeRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__ResumeRunset
#define SOAP_TYPE__tempuri__ResumeRunset (56)
#endif

/* _tempuri__PauseRunsetAfterResponse has binding name '_tempuri__PauseRunsetAfterResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__PauseRunsetAfterResponse
#define SOAP_TYPE__tempuri__PauseRunsetAfterResponse (55)
#endif

/* _tempuri__PauseRunsetAfter has binding name '_tempuri__PauseRunsetAfter' for type '' */
#ifndef SOAP_TYPE__tempuri__PauseRunsetAfter
#define SOAP_TYPE__tempuri__PauseRunsetAfter (54)
#endif

/* _tempuri__StartSelectedRunsetFromResponse has binding name '_tempuri__StartSelectedRunsetFromResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse
#define SOAP_TYPE__tempuri__StartSelectedRunsetFromResponse (53)
#endif

/* _tempuri__StartSelectedRunsetFrom has binding name '_tempuri__StartSelectedRunsetFrom' for type '' */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetFrom
#define SOAP_TYPE__tempuri__StartSelectedRunsetFrom (52)
#endif

/* _tempuri__StartSelectedRunsetResponse has binding name '_tempuri__StartSelectedRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunsetResponse
#define SOAP_TYPE__tempuri__StartSelectedRunsetResponse (51)
#endif

/* _tempuri__StartSelectedRunset has binding name '_tempuri__StartSelectedRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__StartSelectedRunset
#define SOAP_TYPE__tempuri__StartSelectedRunset (50)
#endif

/* _tempuri__MoveSamplePlateTrayInResponse has binding name '_tempuri__MoveSamplePlateTrayInResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayInResponse (49)
#endif

/* _tempuri__MoveSamplePlateTrayIn has binding name '_tempuri__MoveSamplePlateTrayIn' for type '' */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayIn
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayIn (48)
#endif

/* _tempuri__MoveSamplePlateTrayOutResponse has binding name '_tempuri__MoveSamplePlateTrayOutResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayOutResponse (47)
#endif

/* _tempuri__MoveSamplePlateTrayOut has binding name '_tempuri__MoveSamplePlateTrayOut' for type '' */
#ifndef SOAP_TYPE__tempuri__MoveSamplePlateTrayOut
#define SOAP_TYPE__tempuri__MoveSamplePlateTrayOut (46)
#endif

/* _tempuri__GetCurrentSamplePlateIdResponse has binding name '_tempuri__GetCurrentSamplePlateIdResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse
#define SOAP_TYPE__tempuri__GetCurrentSamplePlateIdResponse (45)
#endif

/* _tempuri__GetCurrentSamplePlateId has binding name '_tempuri__GetCurrentSamplePlateId' for type '' */
#ifndef SOAP_TYPE__tempuri__GetCurrentSamplePlateId
#define SOAP_TYPE__tempuri__GetCurrentSamplePlateId (44)
#endif

/* _tempuri__GetSamplePlateIdResponse has binding name '_tempuri__GetSamplePlateIdResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetSamplePlateIdResponse
#define SOAP_TYPE__tempuri__GetSamplePlateIdResponse (43)
#endif

/* _tempuri__GetSamplePlateId has binding name '_tempuri__GetSamplePlateId' for type '' */
#ifndef SOAP_TYPE__tempuri__GetSamplePlateId
#define SOAP_TYPE__tempuri__GetSamplePlateId (42)
#endif

/* _tempuri__SetSamplePlateIdResponse has binding name '_tempuri__SetSamplePlateIdResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__SetSamplePlateIdResponse
#define SOAP_TYPE__tempuri__SetSamplePlateIdResponse (41)
#endif

/* _tempuri__SetSamplePlateId has binding name '_tempuri__SetSamplePlateId' for type '' */
#ifndef SOAP_TYPE__tempuri__SetSamplePlateId
#define SOAP_TYPE__tempuri__SetSamplePlateId (40)
#endif

/* _tempuri__CreateRunsetResponse has binding name '_tempuri__CreateRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__CreateRunsetResponse
#define SOAP_TYPE__tempuri__CreateRunsetResponse (39)
#endif

/* _tempuri__CreateRunset has binding name '_tempuri__CreateRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__CreateRunset
#define SOAP_TYPE__tempuri__CreateRunset (38)
#endif

/* _tempuri__SelectRunsetResponse has binding name '_tempuri__SelectRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__SelectRunsetResponse
#define SOAP_TYPE__tempuri__SelectRunsetResponse (37)
#endif

/* _tempuri__SelectRunset has binding name '_tempuri__SelectRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__SelectRunset
#define SOAP_TYPE__tempuri__SelectRunset (36)
#endif

/* _tempuri__SelectMethodResponse has binding name '_tempuri__SelectMethodResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__SelectMethodResponse
#define SOAP_TYPE__tempuri__SelectMethodResponse (35)
#endif

/* _tempuri__SelectMethod has binding name '_tempuri__SelectMethod' for type '' */
#ifndef SOAP_TYPE__tempuri__SelectMethod
#define SOAP_TYPE__tempuri__SelectMethod (34)
#endif

/* _tempuri__GetMethodNamesOfRunsetResponse has binding name '_tempuri__GetMethodNamesOfRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse
#define SOAP_TYPE__tempuri__GetMethodNamesOfRunsetResponse (33)
#endif

/* _tempuri__GetMethodNamesOfRunset has binding name '_tempuri__GetMethodNamesOfRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__GetMethodNamesOfRunset
#define SOAP_TYPE__tempuri__GetMethodNamesOfRunset (32)
#endif

/* _tempuri__GetAssayTypeOfRunsetResponse has binding name '_tempuri__GetAssayTypeOfRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfRunsetResponse (31)
#endif

/* _tempuri__GetAssayTypeOfRunset has binding name '_tempuri__GetAssayTypeOfRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfRunset
#define SOAP_TYPE__tempuri__GetAssayTypeOfRunset (30)
#endif

/* _tempuri__GetAssayTypeOfCurrentRunsetResponse has binding name '_tempuri__GetAssayTypeOfCurrentRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunsetResponse (29)
#endif

/* _tempuri__GetAssayTypeOfCurrentRunset has binding name '_tempuri__GetAssayTypeOfCurrentRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentRunset (28)
#endif

/* _tempuri__GetNameOfCurrentRunsetResponse has binding name '_tempuri__GetNameOfCurrentRunsetResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse
#define SOAP_TYPE__tempuri__GetNameOfCurrentRunsetResponse (27)
#endif

/* _tempuri__GetNameOfCurrentRunset has binding name '_tempuri__GetNameOfCurrentRunset' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentRunset
#define SOAP_TYPE__tempuri__GetNameOfCurrentRunset (26)
#endif

/* _tempuri__GetAssayTypesOfAllRunsetsResponse has binding name '_tempuri__GetAssayTypesOfAllRunsetsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsetsResponse (25)
#endif

/* _tempuri__GetAssayTypesOfAllRunsets has binding name '_tempuri__GetAssayTypesOfAllRunsets' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllRunsets (24)
#endif

/* _tempuri__GetNamesOfRunsetsOfAssayTypeResponse has binding name '_tempuri__GetNamesOfRunsetsOfAssayTypeResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayTypeResponse (23)
#endif

/* _tempuri__GetNamesOfRunsetsOfAssayType has binding name '_tempuri__GetNamesOfRunsetsOfAssayType' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsOfAssayType (22)
#endif

/* _tempuri__GetNamesOfRunsetsResponse has binding name '_tempuri__GetNamesOfRunsetsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse
#define SOAP_TYPE__tempuri__GetNamesOfRunsetsResponse (21)
#endif

/* _tempuri__GetNamesOfRunsets has binding name '_tempuri__GetNamesOfRunsets' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfRunsets
#define SOAP_TYPE__tempuri__GetNamesOfRunsets (20)
#endif

/* _tempuri__GetAssayTypeOfMethodResponse has binding name '_tempuri__GetAssayTypeOfMethodResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfMethodResponse (19)
#endif

/* _tempuri__GetAssayTypeOfMethod has binding name '_tempuri__GetAssayTypeOfMethod' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfMethod
#define SOAP_TYPE__tempuri__GetAssayTypeOfMethod (18)
#endif

/* _tempuri__GetAssayTypeOfCurrentMethodResponse has binding name '_tempuri__GetAssayTypeOfCurrentMethodResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethodResponse (17)
#endif

/* _tempuri__GetAssayTypeOfCurrentMethod has binding name '_tempuri__GetAssayTypeOfCurrentMethod' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod
#define SOAP_TYPE__tempuri__GetAssayTypeOfCurrentMethod (16)
#endif

/* _tempuri__GetNameOfCurrentMethodResponse has binding name '_tempuri__GetNameOfCurrentMethodResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse
#define SOAP_TYPE__tempuri__GetNameOfCurrentMethodResponse (15)
#endif

/* _tempuri__GetNameOfCurrentMethod has binding name '_tempuri__GetNameOfCurrentMethod' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNameOfCurrentMethod
#define SOAP_TYPE__tempuri__GetNameOfCurrentMethod (14)
#endif

/* _tempuri__GetAssayTypesOfAllMethodsResponse has binding name '_tempuri__GetAssayTypesOfAllMethodsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllMethodsResponse (13)
#endif

/* _tempuri__GetAssayTypesOfAllMethods has binding name '_tempuri__GetAssayTypesOfAllMethods' for type '' */
#ifndef SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods
#define SOAP_TYPE__tempuri__GetAssayTypesOfAllMethods (12)
#endif

/* _tempuri__GetNamesOfMethodsOfAssayTypeResponse has binding name '_tempuri__GetNamesOfMethodsOfAssayTypeResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse
#define SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayTypeResponse (11)
#endif

/* _tempuri__GetNamesOfMethodsOfAssayType has binding name '_tempuri__GetNamesOfMethodsOfAssayType' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType
#define SOAP_TYPE__tempuri__GetNamesOfMethodsOfAssayType (10)
#endif

/* _tempuri__GetNamesOfMethodsResponse has binding name '_tempuri__GetNamesOfMethodsResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethodsResponse
#define SOAP_TYPE__tempuri__GetNamesOfMethodsResponse (9)
#endif

/* _tempuri__GetNamesOfMethods has binding name '_tempuri__GetNamesOfMethods' for type '' */
#ifndef SOAP_TYPE__tempuri__GetNamesOfMethods
#define SOAP_TYPE__tempuri__GetNamesOfMethods (8)
#endif

/* struct _wsrm__SequenceAcknowledgement_None has binding name '_wsrm__SequenceAcknowledgement_None' for type '' */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_None
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_None (784)
#endif

/* struct _wsrm__SequenceAcknowledgement_AcknowledgementRange has binding name '_wsrm__SequenceAcknowledgement_AcknowledgementRange' for type '' */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange (782)
#endif

/* struct _wsrm__SequenceAcknowledgement_Final has binding name '_wsrm__SequenceAcknowledgement_Final' for type '' */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement_Final
#define SOAP_TYPE__wsrm__SequenceAcknowledgement_Final (780)
#endif

/* struct _wsrm__UsesSequenceSSL has binding name '_wsrm__UsesSequenceSSL' for type '' */
#ifndef SOAP_TYPE__wsrm__UsesSequenceSSL
#define SOAP_TYPE__wsrm__UsesSequenceSSL (772)
#endif

/* struct _wsrm__UsesSequenceSTR has binding name '_wsrm__UsesSequenceSTR' for type '' */
#ifndef SOAP_TYPE__wsrm__UsesSequenceSTR
#define SOAP_TYPE__wsrm__UsesSequenceSTR (771)
#endif

/* struct _wsrm__SequenceAcknowledgement has binding name '_wsrm__SequenceAcknowledgement' for type '' */
#ifndef SOAP_TYPE__wsrm__SequenceAcknowledgement
#define SOAP_TYPE__wsrm__SequenceAcknowledgement (766)
#endif

/* struct wsrm__AcceptType has binding name 'wsrm__AcceptType' for type 'wsrm:AcceptType' */
#ifndef SOAP_TYPE_wsrm__AcceptType
#define SOAP_TYPE_wsrm__AcceptType (765)
#endif

/* struct wsrm__OfferType has binding name 'wsrm__OfferType' for type 'wsrm:OfferType' */
#ifndef SOAP_TYPE_wsrm__OfferType
#define SOAP_TYPE_wsrm__OfferType (764)
#endif

/* struct wsrm__TerminateSequenceResponseType has binding name 'wsrm__TerminateSequenceResponseType' for type 'wsrm:TerminateSequenceResponseType' */
#ifndef SOAP_TYPE_wsrm__TerminateSequenceResponseType
#define SOAP_TYPE_wsrm__TerminateSequenceResponseType (763)
#endif

/* struct wsrm__TerminateSequenceType has binding name 'wsrm__TerminateSequenceType' for type 'wsrm:TerminateSequenceType' */
#ifndef SOAP_TYPE_wsrm__TerminateSequenceType
#define SOAP_TYPE_wsrm__TerminateSequenceType (762)
#endif

/* struct wsrm__CloseSequenceResponseType has binding name 'wsrm__CloseSequenceResponseType' for type 'wsrm:CloseSequenceResponseType' */
#ifndef SOAP_TYPE_wsrm__CloseSequenceResponseType
#define SOAP_TYPE_wsrm__CloseSequenceResponseType (761)
#endif

/* struct wsrm__CloseSequenceType has binding name 'wsrm__CloseSequenceType' for type 'wsrm:CloseSequenceType' */
#ifndef SOAP_TYPE_wsrm__CloseSequenceType
#define SOAP_TYPE_wsrm__CloseSequenceType (760)
#endif

/* struct wsrm__CreateSequenceResponseType has binding name 'wsrm__CreateSequenceResponseType' for type 'wsrm:CreateSequenceResponseType' */
#ifndef SOAP_TYPE_wsrm__CreateSequenceResponseType
#define SOAP_TYPE_wsrm__CreateSequenceResponseType (759)
#endif

/* struct wsrm__CreateSequenceType has binding name 'wsrm__CreateSequenceType' for type 'wsrm:CreateSequenceType' */
#ifndef SOAP_TYPE_wsrm__CreateSequenceType
#define SOAP_TYPE_wsrm__CreateSequenceType (758)
#endif

/* struct wsrm__SequenceFaultType has binding name 'wsrm__SequenceFaultType' for type 'wsrm:SequenceFaultType' */
#ifndef SOAP_TYPE_wsrm__SequenceFaultType
#define SOAP_TYPE_wsrm__SequenceFaultType (757)
#endif

/* struct wsrm__AckRequestedType has binding name 'wsrm__AckRequestedType' for type 'wsrm:AckRequestedType' */
#ifndef SOAP_TYPE_wsrm__AckRequestedType
#define SOAP_TYPE_wsrm__AckRequestedType (756)
#endif

/* struct wsrm__SequenceType has binding name 'wsrm__SequenceType' for type 'wsrm:SequenceType' */
#ifndef SOAP_TYPE_wsrm__SequenceType
#define SOAP_TYPE_wsrm__SequenceType (755)
#endif

/* _wst__Participants has binding name '_wst__Participants' for type '' */
#ifndef SOAP_TYPE__wst__Participants
#define SOAP_TYPE__wst__Participants (746)
#endif

/* _wst__DelegateTo has binding name '_wst__DelegateTo' for type '' */
#ifndef SOAP_TYPE__wst__DelegateTo
#define SOAP_TYPE__wst__DelegateTo (743)
#endif

/* _wst__UseKey has binding name '_wst__UseKey' for type '' */
#ifndef SOAP_TYPE__wst__UseKey
#define SOAP_TYPE__wst__UseKey (739)
#endif

/* _wst__ProofEncryption has binding name '_wst__ProofEncryption' for type '' */
#ifndef SOAP_TYPE__wst__ProofEncryption
#define SOAP_TYPE__wst__ProofEncryption (738)
#endif

/* _wst__Encryption has binding name '_wst__Encryption' for type '' */
#ifndef SOAP_TYPE__wst__Encryption
#define SOAP_TYPE__wst__Encryption (737)
#endif

/* _wst__Issuer has binding name '_wst__Issuer' for type '' */
#ifndef SOAP_TYPE__wst__Issuer
#define SOAP_TYPE__wst__Issuer (729)
#endif

/* _wst__OnBehalfOf has binding name '_wst__OnBehalfOf' for type '' */
#ifndef SOAP_TYPE__wst__OnBehalfOf
#define SOAP_TYPE__wst__OnBehalfOf (728)
#endif

/* _wst__Authenticator has binding name '_wst__Authenticator' for type '' */
#ifndef SOAP_TYPE__wst__Authenticator
#define SOAP_TYPE__wst__Authenticator (726)
#endif

/* _wst__KeyExchangeToken has binding name '_wst__KeyExchangeToken' for type '' */
#ifndef SOAP_TYPE__wst__KeyExchangeToken
#define SOAP_TYPE__wst__KeyExchangeToken (725)
#endif

/* _wst__RequestKET has binding name '_wst__RequestKET' for type '' */
#ifndef SOAP_TYPE__wst__RequestKET
#define SOAP_TYPE__wst__RequestKET (724)
#endif

/* _wst__BinaryExchange has binding name '_wst__BinaryExchange' for type '' */
#ifndef SOAP_TYPE__wst__BinaryExchange
#define SOAP_TYPE__wst__BinaryExchange (723)
#endif

/* _wst__SignChallengeResponse has binding name '_wst__SignChallengeResponse' for type '' */
#ifndef SOAP_TYPE__wst__SignChallengeResponse
#define SOAP_TYPE__wst__SignChallengeResponse (721)
#endif

/* _wst__SignChallenge has binding name '_wst__SignChallenge' for type '' */
#ifndef SOAP_TYPE__wst__SignChallenge
#define SOAP_TYPE__wst__SignChallenge (720)
#endif

/* _wst__Status has binding name '_wst__Status' for type '' */
#ifndef SOAP_TYPE__wst__Status
#define SOAP_TYPE__wst__Status (719)
#endif

/* _wst__ValidateTarget has binding name '_wst__ValidateTarget' for type '' */
#ifndef SOAP_TYPE__wst__ValidateTarget
#define SOAP_TYPE__wst__ValidateTarget (718)
#endif

/* _wst__RequestedTokenCancelled has binding name '_wst__RequestedTokenCancelled' for type '' */
#ifndef SOAP_TYPE__wst__RequestedTokenCancelled
#define SOAP_TYPE__wst__RequestedTokenCancelled (717)
#endif

/* _wst__CancelTarget has binding name '_wst__CancelTarget' for type '' */
#ifndef SOAP_TYPE__wst__CancelTarget
#define SOAP_TYPE__wst__CancelTarget (716)
#endif

/* _wst__Renewing has binding name '_wst__Renewing' for type '' */
#ifndef SOAP_TYPE__wst__Renewing
#define SOAP_TYPE__wst__Renewing (715)
#endif

/* _wst__AllowPostdating has binding name '_wst__AllowPostdating' for type '' */
#ifndef SOAP_TYPE__wst__AllowPostdating
#define SOAP_TYPE__wst__AllowPostdating (714)
#endif

/* _wst__RenewTarget has binding name '_wst__RenewTarget' for type '' */
#ifndef SOAP_TYPE__wst__RenewTarget
#define SOAP_TYPE__wst__RenewTarget (713)
#endif

/* _wst__IssuedTokens has binding name '_wst__IssuedTokens' for type '' */
#ifndef SOAP_TYPE__wst__IssuedTokens
#define SOAP_TYPE__wst__IssuedTokens (712)
#endif

/* _wst__RequestedProofToken has binding name '_wst__RequestedProofToken' for type '' */
#ifndef SOAP_TYPE__wst__RequestedProofToken
#define SOAP_TYPE__wst__RequestedProofToken (711)
#endif

/* _wst__RequestedUnattachedReference has binding name '_wst__RequestedUnattachedReference' for type '' */
#ifndef SOAP_TYPE__wst__RequestedUnattachedReference
#define SOAP_TYPE__wst__RequestedUnattachedReference (710)
#endif

/* _wst__RequestedAttachedReference has binding name '_wst__RequestedAttachedReference' for type '' */
#ifndef SOAP_TYPE__wst__RequestedAttachedReference
#define SOAP_TYPE__wst__RequestedAttachedReference (709)
#endif

/* _wst__RequestSecurityTokenResponseCollection has binding name '_wst__RequestSecurityTokenResponseCollection' for type '' */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenResponseCollection
#define SOAP_TYPE__wst__RequestSecurityTokenResponseCollection (707)
#endif

/* _wst__RequestSecurityTokenCollection has binding name '_wst__RequestSecurityTokenCollection' for type '' */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenCollection
#define SOAP_TYPE__wst__RequestSecurityTokenCollection (706)
#endif

/* _wst__Lifetime has binding name '_wst__Lifetime' for type '' */
#ifndef SOAP_TYPE__wst__Lifetime
#define SOAP_TYPE__wst__Lifetime (705)
#endif

/* _wst__Entropy has binding name '_wst__Entropy' for type '' */
#ifndef SOAP_TYPE__wst__Entropy
#define SOAP_TYPE__wst__Entropy (704)
#endif

/* _wst__Claims has binding name '_wst__Claims' for type '' */
#ifndef SOAP_TYPE__wst__Claims
#define SOAP_TYPE__wst__Claims (703)
#endif

/* _wst__BinarySecret has binding name '_wst__BinarySecret' for type '' */
#ifndef SOAP_TYPE__wst__BinarySecret
#define SOAP_TYPE__wst__BinarySecret (702)
#endif

/* _wst__RequestedSecurityToken has binding name '_wst__RequestedSecurityToken' for type '' */
#ifndef SOAP_TYPE__wst__RequestedSecurityToken
#define SOAP_TYPE__wst__RequestedSecurityToken (701)
#endif

/* _wst__RequestSecurityTokenResponse has binding name '_wst__RequestSecurityTokenResponse' for type '' */
#ifndef SOAP_TYPE__wst__RequestSecurityTokenResponse
#define SOAP_TYPE__wst__RequestSecurityTokenResponse (700)
#endif

/* _wst__RequestSecurityToken has binding name '_wst__RequestSecurityToken' for type '' */
#ifndef SOAP_TYPE__wst__RequestSecurityToken
#define SOAP_TYPE__wst__RequestSecurityToken (697)
#endif

/* struct wst__ParticipantType has binding name 'wst__ParticipantType' for type 'wst:ParticipantType' */
#ifndef SOAP_TYPE_wst__ParticipantType
#define SOAP_TYPE_wst__ParticipantType (683)
#endif

/* struct wst__ParticipantsType has binding name 'wst__ParticipantsType' for type 'wst:ParticipantsType' */
#ifndef SOAP_TYPE_wst__ParticipantsType
#define SOAP_TYPE_wst__ParticipantsType (682)
#endif

/* struct wst__DelegateToType has binding name 'wst__DelegateToType' for type 'wst:DelegateToType' */
#ifndef SOAP_TYPE_wst__DelegateToType
#define SOAP_TYPE_wst__DelegateToType (681)
#endif

/* struct wst__UseKeyType has binding name 'wst__UseKeyType' for type 'wst:UseKeyType' */
#ifndef SOAP_TYPE_wst__UseKeyType
#define SOAP_TYPE_wst__UseKeyType (680)
#endif

/* struct wst__ProofEncryptionType has binding name 'wst__ProofEncryptionType' for type 'wst:ProofEncryptionType' */
#ifndef SOAP_TYPE_wst__ProofEncryptionType
#define SOAP_TYPE_wst__ProofEncryptionType (679)
#endif

/* struct wst__EncryptionType has binding name 'wst__EncryptionType' for type 'wst:EncryptionType' */
#ifndef SOAP_TYPE_wst__EncryptionType
#define SOAP_TYPE_wst__EncryptionType (678)
#endif

/* struct wst__OnBehalfOfType has binding name 'wst__OnBehalfOfType' for type 'wst:OnBehalfOfType' */
#ifndef SOAP_TYPE_wst__OnBehalfOfType
#define SOAP_TYPE_wst__OnBehalfOfType (677)
#endif

/* struct wst__AuthenticatorType has binding name 'wst__AuthenticatorType' for type 'wst:AuthenticatorType' */
#ifndef SOAP_TYPE_wst__AuthenticatorType
#define SOAP_TYPE_wst__AuthenticatorType (676)
#endif

/* struct wst__KeyExchangeTokenType has binding name 'wst__KeyExchangeTokenType' for type 'wst:KeyExchangeTokenType' */
#ifndef SOAP_TYPE_wst__KeyExchangeTokenType
#define SOAP_TYPE_wst__KeyExchangeTokenType (675)
#endif

/* struct wst__RequestKETType has binding name 'wst__RequestKETType' for type 'wst:RequestKETType' */
#ifndef SOAP_TYPE_wst__RequestKETType
#define SOAP_TYPE_wst__RequestKETType (674)
#endif

/* struct wst__BinaryExchangeType has binding name 'wst__BinaryExchangeType' for type 'wst:BinaryExchangeType' */
#ifndef SOAP_TYPE_wst__BinaryExchangeType
#define SOAP_TYPE_wst__BinaryExchangeType (673)
#endif

/* struct wst__SignChallengeType has binding name 'wst__SignChallengeType' for type 'wst:SignChallengeType' */
#ifndef SOAP_TYPE_wst__SignChallengeType
#define SOAP_TYPE_wst__SignChallengeType (672)
#endif

/* struct wst__StatusType has binding name 'wst__StatusType' for type 'wst:StatusType' */
#ifndef SOAP_TYPE_wst__StatusType
#define SOAP_TYPE_wst__StatusType (671)
#endif

/* struct wst__ValidateTargetType has binding name 'wst__ValidateTargetType' for type 'wst:ValidateTargetType' */
#ifndef SOAP_TYPE_wst__ValidateTargetType
#define SOAP_TYPE_wst__ValidateTargetType (670)
#endif

/* struct wst__RequestedTokenCancelledType has binding name 'wst__RequestedTokenCancelledType' for type 'wst:RequestedTokenCancelledType' */
#ifndef SOAP_TYPE_wst__RequestedTokenCancelledType
#define SOAP_TYPE_wst__RequestedTokenCancelledType (669)
#endif

/* struct wst__CancelTargetType has binding name 'wst__CancelTargetType' for type 'wst:CancelTargetType' */
#ifndef SOAP_TYPE_wst__CancelTargetType
#define SOAP_TYPE_wst__CancelTargetType (668)
#endif

/* struct wst__RenewingType has binding name 'wst__RenewingType' for type 'wst:RenewingType' */
#ifndef SOAP_TYPE_wst__RenewingType
#define SOAP_TYPE_wst__RenewingType (667)
#endif

/* struct wst__AllowPostdatingType has binding name 'wst__AllowPostdatingType' for type 'wst:AllowPostdatingType' */
#ifndef SOAP_TYPE_wst__AllowPostdatingType
#define SOAP_TYPE_wst__AllowPostdatingType (666)
#endif

/* struct wst__RenewTargetType has binding name 'wst__RenewTargetType' for type 'wst:RenewTargetType' */
#ifndef SOAP_TYPE_wst__RenewTargetType
#define SOAP_TYPE_wst__RenewTargetType (665)
#endif

/* struct wst__RequestedProofTokenType has binding name 'wst__RequestedProofTokenType' for type 'wst:RequestedProofTokenType' */
#ifndef SOAP_TYPE_wst__RequestedProofTokenType
#define SOAP_TYPE_wst__RequestedProofTokenType (664)
#endif

/* struct wst__RequestedReferenceType has binding name 'wst__RequestedReferenceType' for type 'wst:RequestedReferenceType' */
#ifndef SOAP_TYPE_wst__RequestedReferenceType
#define SOAP_TYPE_wst__RequestedReferenceType (663)
#endif

/* struct wst__RequestSecurityTokenResponseCollectionType has binding name 'wst__RequestSecurityTokenResponseCollectionType' for type 'wst:RequestSecurityTokenResponseCollectionType' */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType
#define SOAP_TYPE_wst__RequestSecurityTokenResponseCollectionType (662)
#endif

/* struct wst__RequestSecurityTokenCollectionType has binding name 'wst__RequestSecurityTokenCollectionType' for type 'wst:RequestSecurityTokenCollectionType' */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenCollectionType
#define SOAP_TYPE_wst__RequestSecurityTokenCollectionType (661)
#endif

/* struct wst__LifetimeType has binding name 'wst__LifetimeType' for type 'wst:LifetimeType' */
#ifndef SOAP_TYPE_wst__LifetimeType
#define SOAP_TYPE_wst__LifetimeType (660)
#endif

/* struct wst__EntropyType has binding name 'wst__EntropyType' for type 'wst:EntropyType' */
#ifndef SOAP_TYPE_wst__EntropyType
#define SOAP_TYPE_wst__EntropyType (658)
#endif

/* struct wst__ClaimsType has binding name 'wst__ClaimsType' for type 'wst:ClaimsType' */
#ifndef SOAP_TYPE_wst__ClaimsType
#define SOAP_TYPE_wst__ClaimsType (657)
#endif

/* struct wst__BinarySecretType has binding name 'wst__BinarySecretType' for type 'wst:BinarySecretType' */
#ifndef SOAP_TYPE_wst__BinarySecretType
#define SOAP_TYPE_wst__BinarySecretType (656)
#endif

/* struct wst__RequestedSecurityTokenType has binding name 'wst__RequestedSecurityTokenType' for type 'wst:RequestedSecurityTokenType' */
#ifndef SOAP_TYPE_wst__RequestedSecurityTokenType
#define SOAP_TYPE_wst__RequestedSecurityTokenType (655)
#endif

/* struct wst__RequestSecurityTokenResponseType has binding name 'wst__RequestSecurityTokenResponseType' for type 'wst:RequestSecurityTokenResponseType' */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenResponseType
#define SOAP_TYPE_wst__RequestSecurityTokenResponseType (654)
#endif

/* struct wst__RequestSecurityTokenType has binding name 'wst__RequestSecurityTokenType' for type 'wst:RequestSecurityTokenType' */
#ifndef SOAP_TYPE_wst__RequestSecurityTokenType
#define SOAP_TYPE_wst__RequestSecurityTokenType (653)
#endif

/* struct _wsp__AppliesTo_ has binding name '_wsp__AppliesTo_' for type '' */
#ifndef SOAP_TYPE__wsp__AppliesTo_
#define SOAP_TYPE__wsp__AppliesTo_ (651)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (650)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (646)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (644)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (642)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (636)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (634)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (628)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (627)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (626)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (625)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (623)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (622)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (621)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (614)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (613)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (612)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (611)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (610)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (608)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (602)
#endif

/* _saml2__EncryptedAttribute has binding name '_saml2__EncryptedAttribute' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (601)
#endif

/* _saml2__Attribute has binding name '_saml2__Attribute' for type '' */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (599)
#endif

/* _saml2__AttributeStatement has binding name '_saml2__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (598)
#endif

/* _saml2__Evidence has binding name '_saml2__Evidence' for type '' */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (597)
#endif

/* _saml2__Action has binding name '_saml2__Action' for type '' */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (596)
#endif

/* _saml2__AuthzDecisionStatement has binding name '_saml2__AuthzDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (595)
#endif

/* _saml2__AuthnContext has binding name '_saml2__AuthnContext' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (590)
#endif

/* _saml2__SubjectLocality has binding name '_saml2__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (589)
#endif

/* _saml2__AuthnStatement has binding name '_saml2__AuthnStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (588)
#endif

/* _saml2__Statement has binding name '_saml2__Statement' for type '' */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (587)
#endif

/* _saml2__EncryptedAssertion has binding name '_saml2__EncryptedAssertion' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (586)
#endif

/* _saml2__Advice has binding name '_saml2__Advice' for type '' */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (585)
#endif

/* _saml2__ProxyRestriction has binding name '_saml2__ProxyRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (584)
#endif

/* _saml2__OneTimeUse has binding name '_saml2__OneTimeUse' for type '' */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (583)
#endif

/* _saml2__AudienceRestriction has binding name '_saml2__AudienceRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (581)
#endif

/* _saml2__Condition has binding name '_saml2__Condition' for type '' */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (580)
#endif

/* _saml2__Conditions has binding name '_saml2__Conditions' for type '' */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (579)
#endif

/* _saml2__SubjectConfirmationData has binding name '_saml2__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (578)
#endif

/* _saml2__SubjectConfirmation has binding name '_saml2__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (577)
#endif

/* _saml2__Subject has binding name '_saml2__Subject' for type '' */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (576)
#endif

/* _saml2__Assertion has binding name '_saml2__Assertion' for type '' */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (575)
#endif

/* _saml2__Issuer has binding name '_saml2__Issuer' for type '' */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (572)
#endif

/* _saml2__EncryptedID has binding name '_saml2__EncryptedID' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (571)
#endif

/* _saml2__NameID has binding name '_saml2__NameID' for type '' */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (570)
#endif

/* _saml2__BaseID has binding name '_saml2__BaseID' for type '' */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (569)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (532)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (531)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (530)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (529)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (528)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (527)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (526)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (525)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (524)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (523)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (522)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (521)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (520)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (519)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (518)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (517)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (516)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (515)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (514)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (513)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (512)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (511)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (510)
#endif

/* _saml1__Attribute has binding name '_saml1__Attribute' for type '' */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (508)
#endif

/* _saml1__AttributeDesignator has binding name '_saml1__AttributeDesignator' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (507)
#endif

/* _saml1__AttributeStatement has binding name '_saml1__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (506)
#endif

/* _saml1__Evidence has binding name '_saml1__Evidence' for type '' */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (505)
#endif

/* _saml1__Action has binding name '_saml1__Action' for type '' */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (504)
#endif

/* _saml1__AuthorizationDecisionStatement has binding name '_saml1__AuthorizationDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (503)
#endif

/* _saml1__AuthorityBinding has binding name '_saml1__AuthorityBinding' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (502)
#endif

/* _saml1__SubjectLocality has binding name '_saml1__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (501)
#endif

/* _saml1__AuthenticationStatement has binding name '_saml1__AuthenticationStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (500)
#endif

/* _saml1__SubjectConfirmation has binding name '_saml1__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (497)
#endif

/* _saml1__NameIdentifier has binding name '_saml1__NameIdentifier' for type '' */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (496)
#endif

/* _saml1__Subject has binding name '_saml1__Subject' for type '' */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (495)
#endif

/* _saml1__SubjectStatement has binding name '_saml1__SubjectStatement' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (494)
#endif

/* _saml1__Statement has binding name '_saml1__Statement' for type '' */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (493)
#endif

/* _saml1__Advice has binding name '_saml1__Advice' for type '' */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (492)
#endif

/* _saml1__DoNotCacheCondition has binding name '_saml1__DoNotCacheCondition' for type '' */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (491)
#endif

/* _saml1__AudienceRestrictionCondition has binding name '_saml1__AudienceRestrictionCondition' for type '' */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (489)
#endif

/* _saml1__Condition has binding name '_saml1__Condition' for type '' */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (488)
#endif

/* _saml1__Conditions has binding name '_saml1__Conditions' for type '' */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (487)
#endif

/* _saml1__Assertion has binding name '_saml1__Assertion' for type '' */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (486)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (451)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (450)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (449)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (448)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (447)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (446)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (445)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (444)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (443)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (442)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (441)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (440)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (439)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (438)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (437)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (436)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (435)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (434)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (433)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (432)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (425)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (424)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (423)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (409)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (408)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (407)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (406)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (405)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (404)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (403)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (402)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (401)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (400)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (399)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (398)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (387)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (386)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (385)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (384)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (381)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (379)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (378)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (377)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (375)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (374)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (373)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (372)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (371)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (370)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (369)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (367)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (365)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (364)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (361)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (357)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (356)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (355)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (354)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (353)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (350)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (349)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (347)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (346)
#endif

/* struct wsrm__TerminateSequenceResponseType * has binding name 'PointerTowsrm__TerminateSequenceResponseType' for type 'wsrm:TerminateSequenceResponseType' */
#ifndef SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType
#define SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType (799)
#endif

/* struct wsrm__TerminateSequenceType * has binding name 'PointerTowsrm__TerminateSequenceType' for type 'wsrm:TerminateSequenceType' */
#ifndef SOAP_TYPE_PointerTowsrm__TerminateSequenceType
#define SOAP_TYPE_PointerTowsrm__TerminateSequenceType (798)
#endif

/* struct wsrm__CloseSequenceResponseType * has binding name 'PointerTowsrm__CloseSequenceResponseType' for type 'wsrm:CloseSequenceResponseType' */
#ifndef SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType
#define SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType (795)
#endif

/* struct wsrm__CloseSequenceType * has binding name 'PointerTowsrm__CloseSequenceType' for type 'wsrm:CloseSequenceType' */
#ifndef SOAP_TYPE_PointerTowsrm__CloseSequenceType
#define SOAP_TYPE_PointerTowsrm__CloseSequenceType (794)
#endif

/* struct wsrm__CreateSequenceResponseType * has binding name 'PointerTowsrm__CreateSequenceResponseType' for type 'wsrm:CreateSequenceResponseType' */
#ifndef SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType
#define SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType (791)
#endif

/* struct wsrm__CreateSequenceType * has binding name 'PointerTowsrm__CreateSequenceType' for type 'wsrm:CreateSequenceType' */
#ifndef SOAP_TYPE_PointerTowsrm__CreateSequenceType
#define SOAP_TYPE_PointerTowsrm__CreateSequenceType (790)
#endif

/* struct wsrm__SequenceFaultType * has binding name 'PointerTowsrm__SequenceFaultType' for type 'wsrm:SequenceFaultType' */
#ifndef SOAP_TYPE_PointerTowsrm__SequenceFaultType
#define SOAP_TYPE_PointerTowsrm__SequenceFaultType (789)
#endif

/* struct _wsrm__SequenceAcknowledgement * has binding name 'PointerTo_wsrm__SequenceAcknowledgement' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement
#define SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement (788)
#endif

/* struct wsrm__AckRequestedType * has binding name 'PointerTowsrm__AckRequestedType' for type 'wsrm:AckRequestedType' */
#ifndef SOAP_TYPE_PointerTowsrm__AckRequestedType
#define SOAP_TYPE_PointerTowsrm__AckRequestedType (787)
#endif

/* struct wsrm__SequenceType * has binding name 'PointerTowsrm__SequenceType' for type 'wsrm:SequenceType' */
#ifndef SOAP_TYPE_PointerTowsrm__SequenceType
#define SOAP_TYPE_PointerTowsrm__SequenceType (786)
#endif

/* struct _wsrm__SequenceAcknowledgement_None * has binding name 'PointerTo_wsrm__SequenceAcknowledgement_None' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None
#define SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None (785)
#endif

/* struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * has binding name 'PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange
#define SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange (783)
#endif

/* struct _wsrm__SequenceAcknowledgement_Final * has binding name 'PointerTo_wsrm__SequenceAcknowledgement_Final' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final
#define SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final (781)
#endif

/* struct wsrm__AcceptType * has binding name 'PointerTowsrm__AcceptType' for type 'wsrm:AcceptType' */
#ifndef SOAP_TYPE_PointerTowsrm__AcceptType
#define SOAP_TYPE_PointerTowsrm__AcceptType (779)
#endif

/* enum wsrm__IncompleteSequenceBehaviorType * has binding name 'PointerTowsrm__IncompleteSequenceBehaviorType' for type 'wsrm:IncompleteSequenceBehaviorType' */
#ifndef SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType
#define SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType (778)
#endif

/* struct wsrm__OfferType * has binding name 'PointerTowsrm__OfferType' for type 'wsrm:OfferType' */
#ifndef SOAP_TYPE_PointerTowsrm__OfferType
#define SOAP_TYPE_PointerTowsrm__OfferType (777)
#endif

/* LONG64 * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (776)
#endif

/* struct _wsrm__UsesSequenceSSL * has binding name 'PointerTo_wsrm__UsesSequenceSSL' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL
#define SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL (775)
#endif

/* _wsrm__Identifier has binding name '_wsrm__Identifier' for type '' */
#ifndef SOAP_TYPE__wsrm__Identifier
#define SOAP_TYPE__wsrm__Identifier (767)
#endif

/* struct wst__RequestSecurityTokenCollectionType * has binding name 'PointerTowst__RequestSecurityTokenCollectionType' for type 'wst:RequestSecurityTokenCollectionType' */
#ifndef SOAP_TYPE_PointerTowst__RequestSecurityTokenCollectionType
#define SOAP_TYPE_PointerTowst__RequestSecurityTokenCollectionType (752)
#endif

/* struct wst__RequestSecurityTokenResponseCollectionType * has binding name 'PointerTowst__RequestSecurityTokenResponseCollectionType' for type 'wst:RequestSecurityTokenResponseCollectionType' */
#ifndef SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseCollectionType
#define SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseCollectionType (747)
#endif

/* _wst__Delegatable has binding name '_wst__Delegatable' for type '' */
#ifndef SOAP_TYPE__wst__Delegatable
#define SOAP_TYPE__wst__Delegatable (745)
#endif

/* _wst__Forwardable has binding name '_wst__Forwardable' for type '' */
#ifndef SOAP_TYPE__wst__Forwardable
#define SOAP_TYPE__wst__Forwardable (744)
#endif

/* _wst__EncryptWith has binding name '_wst__EncryptWith' for type '' */
#ifndef SOAP_TYPE__wst__EncryptWith
#define SOAP_TYPE__wst__EncryptWith (742)
#endif

/* _wst__SignWith has binding name '_wst__SignWith' for type '' */
#ifndef SOAP_TYPE__wst__SignWith
#define SOAP_TYPE__wst__SignWith (741)
#endif

/* _wst__KeyWrapAlgorithm has binding name '_wst__KeyWrapAlgorithm' for type '' */
#ifndef SOAP_TYPE__wst__KeyWrapAlgorithm
#define SOAP_TYPE__wst__KeyWrapAlgorithm (740)
#endif

/* _wst__ComputedKeyAlgorithm has binding name '_wst__ComputedKeyAlgorithm' for type '' */
#ifndef SOAP_TYPE__wst__ComputedKeyAlgorithm
#define SOAP_TYPE__wst__ComputedKeyAlgorithm (736)
#endif

/* _wst__CanonicalizationAlgorithm has binding name '_wst__CanonicalizationAlgorithm' for type '' */
#ifndef SOAP_TYPE__wst__CanonicalizationAlgorithm
#define SOAP_TYPE__wst__CanonicalizationAlgorithm (735)
#endif

/* _wst__EncryptionAlgorithm has binding name '_wst__EncryptionAlgorithm' for type '' */
#ifndef SOAP_TYPE__wst__EncryptionAlgorithm
#define SOAP_TYPE__wst__EncryptionAlgorithm (734)
#endif

/* _wst__SignatureAlgorithm has binding name '_wst__SignatureAlgorithm' for type '' */
#ifndef SOAP_TYPE__wst__SignatureAlgorithm
#define SOAP_TYPE__wst__SignatureAlgorithm (733)
#endif

/* _wst__KeyType has binding name '_wst__KeyType' for type '' */
#ifndef SOAP_TYPE__wst__KeyType
#define SOAP_TYPE__wst__KeyType (731)
#endif

/* _wst__AuthenticationType has binding name '_wst__AuthenticationType' for type '' */
#ifndef SOAP_TYPE__wst__AuthenticationType
#define SOAP_TYPE__wst__AuthenticationType (730)
#endif

/* _wst__CombinedHash has binding name '_wst__CombinedHash' for type '' */
#ifndef SOAP_TYPE__wst__CombinedHash
#define SOAP_TYPE__wst__CombinedHash (727)
#endif

/* _wst__Challenge has binding name '_wst__Challenge' for type '' */
#ifndef SOAP_TYPE__wst__Challenge
#define SOAP_TYPE__wst__Challenge (722)
#endif

/* _wst__ComputedKey has binding name '_wst__ComputedKey' for type '' */
#ifndef SOAP_TYPE__wst__ComputedKey
#define SOAP_TYPE__wst__ComputedKey (708)
#endif

/* _wst__RequestType has binding name '_wst__RequestType' for type '' */
#ifndef SOAP_TYPE__wst__RequestType
#define SOAP_TYPE__wst__RequestType (699)
#endif

/* _wst__TokenType has binding name '_wst__TokenType' for type '' */
#ifndef SOAP_TYPE__wst__TokenType
#define SOAP_TYPE__wst__TokenType (698)
#endif

/* struct wst__ParticipantType * has binding name 'PointerTowst__ParticipantType' for type 'wst:ParticipantType' */
#ifndef SOAP_TYPE_PointerTowst__ParticipantType
#define SOAP_TYPE_PointerTowst__ParticipantType (696)
#endif

/* struct wst__RequestSecurityTokenResponseType * has binding name 'PointerTowst__RequestSecurityTokenResponseType' for type 'wst:RequestSecurityTokenResponseType' */
#ifndef SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseType
#define SOAP_TYPE_PointerTowst__RequestSecurityTokenResponseType (695)
#endif

/* struct wst__RequestSecurityTokenType * has binding name 'PointerTowst__RequestSecurityTokenType' for type 'wst:RequestSecurityTokenType' */
#ifndef SOAP_TYPE_PointerTowst__RequestSecurityTokenType
#define SOAP_TYPE_PointerTowst__RequestSecurityTokenType (694)
#endif

/* struct wst__LifetimeType * has binding name 'PointerTowst__LifetimeType' for type 'wst:LifetimeType' */
#ifndef SOAP_TYPE_PointerTowst__LifetimeType
#define SOAP_TYPE_PointerTowst__LifetimeType (693)
#endif

/* struct wst__RequestedProofTokenType * has binding name 'PointerTowst__RequestedProofTokenType' for type 'wst:RequestedProofTokenType' */
#ifndef SOAP_TYPE_PointerTowst__RequestedProofTokenType
#define SOAP_TYPE_PointerTowst__RequestedProofTokenType (692)
#endif

/* struct wst__RequestedReferenceType * has binding name 'PointerTowst__RequestedReferenceType' for type 'wst:RequestedReferenceType' */
#ifndef SOAP_TYPE_PointerTowst__RequestedReferenceType
#define SOAP_TYPE_PointerTowst__RequestedReferenceType (691)
#endif

/* struct wst__RequestedSecurityTokenType * has binding name 'PointerTowst__RequestedSecurityTokenType' for type 'wst:RequestedSecurityTokenType' */
#ifndef SOAP_TYPE_PointerTowst__RequestedSecurityTokenType
#define SOAP_TYPE_PointerTowst__RequestedSecurityTokenType (690)
#endif

/* struct wst__AuthenticatorType * has binding name 'PointerTowst__AuthenticatorType' for type 'wst:AuthenticatorType' */
#ifndef SOAP_TYPE_PointerTowst__AuthenticatorType
#define SOAP_TYPE_PointerTowst__AuthenticatorType (689)
#endif

/* struct wst__BinaryExchangeType * has binding name 'PointerTowst__BinaryExchangeType' for type 'wst:BinaryExchangeType' */
#ifndef SOAP_TYPE_PointerTowst__BinaryExchangeType
#define SOAP_TYPE_PointerTowst__BinaryExchangeType (688)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (687)
#endif

/* struct wst__EntropyType * has binding name 'PointerTowst__EntropyType' for type 'wst:EntropyType' */
#ifndef SOAP_TYPE_PointerTowst__EntropyType
#define SOAP_TYPE_PointerTowst__EntropyType (685)
#endif

/* struct _wsp__AppliesTo_ * has binding name 'PointerTo_wsp__AppliesTo_' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsp__AppliesTo_
#define SOAP_TYPE_PointerTo_wsp__AppliesTo_ (684)
#endif

/* struct wst__BinarySecretType * has binding name 'PointerTowst__BinarySecretType' for type 'wst:BinarySecretType' */
#ifndef SOAP_TYPE_PointerTowst__BinarySecretType
#define SOAP_TYPE_PointerTowst__BinarySecretType (659)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTowsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType (652)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (647)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (645)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (643)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (641)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (640)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (639)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (638)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (637)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (633)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (632)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (630)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (629)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (624)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (620)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (619)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (616)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (615)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (609)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (607)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (606)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (605)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (604)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (603)
#endif

/* _saml2__AttributeValue has binding name '_saml2__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (600)
#endif

/* _saml2__AuthenticatingAuthority has binding name '_saml2__AuthenticatingAuthority' for type '' */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (594)
#endif

/* _saml2__AuthnContextDecl has binding name '_saml2__AuthnContextDecl' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (593)
#endif

/* _saml2__AuthnContextDeclRef has binding name '_saml2__AuthnContextDeclRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (592)
#endif

/* _saml2__AuthnContextClassRef has binding name '_saml2__AuthnContextClassRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (591)
#endif

/* _saml2__Audience has binding name '_saml2__Audience' for type '' */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (582)
#endif

/* _saml2__AssertionURIRef has binding name '_saml2__AssertionURIRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (574)
#endif

/* _saml2__AssertionIDRef has binding name '_saml2__AssertionIDRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (573)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (568)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (567)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (566)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (564)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (563)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (562)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (561)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (560)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (558)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (557)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (555)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (554)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (553)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (552)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (551)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (549)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (548)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (547)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (546)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (545)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (544)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (543)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (542)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (541)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (539)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (538)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (537)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (536)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (535)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (534)
#endif

/* _saml1__AttributeValue has binding name '_saml1__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (509)
#endif

/* _saml1__ConfirmationMethod has binding name '_saml1__ConfirmationMethod' for type '' */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (499)
#endif

/* _saml1__SubjectConfirmationData has binding name '_saml1__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (498)
#endif

/* _saml1__Audience has binding name '_saml1__Audience' for type '' */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (490)
#endif

/* _saml1__AssertionIDReference has binding name '_saml1__AssertionIDReference' for type '' */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (485)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (484)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (483)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (482)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (481)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (480)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (479)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (478)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (477)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (475)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (474)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (473)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (472)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (471)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (469)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (468)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (467)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (466)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (465)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (462)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (461)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (460)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (459)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (458)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (457)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (456)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (454)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (453)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (431)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (430)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (426)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (421)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (420)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (419)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (418)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (416)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (415)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (414)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (413)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (412)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (411)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (410)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (397)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (396)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (395)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (394)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (393)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (392)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (391)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (390)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (389)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (388)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (383)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (382)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (380)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (376)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (368)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (366)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (363)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (362)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (360)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (359)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (358)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (352)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (351)
#endif

/* _tempuri__GetWarnings * has binding name 'PointerTo_tempuri__GetWarnings' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetWarnings
#define SOAP_TYPE_PointerTo_tempuri__GetWarnings (259)
#endif

/* _tempuri__HasWarnings * has binding name 'PointerTo_tempuri__HasWarnings' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__HasWarnings
#define SOAP_TYPE_PointerTo_tempuri__HasWarnings (255)
#endif

/* _tempuri__GetErrors * has binding name 'PointerTo_tempuri__GetErrors' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetErrors
#define SOAP_TYPE_PointerTo_tempuri__GetErrors (251)
#endif

/* _tempuri__HasErrors * has binding name 'PointerTo_tempuri__HasErrors' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__HasErrors
#define SOAP_TYPE_PointerTo_tempuri__HasErrors (247)
#endif

/* _tempuri__GetMessage * has binding name 'PointerTo_tempuri__GetMessage' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetMessage
#define SOAP_TYPE_PointerTo_tempuri__GetMessage (243)
#endif

/* _tempuri__HasMessage * has binding name 'PointerTo_tempuri__HasMessage' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__HasMessage
#define SOAP_TYPE_PointerTo_tempuri__HasMessage (239)
#endif

/* _tempuri__IsSamplePlateTrayIn * has binding name 'PointerTo_tempuri__IsSamplePlateTrayIn' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__IsSamplePlateTrayIn
#define SOAP_TYPE_PointerTo_tempuri__IsSamplePlateTrayIn (235)
#endif

/* _tempuri__IsChipDocked * has binding name 'PointerTo_tempuri__IsChipDocked' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__IsChipDocked
#define SOAP_TYPE_PointerTo_tempuri__IsChipDocked (231)
#endif

/* _tempuri__GetOperationMode * has binding name 'PointerTo_tempuri__GetOperationMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetOperationMode
#define SOAP_TYPE_PointerTo_tempuri__GetOperationMode (227)
#endif

/* _tempuri__RunMaintenanceProcedure * has binding name 'PointerTo_tempuri__RunMaintenanceProcedure' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__RunMaintenanceProcedure
#define SOAP_TYPE_PointerTo_tempuri__RunMaintenanceProcedure (223)
#endif

/* _tempuri__GetNamesOfMaintenanceProcedures * has binding name 'PointerTo_tempuri__GetNamesOfMaintenanceProcedures' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNamesOfMaintenanceProcedures
#define SOAP_TYPE_PointerTo_tempuri__GetNamesOfMaintenanceProcedures (219)
#endif

/* _tempuri__GetStandbyAfterFinish * has binding name 'PointerTo_tempuri__GetStandbyAfterFinish' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetStandbyAfterFinish
#define SOAP_TYPE_PointerTo_tempuri__GetStandbyAfterFinish (215)
#endif

/* _tempuri__SetStandbyAfterFinish * has binding name 'PointerTo_tempuri__SetStandbyAfterFinish' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__SetStandbyAfterFinish
#define SOAP_TYPE_PointerTo_tempuri__SetStandbyAfterFinish (211)
#endif

/* _tempuri__LeaveStandby * has binding name 'PointerTo_tempuri__LeaveStandby' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__LeaveStandby
#define SOAP_TYPE_PointerTo_tempuri__LeaveStandby (207)
#endif

/* _tempuri__AbortScript * has binding name 'PointerTo_tempuri__AbortScript' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AbortScript
#define SOAP_TYPE_PointerTo_tempuri__AbortScript (203)
#endif

/* _tempuri__ResetRunset * has binding name 'PointerTo_tempuri__ResetRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__ResetRunset
#define SOAP_TYPE_PointerTo_tempuri__ResetRunset (199)
#endif

/* _tempuri__ResumeRunset * has binding name 'PointerTo_tempuri__ResumeRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__ResumeRunset
#define SOAP_TYPE_PointerTo_tempuri__ResumeRunset (195)
#endif

/* _tempuri__PauseRunsetAfter * has binding name 'PointerTo_tempuri__PauseRunsetAfter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__PauseRunsetAfter
#define SOAP_TYPE_PointerTo_tempuri__PauseRunsetAfter (191)
#endif

/* _tempuri__StartSelectedRunsetFrom * has binding name 'PointerTo_tempuri__StartSelectedRunsetFrom' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__StartSelectedRunsetFrom
#define SOAP_TYPE_PointerTo_tempuri__StartSelectedRunsetFrom (187)
#endif

/* _tempuri__StartSelectedRunset * has binding name 'PointerTo_tempuri__StartSelectedRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__StartSelectedRunset
#define SOAP_TYPE_PointerTo_tempuri__StartSelectedRunset (183)
#endif

/* _tempuri__MoveSamplePlateTrayIn * has binding name 'PointerTo_tempuri__MoveSamplePlateTrayIn' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayIn
#define SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayIn (179)
#endif

/* _tempuri__MoveSamplePlateTrayOut * has binding name 'PointerTo_tempuri__MoveSamplePlateTrayOut' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayOut
#define SOAP_TYPE_PointerTo_tempuri__MoveSamplePlateTrayOut (175)
#endif

/* _tempuri__GetCurrentSamplePlateId * has binding name 'PointerTo_tempuri__GetCurrentSamplePlateId' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetCurrentSamplePlateId
#define SOAP_TYPE_PointerTo_tempuri__GetCurrentSamplePlateId (171)
#endif

/* _tempuri__GetSamplePlateId * has binding name 'PointerTo_tempuri__GetSamplePlateId' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetSamplePlateId
#define SOAP_TYPE_PointerTo_tempuri__GetSamplePlateId (167)
#endif

/* _tempuri__SetSamplePlateId * has binding name 'PointerTo_tempuri__SetSamplePlateId' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__SetSamplePlateId
#define SOAP_TYPE_PointerTo_tempuri__SetSamplePlateId (163)
#endif

/* _tempuri__CreateRunset * has binding name 'PointerTo_tempuri__CreateRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__CreateRunset
#define SOAP_TYPE_PointerTo_tempuri__CreateRunset (159)
#endif

/* _tempuri__SelectRunset * has binding name 'PointerTo_tempuri__SelectRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__SelectRunset
#define SOAP_TYPE_PointerTo_tempuri__SelectRunset (155)
#endif

/* _tempuri__SelectMethod * has binding name 'PointerTo_tempuri__SelectMethod' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__SelectMethod
#define SOAP_TYPE_PointerTo_tempuri__SelectMethod (151)
#endif

/* _tempuri__GetMethodNamesOfRunset * has binding name 'PointerTo_tempuri__GetMethodNamesOfRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetMethodNamesOfRunset
#define SOAP_TYPE_PointerTo_tempuri__GetMethodNamesOfRunset (147)
#endif

/* _tempuri__GetAssayTypeOfRunset * has binding name 'PointerTo_tempuri__GetAssayTypeOfRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfRunset
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfRunset (143)
#endif

/* _tempuri__GetAssayTypeOfCurrentRunset * has binding name 'PointerTo_tempuri__GetAssayTypeOfCurrentRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentRunset
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentRunset (139)
#endif

/* _tempuri__GetNameOfCurrentRunset * has binding name 'PointerTo_tempuri__GetNameOfCurrentRunset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentRunset
#define SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentRunset (135)
#endif

/* _tempuri__GetAssayTypesOfAllRunsets * has binding name 'PointerTo_tempuri__GetAssayTypesOfAllRunsets' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllRunsets
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllRunsets (131)
#endif

/* _tempuri__GetNamesOfRunsetsOfAssayType * has binding name 'PointerTo_tempuri__GetNamesOfRunsetsOfAssayType' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType
#define SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsetsOfAssayType (127)
#endif

/* _tempuri__GetNamesOfRunsets * has binding name 'PointerTo_tempuri__GetNamesOfRunsets' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsets
#define SOAP_TYPE_PointerTo_tempuri__GetNamesOfRunsets (123)
#endif

/* _tempuri__GetAssayTypeOfMethod * has binding name 'PointerTo_tempuri__GetAssayTypeOfMethod' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfMethod
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfMethod (119)
#endif

/* _tempuri__GetAssayTypeOfCurrentMethod * has binding name 'PointerTo_tempuri__GetAssayTypeOfCurrentMethod' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentMethod
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypeOfCurrentMethod (115)
#endif

/* _tempuri__GetNameOfCurrentMethod * has binding name 'PointerTo_tempuri__GetNameOfCurrentMethod' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentMethod
#define SOAP_TYPE_PointerTo_tempuri__GetNameOfCurrentMethod (111)
#endif

/* _tempuri__GetAssayTypesOfAllMethods * has binding name 'PointerTo_tempuri__GetAssayTypesOfAllMethods' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllMethods
#define SOAP_TYPE_PointerTo_tempuri__GetAssayTypesOfAllMethods (107)
#endif

/* _tempuri__GetNamesOfMethodsOfAssayType * has binding name 'PointerTo_tempuri__GetNamesOfMethodsOfAssayType' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethodsOfAssayType
#define SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethodsOfAssayType (103)
#endif

/* _tempuri__GetNamesOfMethods * has binding name 'PointerTo_tempuri__GetNamesOfMethods' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethods
#define SOAP_TYPE_PointerTo_tempuri__GetNamesOfMethods (99)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (97)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (96)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (94)
#endif

/* arr__ArrayOfstring * has binding name 'PointerToarr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_PointerToarr__ArrayOfstring
#define SOAP_TYPE_PointerToarr__ArrayOfstring (92)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (98)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
